diff --git a/defs.mk b/defs.mk
new file mode 100644
index 0000000..f62cde1
--- /dev/null
+++ b/defs.mk
@@ -0,0 +1,20 @@
+# This file was generated by configure. Edits will disappear if you rerun
+# configure. If you find that you need to edit this file to make things
+# work, let the course staff know and we'll try to fix the configure script.
+#
+# The purpose of this file is to hold all the makefile definitions
+# needed to adjust the OS/161 build process to any particular
+# environment. If I've done it right, all you need to do is rerun the
+# configure script and make clean if you start working on a different
+# host OS. If I've done it mostly right, you may need to edit this
+# file but you still hopefully won't need to edit any of the
+# makefiles.
+#
+# The things that can be set here are documented in mk/os161.config.mk.
+#
+
+OSTREE=$(HOME)/root-team
+PLATFORM=sys161
+MACHINE=mips
+COMPAT_CFLAGS=
+COMPAT_TARGETS=
diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
index 0f773bd..d205710 100644
--- a/kern/arch/mips/syscall/syscall.c
+++ b/kern/arch/mips/syscall/syscall.c
@@ -36,6 +36,8 @@
 #include <current.h>
 #include <syscall.h>
 
+#include <endian.h>
+#include <copyinout.h>
 
 /*
  * System call dispatcher.
@@ -80,6 +82,9 @@ syscall(struct trapframe *tf)
 {
 	int callno;
 	int32_t retval;
+	uint32_t retval2;
+	uint64_t ar2,ret;
+	int whence;
 	int err;
 
 	KASSERT(curthread != NULL);
@@ -110,7 +115,52 @@ syscall(struct trapframe *tf)
 		break;
 
 	    /* Add stuff here */
- 
+	    case SYS_open:
+	    retval = open((userptr_t)tf->tf_a0,
+	    		(int)tf->tf_a1,&err);
+	    break;
+
+   	    case SYS_close:
+   	    err = close(tf->tf_a0);
+        break;
+
+        case SYS_read:
+        retval = read(tf->tf_a0,(userptr_t)tf->tf_a1,tf->tf_a2,&err);
+        break;
+
+        case SYS_write:
+        retval = write(tf->tf_a0,(userptr_t)tf->tf_a1,
+        		tf->tf_a2,&err);
+        break;
+
+        case SYS_dup2:
+        err = dup2(tf->tf_a0,tf->tf_a1);
+        break;
+
+        case SYS_lseek:
+        join32to64(tf->tf_a2,tf->tf_a3,&ar2);
+        //kprintf("Correct lseek called\n");
+           if ((err = copyin((const_userptr_t)(tf->tf_sp+16), &whence, sizeof(whence))) != 0) {
+               break;
+           }
+        ret = lseek((int)tf->tf_a0,ar2,whence,&err);
+        //kprintf("ret value %llu\n",ret);
+        split64to32(ret,(uint32_t *)&retval,(uint32_t *)&retval2);
+        //kprintf("Retval %d,%d\n",retval,retval2);
+        if (!err)
+        {
+        tf->tf_v1 = retval2;
+        }
+        break;
+
+        case SYS_chdir:
+        err = chdir((const_userptr_t)tf->tf_a0);
+        break;
+
+        case SYS___getcwd:
+        err = __getcwd((userptr_t)tf->tf_a0,(size_t)tf->tf_a1);
+        break;
+
 	    default:
 		kprintf("Unknown syscall %d\n", callno);
 		err = ENOSYS;
diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
index d527f61..4f9c76f 100644
--- a/kern/conf/conf.kern
+++ b/kern/conf/conf.kern
@@ -367,6 +367,7 @@ file      vfs/devnull.c
 file      syscall/loadelf.c
 file      syscall/runprogram.c
 file      syscall/time_syscalls.c
+file	  syscall/file_syscalls.c
 
 #
 # Startup and initialization
diff --git a/kern/include/fcntl.h b/kern/include/fcntl.h
new file mode 100644
index 0000000..40e3f6c
--- /dev/null
+++ b/kern/include/fcntl.h
@@ -0,0 +1,100 @@
+/*
+ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008
+ *	The President and Fellows of Harvard College.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _KERN_FCNTL_H_
+#define _KERN_FCNTL_H_
+
+/*
+ * Constants for libc's <fcntl.h>.
+ */
+
+
+/*
+ * Important
+ */
+
+/* Flags for open: choose one of these: */
+#define O_RDONLY      0      /* Open for read */
+#define O_WRONLY      1      /* Open for write */
+#define O_RDWR        2      /* Open for read and write */
+/* then or in any of these: */
+#define O_CREAT       4      /* Create file if it doesn't exist */
+#define O_EXCL        8      /* With O_CREAT, fail if file already exists */
+#define O_TRUNC      16      /* Truncate file upon open */
+#define O_APPEND     32      /* All writes happen at EOF (optional feature) */
+#define O_NOCTTY     64      /* Required by POSIX, != 0, but does nothing */
+
+/* Additional related definition */
+#define O_ACCMODE     3      /* mask for O_RDONLY/O_WRONLY/O_RDWR */
+
+/*
+ * Not so important
+ */
+
+/* operation codes for flock() */
+#define LOCK_SH         1       /* shared lock */
+#define LOCK_EX         2       /* exclusive lock */
+#define LOCK_UN         3       /* release the lock */
+#define LOCK_NB         4       /* flag: don't block */
+
+/*
+ * Mostly pretty useless
+ */
+
+/* fcntl() operations */
+#define F_DUPFD         0       /* like dup() but not quite */  
+#define F_GETFD         1       /* get per-handle flags */
+#define F_SETFD         2       /* set per-handle flags */
+#define F_GETFL         3       /* get per-file flags (O_* open flags) */
+#define F_SETFL         4       /* set per-file flags (O_* open flags) */
+#define F_GETOWN        5       /* get process/pgroup for SIGURG and SIGIO */
+#define F_SETOWN        6       /* set process/pgroup for SIGURG and SIGIO */
+#define F_GETLK         7       /* inspect record locks */
+#define F_SETLK         8       /* acquire record locks nonblocking */
+#define F_SETLKW        9       /* acquire record locks and wait */
+
+/* flag for F_GETFD and F_SETFD */
+#define FD_CLOEXEC      1       /* close-on-exec */
+
+/* modes for fcntl (F_GETLK/SETLK) locking */
+#define F_RDLCK         0       /* shared lock */
+#define F_WRLCK         1       /* exclusive lock */
+#define F_UNLCK         2       /* unlock */
+
+/* struct for fcntl (F_GETLK/SETLK) locking */
+struct flock {
+	off_t l_start;          /* place in file */
+	int l_whence;           /* SEEK_SET, SEEK_CUR, or SEEK_END */
+	int l_type;             /* F_RDLCK or F_WRLCK */
+	off_t l_len;            /* length of locked region */
+	pid_t l_pid;            /* process that holds the lock */
+};
+
+
+#endif /* _KERN_FCNTL_H_ */
diff --git a/kern/include/kern/limits.h b/kern/include/kern/limits.h
index 3fad3f2..b2afe55 100644
--- a/kern/include/kern/limits.h
+++ b/kern/include/kern/limits.h
@@ -96,5 +96,7 @@
 /* Max number of iovec structures at once for readv/writev/preadv/pwritev */
 #define __IOV_MAX       1024
 
+/*Maximum length of file name */
+
 
 #endif /* _KERN_LIMITS_H_ */
diff --git a/kern/include/seek.h b/kern/include/seek.h
new file mode 100644
index 0000000..cf1cfe6
--- /dev/null
+++ b/kern/include/seek.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008
+ *	The President and Fellows of Harvard College.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _KERN_SEEK_H_
+#define _KERN_SEEK_H_
+
+/*
+ * Codes for lseek(), which are shared in libc between <fcntl.h> and
+ * <unistd.h> and thus get their own file.
+ *
+ * These are pretty important. Back in the day (like 20+ years ago)
+ * people would often just write the values 0, 1, and 2, but that's
+ * really not recommended.
+ */
+
+#define SEEK_SET      0      /* Seek relative to beginning of file */
+#define SEEK_CUR      1      /* Seek relative to current position in file */
+#define SEEK_END      2      /* Seek relative to end of file */
+
+
+#endif /* _KERN_SEEK_H_ */
diff --git a/kern/include/synch.h b/kern/include/synch.h
index ac3714b..35565c6 100644
--- a/kern/include/synch.h
+++ b/kern/include/synch.h
@@ -74,6 +74,10 @@ void V(struct semaphore *);
  */
 struct lock {
         char *lk_name;
+        //added by vasanth
+        volatile struct thread *lock_owner;
+        struct wchan *lock_wchan;
+        struct spinlock spn_lock;
         // add what you need here
         // (don't forget to mark things volatile as needed)
 };
@@ -113,6 +117,7 @@ void lock_destroy(struct lock *);
 
 struct cv {
         char *cv_name;
+        struct wchan *cv_waitchan;
         // add what you need here
         // (don't forget to mark things volatile as needed)
 };
@@ -140,9 +145,18 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
 /*
  * 13 Feb 2012 : GWA : Reader-writer locks.
  */
-
+/* we use two waiting channels one for reader and one for writer we do this so that
+ *if a writer is waiting all the readers will be put on sleep until the writers are
+ *done with their writing
+ */
 struct rwlock {
         char *rwlock_name;
+        volatile int num_reader;
+        volatile int num_writer;
+        struct wchan *rlock_wchan;
+        struct wchan *wlock_wchan;
+        struct lock *rw_lock;
+
 };
 
 struct rwlock * rwlock_create(const char *);
diff --git a/kern/include/syscall.h b/kern/include/syscall.h
index befd3d8..6eb477d 100644
--- a/kern/include/syscall.h
+++ b/kern/include/syscall.h
@@ -57,5 +57,12 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
 
 int sys_reboot(int code);
 int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
-
+int open(userptr_t filename, int flags,int *err);
+int close(int fd);
+int read(int fd, userptr_t buf, size_t buflen,int *err);
+int write(int fd, userptr_t buf, size_t buflen,int *err);
+int dup2(int oldfd, int newfd);
+off_t lseek(int fd,off_t pos, int whence, int *err);
+int chdir(const_userptr_t pathname);
+int __getcwd(userptr_t buf, size_t buflen);
 #endif /* _SYSCALL_H_ */
diff --git a/kern/include/test.h b/kern/include/test.h
index 240d583..7e24bde 100644
--- a/kern/include/test.h
+++ b/kern/include/test.h
@@ -63,6 +63,17 @@ void whalemating_cleanup(void);
  * Traffic light.
  */
 
+//volatile unsigned long intersectionOccupied = 0;
+
+/**
+* Added by Babu:
+* Locks for each quadrants
+**/
+struct lock *lockquad0;
+struct lock *lockquad1;
+struct lock *lockquad2;
+struct lock *lockquad3;
+
 void inQuadrant(int);
 void leaveIntersection(void);
 int stoplight(int, char **);
@@ -72,6 +83,7 @@ void turnleft(void *, unsigned long);
 void turnright(void *, unsigned long);
 void stoplight_init(void);
 void stoplight_cleanup(void);
+void inQuadrantSync(unsigned long);
 
 /*
  * Test code.
diff --git a/kern/include/thread.h b/kern/include/thread.h
index 86706ca..65e1f08 100644
--- a/kern/include/thread.h
+++ b/kern/include/thread.h
@@ -38,7 +38,7 @@
 
 #include <spinlock.h>
 #include <threadlist.h>
-
+#include <limits.h>
 struct addrspace;
 struct cpu;
 struct vnode;
@@ -57,6 +57,7 @@ struct vnode;
 #define SAME_STACK(p1, p2)     (((p1) & STACK_MASK) == ((p2) & STACK_MASK))
 
 
+
 /* States a thread can be in. */
 typedef enum {
 	S_RUN,		/* running */
@@ -65,6 +66,15 @@ typedef enum {
 	S_ZOMBIE,	/* zombie; exited but not yet deleted */
 } threadstate_t;
 
+struct fTable{
+	    char *name;
+	    int status;
+	    off_t offset;
+	    int ref_count;
+	    struct lock *lock;
+	    struct vnode *vn;
+	};
+
 /* Thread structure. */
 struct thread {
 	/*
@@ -101,6 +111,8 @@ struct thread {
 	int t_curspl;			/* Current spl*() state */
 	int t_iplhigh_count;		/* # of times IPL has been raised */
 
+
+
 	/*
 	 * Public fields
 	 */
@@ -112,8 +124,11 @@ struct thread {
 	struct vnode *t_cwd;		/* current working directory */
 
 	/* add more here as needed */
+	struct fTable *ft[OPEN_MAX];          /*File table pointer*/
+	int priority;
 };
 
+
 /* Call once during system startup to allocate data structures. */
 void thread_bootstrap(void);
 
diff --git a/kern/include/unistd.h b/kern/include/unistd.h
new file mode 100644
index 0000000..30f2678
--- /dev/null
+++ b/kern/include/unistd.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008
+ *	The President and Fellows of Harvard College.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _KERN_UNISTD_H_
+#define _KERN_UNISTD_H_
+
+/* Constants for read/write/etc: special file handles */
+#define STDIN_FILENO  0      /* Standard input */
+#define STDOUT_FILENO 1      /* Standard output */
+#define STDERR_FILENO 2      /* Standard error */
+
+
+#endif /* _KERN_UNISTD_H_ */
diff --git a/kern/startup/main.c b/kern/startup/main.c
index be4c4b8..969575b 100644
--- a/kern/startup/main.c
+++ b/kern/startup/main.c
@@ -1,3 +1,4 @@
+/*vsubrama@buffalo.edu*/
 /*
  * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
  *	The President and Fellows of Harvard College.
diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
index 81d2f0e..b1d2a35 100644
--- a/kern/synchprobs/problems.c
+++ b/kern/synchprobs/problems.c
@@ -35,6 +35,7 @@
 #include <thread.h>
 #include <test.h>
 #include <synch.h>
+#include <wchan.h>
 
 /*
  * 08 Feb 2012 : GWA : Driver code is in kern/synchprobs/driver.c. We will
@@ -46,8 +47,71 @@
 // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
 // functions will allow you to do local initialization. They are called at
 // the top of the corresponding driver code.
-
+struct whalemating{
+	volatile int num_male_whale;
+	volatile int num_female_whale;
+	volatile int num_matchmaker_whale;
+	struct wchan *male_wchan;
+	struct wchan *female_wchan;
+	struct wchan *matchmaker_wchan;
+	struct wchan *match_wchan;
+	volatile int match_found;
+	struct lock *lock;
+};
+struct whalemating *whale_mating;
 void whalemating_init() {
+
+
+	whale_mating = kmalloc(sizeof(struct whalemating));
+	if (whale_mating == NULL)
+	{
+		return;
+	}
+	whale_mating->male_wchan = wchan_create("name");
+	if (whale_mating->male_wchan == NULL)
+	{
+		kfree(whale_mating);
+		return;
+	}
+	whale_mating->female_wchan = wchan_create("name");
+	if (whale_mating->female_wchan == NULL)
+	{
+		wchan_destroy(whale_mating->male_wchan);
+		kfree(whale_mating);
+		return;
+	}
+	whale_mating->matchmaker_wchan = wchan_create("name");
+	if (whale_mating->matchmaker_wchan == NULL)
+	{
+		wchan_destroy(whale_mating->male_wchan);
+		wchan_destroy(whale_mating->female_wchan);
+		kfree(whale_mating);
+		return;
+	}
+	whale_mating->match_wchan = wchan_create("name");
+	if (whale_mating->matchmaker_wchan == NULL)
+		{
+			wchan_destroy(whale_mating->male_wchan);
+			wchan_destroy(whale_mating->female_wchan);
+			wchan_destroy(whale_mating->match_wchan);
+			kfree(whale_mating);
+			return;
+		}
+	whale_mating->lock = lock_create("name");
+	if (whale_mating->lock == NULL)
+	{
+		wchan_destroy(whale_mating->male_wchan);
+		wchan_destroy(whale_mating->female_wchan);
+		wchan_destroy(whale_mating->matchmaker_wchan);
+		wchan_destroy(whale_mating->match_wchan);
+		kfree(whale_mating);
+		return;
+	}
+	whale_mating->num_male_whale = 0;
+	whale_mating->num_female_whale = 0;
+	whale_mating->num_matchmaker_whale = 0;
+	whale_mating->match_found=0;
+
   return;
 }
 
@@ -55,6 +119,12 @@ void whalemating_init() {
 // care if your problems leak memory, but if you do, use this to clean up.
 
 void whalemating_cleanup() {
+	wchan_destroy(whale_mating->male_wchan);
+	wchan_destroy(whale_mating->female_wchan);
+	wchan_destroy(whale_mating->matchmaker_wchan);
+	wchan_destroy(whale_mating->match_wchan);
+	lock_destroy(whale_mating->lock);
+	kfree(whale_mating);
   return;
 }
 
@@ -64,9 +134,28 @@ male(void *p, unsigned long which)
 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
   (void)which;
   
-  male_start();
-	// Implement this function 
-  male_end();
+ male_start();
+	// Implement this function
+ lock_acquire(whale_mating->lock);
+ while(whale_mating->num_male_whale>1)
+ {
+   wchan_lock(whale_mating->male_wchan);
+   lock_release(whale_mating->lock);
+   wchan_sleep(whale_mating->male_wchan);
+   lock_acquire(whale_mating->lock);
+ }
+ whale_mating->num_male_whale++;
+ wchan_wakeall(whale_mating->match_wchan);
+ while(!(whale_mating->match_found==1))
+ {
+	 wchan_lock(whale_mating->match_wchan);
+	 lock_release(whale_mating->lock);
+	 wchan_sleep(whale_mating->match_wchan);
+	 lock_acquire(whale_mating->lock);
+ }
+ lock_release(whale_mating->lock);
+ male_end();
+
 
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // whalemating driver can return to the menu cleanly.
@@ -81,15 +170,36 @@ female(void *p, unsigned long which)
   (void)which;
   
   female_start();
-	// Implement this function 
+
+	// Implement this function
+  lock_acquire(whale_mating->lock);
+   while(whale_mating->num_female_whale>1)
+   {
+     wchan_lock(whale_mating->female_wchan);
+     lock_release(whale_mating->lock);
+     wchan_sleep(whale_mating->female_wchan);
+     lock_acquire(whale_mating->lock);
+   }
+   whale_mating->num_female_whale++;
+   wchan_wakeall(whale_mating->match_wchan);
+   while(!(whale_mating->match_found==1))
+   {
+  	 wchan_lock(whale_mating->match_wchan);
+  	 lock_release(whale_mating->lock);
+  	 wchan_sleep(whale_mating->match_wchan);
+  	 lock_acquire(whale_mating->lock);
+   }
+   lock_release(whale_mating->lock);
   female_end();
-  
+
+
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // whalemating driver can return to the menu cleanly.
   V(whalematingMenuSemaphore);
   return;
 }
 
+
 void
 matchmaker(void *p, unsigned long which)
 {
@@ -97,15 +207,43 @@ matchmaker(void *p, unsigned long which)
   (void)which;
   
   matchmaker_start();
-	// Implement this function 
+  lock_acquire(whale_mating->lock);
+  while(whale_mating->num_matchmaker_whale>1)
+  {
+     wchan_lock(whale_mating->matchmaker_wchan);
+     lock_release(whale_mating->lock);
+     wchan_sleep(whale_mating->matchmaker_wchan);
+     lock_acquire(whale_mating->lock);
+  }
+  whale_mating->num_matchmaker_whale++;
+  wchan_wakeall(whale_mating->match_wchan);
+  while((whale_mating->num_male_whale == 0) || (whale_mating->num_female_whale == 0))
+  {
+	  wchan_lock(whale_mating->match_wchan);
+	  lock_release(whale_mating->lock);
+	  wchan_sleep(whale_mating->match_wchan);
+	  lock_acquire(whale_mating->lock);
+  }
+  whale_mating->match_found=1;
+  wchan_wakeall(whale_mating->match_wchan);
+  whale_mating->num_male_whale--;
+  whale_mating->num_female_whale--;
+  whale_mating->num_matchmaker_whale--;
+  whale_mating->match_found=0;
+  wchan_wakeall(whale_mating->male_wchan);
+  wchan_wakeall(whale_mating->female_wchan);
+  wchan_wakeall(whale_mating->matchmaker_wchan);
+  lock_release(whale_mating->lock);
+	// Implement this function
   matchmaker_end();
-  
+
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // whalemating driver can return to the menu cleanly.
   V(whalematingMenuSemaphore);
   return;
 }
 
+
 /*
  * You should implement your solution to the stoplight problem below. The
  * quadrant and direction mappings for reference: (although the problem is,
@@ -133,27 +271,48 @@ matchmaker(void *p, unsigned long which)
  * functions in drivers.c.
  */
 
+/**
+ * Added by Babu : 27 Feb 2012
+ * Solving Stop light problem with the help
+ * of locks and predefined semaphores.
+ */
+
+
 // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
 // functions will allow you to do local initialization. They are called at
 // the top of the corresponding driver code.
 
 void stoplight_init() {
-  return;
+	lockquad0 = lock_create("quad0lk");
+	lockquad1 = lock_create("quad1lk");
+	lockquad2 = lock_create("quad2lk");
+	lockquad3 = lock_create("quad3lk");
+	return;
 }
 
 // 20 Feb 2012 : GWA : Adding at the suggestion of Nikhil Londhe. We don't
 // care if your problems leak memory, but if you do, use this to clean up.
 
 void stoplight_cleanup() {
-  return;
+	lock_destroy(lockquad0);
+	lock_destroy(lockquad1);
+	lock_destroy(lockquad2);
+	lock_destroy(lockquad3);
+	return;
 }
 
 void
 gostraight(void *p, unsigned long direction)
 {
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
-  (void)direction;
-  
+	unsigned long destQuadrant1 = direction;
+	unsigned long destQuadrant2 = (direction + 3) % 4;
+	kprintf("go straight....\n");
+
+	inQuadrantSync(destQuadrant1);
+	inQuadrantSync(destQuadrant2);
+	leaveIntersection();
+
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
   V(stoplightMenuSemaphore);
@@ -163,8 +322,16 @@ gostraight(void *p, unsigned long direction)
 void
 turnleft(void *p, unsigned long direction)
 {
+	kprintf("turn left....\n");
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
-  (void)direction;
+	unsigned long destQuadrant1 = direction;
+	unsigned long destQuadrant2 = (direction + 3) % 4;
+	unsigned long destQuadrant3 = (direction + 2) % 4;
+
+	inQuadrantSync(destQuadrant1);
+	inQuadrantSync(destQuadrant2);
+	inQuadrantSync(destQuadrant3);
+	leaveIntersection();
   
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
@@ -175,11 +342,54 @@ turnleft(void *p, unsigned long direction)
 void
 turnright(void *p, unsigned long direction)
 {
+	kprintf("turn right....\n");
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
-  (void)direction;
+	unsigned long destQuadrant1 = direction;
+
+	inQuadrantSync(destQuadrant1);
+	leaveIntersection();
 
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
   V(stoplightMenuSemaphore);
   return;
 }
+
+/*
+ * Added by Babu
+ * Function which serve as a wrapper to inQuadrant operations
+ * along with synchronization primitive like lock
+ */
+void
+inQuadrantSync(unsigned long destQuadrant)
+{
+	struct lock *lockquad;
+	switch (destQuadrant)
+	{
+		case 0:
+			lockquad = lockquad0;
+			break;
+		case 1:
+			lockquad = lockquad1;
+			break;
+		case 2:
+			lockquad = lockquad2;
+			break;
+		case 3:
+			lockquad = lockquad3;
+			break;
+		default:
+			panic("unknown direction");
+			break;
+	}
+
+	/* If the lock is not held before, then acquire it */
+	if(lock_do_i_hold(lockquad))
+	{
+		lock_acquire(lockquad);
+		inQuadrant(destQuadrant);
+		kprintf("Releasing lock 0\n");
+		lock_release(lockquad);
+	}
+	return;
+}
diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
new file mode 100644
index 0000000..83f4d58
--- /dev/null
+++ b/kern/syscall/file_syscalls.c
@@ -0,0 +1,341 @@
+/*
+ * file_syscalls.c
+ *
+ *  Created on: Mar 8, 2014
+ *      Author: trinity
+ */
+#include <types.h>
+#include <copyinout.h>
+#include <lib.h>
+#include <thread.h>
+#include <syscall.h>
+#include <vfs.h>
+#include <vnode.h>
+#include <fcntl.h>
+#include <current.h>
+#include <synch.h>
+
+#include <uio.h>
+#include <kern/iovec.h>
+#include <seek.h>
+#include <stat.h>
+#include <kern/errno.h>
+
+int
+open(userptr_t filename, int flags,int *err)
+{
+	char *iobuff;
+	int rFlag,vfs_ret;
+	size_t aSize;
+	if (filename == NULL)
+	{
+		*err = EFAULT;
+		 return -1;
+	}
+	int tflags = flags & O_ACCMODE;
+	if ( tflags != O_RDONLY && tflags != O_WRONLY && tflags !=O_RDWR )
+	{
+		kprintf("Failing in arguments\n");
+		*err = EINVAL;
+		return -1;
+	}
+	int i;
+	for ( i=0;i<OPEN_MAX;i++)
+	{
+		if (curthread->ft[i] == NULL)
+		{
+			curthread->ft[i] = kmalloc(sizeof(struct fTable));
+			if (curthread->ft[i] == NULL)
+			{
+				*err = ENOMEM;
+				return -1;
+			}
+			curthread->ft[i]->lock = lock_create(curthread->t_name);
+			if (curthread->ft[i]->lock == NULL)
+			{
+				kfree(curthread->ft[i]);
+				curthread->ft[i] = NULL;
+				*err = ENOMEM;
+				return -1;
+			}
+			curthread->ft[i]->offset=0;
+			curthread->ft[i]->ref_count=(curthread->ft[i]->ref_count) + 1;
+			curthread->ft[i]->status = flags;
+			iobuff = (char *)kmalloc(PATH_MAX*sizeof(char));
+			if (iobuff == NULL)
+			{
+				lock_destroy(curthread->ft[i]->lock);
+				kfree(curthread->ft[i]);
+				curthread->ft[i] = NULL;
+				*err = ENOMEM;
+				return -1;
+			}
+			rFlag = copyinstr((const_userptr_t)filename,iobuff,PATH_MAX,&aSize);
+			if(rFlag)
+			{
+				kfree(iobuff);
+				lock_destroy(curthread->ft[i]->lock);
+				kfree(curthread->ft[i]);
+				curthread->ft[i] = NULL;
+				*err = EFAULT;
+				return -1;
+			}
+			vfs_ret=vfs_open((char *)filename,flags,0664,&(curthread->ft[i]->vn));
+			if(vfs_ret)
+			{
+				kfree(iobuff);
+				lock_destroy(curthread->ft[i]->lock);
+				kfree(curthread->ft[i]);
+				curthread->ft[i] = NULL;
+				*err = vfs_ret;
+				return -1;
+			}
+			*err = vfs_ret;
+			return i;
+		}
+	}
+	return 0;
+}
+int close(int fd)
+{
+	if ( fd < 0 || fd > OPEN_MAX)
+	{
+		return EBADF;
+	}
+	if (curthread->ft[fd] == NULL)
+	{
+		return EBADF;
+	}
+	lock_acquire(curthread->ft[fd]->lock);
+	curthread->ft[fd]->ref_count=(curthread->ft[fd]->ref_count)-1;
+	if(curthread->ft[fd]->ref_count == 0)
+	{
+		vfs_close(curthread->ft[fd]->vn);
+		lock_release(curthread->ft[fd]->lock);
+		lock_destroy(curthread->ft[fd]->lock);
+		kfree(curthread->ft[fd]);
+		curthread->ft[fd]=NULL;
+		return 0;
+	}
+	else
+	{
+		lock_release(curthread->ft[fd]->lock);
+		curthread->ft[fd]=NULL;
+		return 0;
+	}
+	return 0;
+}
+
+int
+read(int fd, userptr_t buf, size_t buflen,int *err)
+{
+	int ret;
+	if ( fd < 0 || fd > OPEN_MAX)
+	{
+		*err = EBADF;
+		return -1;
+	}
+	if (curthread->ft[fd] == NULL)
+	{
+		*err = EBADF;
+		return -1;
+	}
+	if (buf == NULL)
+	{
+		*err = EFAULT;
+		return -1;
+	}
+	lock_acquire(curthread->ft[fd]->lock);
+	struct iovec iov;
+	struct uio uio;
+
+	iov.iov_ubase = buf;
+	iov.iov_len = buflen;
+
+	uio.uio_iov = &iov;
+	uio.uio_iovcnt = 1;
+	uio.uio_offset = curthread->ft[fd]->offset;
+	uio.uio_resid = buflen;
+	uio.uio_segflg = UIO_USERSPACE;
+	uio.uio_space = curthread->t_addrspace;
+	uio.uio_rw=UIO_READ;
+	if((ret = VOP_READ(curthread->ft[fd]->vn,&uio))!=0)
+	{
+		*err = ret;
+		return -1;
+	}
+	int diff = uio.uio_offset - curthread->ft[fd]->offset;
+	curthread->ft[fd]->offset=uio.uio_offset;
+	lock_release(curthread->ft[fd]->lock);
+	*err = 0;
+	return diff;
+}
+int
+write(int fd, userptr_t buf, size_t buflen, int *err)
+{
+	int ret;
+	if ( fd < 0 || fd > OPEN_MAX)
+	{
+		*err = EBADF;
+		return -1;
+	}
+	if (curthread->ft[fd] == NULL)
+	{
+		*err = EBADF;
+		return -1;
+	}
+	if (buf == NULL)
+	{
+		*err = EFAULT;
+		return -1;
+	}
+	lock_acquire(curthread->ft[fd]->lock);
+	struct iovec iov;
+	struct uio uio;
+	iov.iov_ubase = buf;
+	iov.iov_len = buflen;
+	uio.uio_iov = &iov;
+	uio.uio_iovcnt = 1;
+	uio.uio_offset = curthread->ft[fd]->offset;
+	uio.uio_resid = buflen;
+	uio.uio_segflg = UIO_USERSPACE;
+	uio.uio_space = curthread->t_addrspace;
+	uio.uio_rw=UIO_WRITE;
+	if((ret = VOP_WRITE(curthread->ft[fd]->vn,&uio))!=0)
+	{
+		*err = ret;
+		return -1;
+	}
+	int diff = uio.uio_offset - curthread->ft[fd]->offset ;
+	curthread->ft[fd]->offset=uio.uio_offset;
+	lock_release(curthread->ft[fd]->lock);
+	*err=0;
+	return diff;
+}
+off_t
+lseek(int fd,off_t pos, int whence,int *err)
+{
+	off_t nPos=0;
+	struct stat eoFILE;
+	//kprintf("lseek entered\n");
+	if (curthread->ft[fd] == NULL)
+	{
+		*err = EBADF;
+		 return -1;
+	}
+	//kprintf("curthread->ft[fd] == NULL\n");
+	if ( fd < 0 || fd > OPEN_MAX)
+	{
+		*err = EBADF;
+		 return -1;
+	}
+	//kprintf("fd < 0 || fd > OPEN_MAX\n");
+	if (whence != SEEK_SET && whence != SEEK_CUR && whence != SEEK_END)
+	{
+		*err = EINVAL;
+		return -1;
+	}
+	//kprintf("whence != SEEK_SET || whence != SEEK_CUR || whence != SEEK_END\n");
+	//kprintf("Acquiring lock\n");
+	lock_acquire(curthread->ft[fd]->lock);
+	//kprintf("Stat gathering\n");
+	VOP_STAT(curthread->ft[fd]->vn,&eoFILE);
+	if (whence == SEEK_SET)
+	{
+		nPos = pos;
+	}
+	if (whence == SEEK_CUR)
+	{
+		nPos = curthread->ft[fd]->offset+pos;
+	}
+	if (whence == SEEK_END)
+	{
+		nPos = eoFILE.st_size+pos;
+	}
+	if (nPos < 0)
+	{
+		*err = EINVAL;
+		lock_release(curthread->ft[fd]->lock);
+		return -1;
+	}
+	//kprintf("NPos %llu\n",nPos);
+	*err = VOP_TRYSEEK(curthread->ft[fd]->vn,nPos);
+	if (*err)
+	{
+		lock_release(curthread->ft[fd]->lock);
+	    return -1;
+	}
+	curthread->ft[fd]->offset = nPos;
+	lock_release(curthread->ft[fd]->lock);
+	//kprintf("New position  %llu\n",nPos);
+	return curthread->ft[fd]->offset;
+}
+int
+dup2(int oldfd, int newfd)
+{
+	int ret;
+		if ( oldfd < 0 || oldfd > OPEN_MAX || newfd < 0 || newfd > OPEN_MAX)
+		{
+			return -1;
+		}
+		if (curthread->ft[oldfd] == NULL || curthread->ft[newfd] == NULL)
+		{
+			return -1;
+		}
+		if (curthread->ft[oldfd] == curthread->ft[newfd] || oldfd == newfd)
+		{
+		    return oldfd;
+		}
+		if (curthread->ft[newfd] != NULL)
+		{
+		   ret = close(newfd);
+		   if (ret)
+		      return -1;
+		}
+		curthread->ft[newfd] = curthread->ft[oldfd];
+		lock_acquire(curthread->ft[newfd]->lock);
+		curthread->ft[newfd]->ref_count++;
+		lock_release(curthread->ft[newfd]->lock);
+		return newfd;
+}
+
+int
+chdir(const_userptr_t pathname)
+{
+	char new_path[PATH_MAX];
+	size_t get;
+
+	if (pathname == NULL)
+	{
+		return -1;
+	}
+
+	int ret = copyinstr(pathname,new_path,PATH_MAX,&get);
+
+	if (ret)
+	{
+		return -1;
+	}
+
+	return vfs_chdir(new_path);
+}
+int
+__getcwd(userptr_t buf, size_t buflen)
+{
+	char path[PATH_MAX];
+	int ret;
+	struct iovec iov;
+	struct uio uio;
+	uio_kinit(&iov,&uio,path,PATH_MAX,0,UIO_READ);
+	ret = vfs_getcwd(&uio);
+	if (ret)
+	{
+		return -1;
+	}
+	ret = copyout((userptr_t)path,buf,buflen);
+	if (ret)
+	{
+		return -1;
+	}
+	return uio.uio_offset;
+}
diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
index a6f45c8..d18567f 100644
--- a/kern/syscall/runprogram.c
+++ b/kern/syscall/runprogram.c
@@ -44,7 +44,8 @@
 #include <vfs.h>
 #include <syscall.h>
 #include <test.h>
-
+#include <synch.h>
+#include <unistd.h>
 /*
  * Load program "progname" and start running it in usermode.
  * Does not return except on error.
@@ -58,6 +59,56 @@ runprogram(char *progname)
 	vaddr_t entrypoint, stackptr;
 	int result;
 
+	struct vnode *o, *i, *e;
+	char *con0 = kstrdup("con:");
+	char *con1 = kstrdup("con:");
+	char *con2 = kstrdup("con:");
+	int inpTemp = vfs_open(con0,O_RDONLY,0664,&i);
+	int outTemp = vfs_open(con1,O_WRONLY,0664,&o);
+	int errTemp = vfs_open(con2,O_WRONLY,0664,&e);
+	KASSERT(inpTemp!=1);
+	KASSERT(outTemp!=1);
+	KASSERT(errTemp!=1);
+
+	struct fTable *input, *output, *error;
+	input= kmalloc(sizeof(struct fTable));
+	output = kmalloc(sizeof(struct fTable));
+	error = kmalloc(sizeof(struct fTable));
+	KASSERT(input!=NULL);
+	KASSERT(output!=NULL);
+	KASSERT(error!=NULL);
+
+	input->name=kstrdup("Standard_Input");
+	input->offset=0;
+	input->ref_count =0;
+	input->status=O_RDONLY;
+	input->vn=i;
+	input->lock=lock_create("Standard Input");
+
+	output->name=kstrdup("Standard_Output");
+	output->offset=0;
+	output->ref_count =0;
+	output->status=O_WRONLY;
+	output->vn=o;
+	output->lock=lock_create("Standard Output");
+
+	error->name=kstrdup("Standard_Error");
+	error->offset=0;
+	error->ref_count =0;
+	error->status=O_WRONLY;
+	error->vn=e;
+	error->lock=lock_create("Standard Error");
+	KASSERT(input->lock!=NULL);
+	KASSERT(output->lock!=NULL);
+	KASSERT(error->lock!=NULL);
+
+	curthread->ft[STDIN_FILENO]=input;
+	curthread->ft[STDOUT_FILENO]=output;
+	curthread->ft[STDERR_FILENO]=error;
+	kfree(con0);
+	kfree(con1);
+	kfree(con2);
+	//kprintf("IO fd's initialized\n");
 	/* Open the file. */
 	result = vfs_open(progname, O_RDONLY, 0, &v);
 	if (result) {
diff --git a/kern/test/malloctest.c b/kern/test/malloctest.c
index b4dd87c..a8e4ba8 100644
--- a/kern/test/malloctest.c
+++ b/kern/test/malloctest.c
@@ -60,7 +60,6 @@ mallocthread(void *sm, unsigned long num)
 	void *oldptr=NULL;
 	void *oldptr2=NULL;
 	int i;
-
 	for (i=0; i<NTRIES; i++) {
 		ptr = kmalloc(ITEMSIZE);
 		if (ptr==NULL) {
diff --git a/kern/test/synchtest.c b/kern/test/synchtest.c
index d072469..f106f4a 100644
--- a/kern/test/synchtest.c
+++ b/kern/test/synchtest.c
@@ -309,21 +309,23 @@ cvtest2thread(void *junk, unsigned long num)
 {
 	int i;
 	(void)junk;
-
 	for (i=0; i<NCVLOOPS; i++) {
 		lock_acquire(testlock);
 		while (testval1 != num) {
-      testval2 = 0;
+			testval2 = 0;
+
 			cv_wait(testcv, testlock);
-      testval2 = 0xFFFFFFFF;
+			testval2 = 0xFFFFFFFF;
 		}
 		testval2 = num;
+
 		cv_broadcast(testcv, testlock);
 		thread_yield();
 		kprintf("Thread %lu\n", testval2);
 		testval1 = (testval1 + NTHREADS - 1)%NTHREADS;
 		lock_release(testlock);
 	}
+	kprintf("cv2 test exiting\n");
 	V(donesem);
 }
 
@@ -344,6 +346,7 @@ cvtest2(int nargs, char **args)
 	for (i=0; i<NTHREADS; i++) {
 		result = thread_fork("synchtest", cvtest2thread, NULL, i,
 				      NULL);
+		//kprintf("Thread fork failure\n");
 		if (result) {
 			panic("cvtest: thread_fork failed: %s\n",
 			      strerror(result));
diff --git a/kern/thread/synch.c b/kern/thread/synch.c
index 9a7468c..7828129 100644
--- a/kern/thread/synch.c
+++ b/kern/thread/synch.c
@@ -47,20 +47,20 @@
 struct semaphore *
 sem_create(const char *name, int initial_count)
 {
-        struct semaphore *sem;
+	struct semaphore *sem;
 
-        KASSERT(initial_count >= 0);
+	KASSERT(initial_count >= 0);
 
-        sem = kmalloc(sizeof(struct semaphore));
-        if (sem == NULL) {
-                return NULL;
-        }
+	sem = kmalloc(sizeof(struct semaphore));
+	if (sem == NULL) {
+			return NULL;
+	}
 
-        sem->sem_name = kstrdup(name);
-        if (sem->sem_name == NULL) {
-                kfree(sem);
-                return NULL;
-        }
+	sem->sem_name = kstrdup(name);
+	if (sem->sem_name == NULL) {
+			kfree(sem);
+			return NULL;
+	}
 
 	sem->sem_wchan = wchan_create(sem->sem_name);
 	if (sem->sem_wchan == NULL) {
@@ -70,9 +70,9 @@ sem_create(const char *name, int initial_count)
 	}
 
 	spinlock_init(&sem->sem_lock);
-        sem->sem_count = initial_count;
+    sem->sem_count = initial_count;
 
-        return sem;
+    return sem;
 }
 
 void
@@ -81,8 +81,8 @@ sem_destroy(struct semaphore *sem)
         KASSERT(sem != NULL);
 
 	/* wchan_cleanup will assert if anyone's waiting on it */
-	spinlock_cleanup(&sem->sem_lock);
-	wchan_destroy(sem->sem_wchan);
+		spinlock_cleanup(&sem->sem_lock);
+		wchan_destroy(sem->sem_wchan);
         kfree(sem->sem_name);
         kfree(sem);
 }
@@ -100,7 +100,7 @@ P(struct semaphore *sem)
          */
         KASSERT(curthread->t_in_interrupt == false);
 
-	spinlock_acquire(&sem->sem_lock);
+        spinlock_acquire(&sem->sem_lock);
         while (sem->sem_count == 0) {
 		/*
 		 * Bridge to the wchan lock, so if someone else comes
@@ -120,24 +120,22 @@ P(struct semaphore *sem)
 		 */
 		wchan_lock(sem->sem_wchan);
 		spinlock_release(&sem->sem_lock);
-                wchan_sleep(sem->sem_wchan);
-
+	        wchan_sleep(sem->sem_wchan);
 		spinlock_acquire(&sem->sem_lock);
-        }
-        KASSERT(sem->sem_count > 0);
-        sem->sem_count--;
+	}
+	KASSERT(sem->sem_count > 0);
+	sem->sem_count--;
 	spinlock_release(&sem->sem_lock);
 }
 
 void
 V(struct semaphore *sem)
 {
-        KASSERT(sem != NULL);
+    KASSERT(sem != NULL);
+	spinlock_acquire(&sem->sem_lock); 
 
-	spinlock_acquire(&sem->sem_lock);
-
-        sem->sem_count++;
-        KASSERT(sem->sem_count > 0);
+	sem->sem_count++;
+	KASSERT(sem->sem_count > 0);
 	wchan_wakeone(sem->sem_wchan);
 
 	spinlock_release(&sem->sem_lock);
@@ -158,20 +156,35 @@ lock_create(const char *name)
         }
 
         lock->lk_name = kstrdup(name);
+
         if (lock->lk_name == NULL) {
                 kfree(lock);
                 return NULL;
         }
-        
+        //added by vasanth
+        lock->lock_owner=NULL;
+        lock->lock_wchan = wchan_create(lock->lk_name);
+		if (lock->lock_wchan == NULL)
+		{
+			kfree(lock->lk_name);
+			kfree(lock);
+			return NULL;
+		}
+		spinlock_init(&lock->spn_lock);
+
         // add stuff here as needed
-        
         return lock;
 }
 
 void
 lock_destroy(struct lock *lock)
 {
+
         KASSERT(lock != NULL);
+        //added by vasanth
+        //KASSERT(lock->lock_owner == NULL);
+        spinlock_cleanup(&lock->spn_lock);
+        wchan_destroy(lock->lock_wchan);
 
         // add stuff here as needed
         
@@ -182,27 +195,61 @@ lock_destroy(struct lock *lock)
 void
 lock_acquire(struct lock *lock)
 {
+		//added by vasanth
+		KASSERT(lock != NULL);
+		spinlock_acquire(&lock->spn_lock);
+		while (lock->lock_owner!=NULL)
+		{
+			wchan_lock(lock->lock_wchan);
+			spinlock_release(&lock->spn_lock);
+			wchan_sleep(lock->lock_wchan);
+			spinlock_acquire(&lock->spn_lock);
+		}
+		lock->lock_owner=curthread;
+		spinlock_release(&lock->spn_lock);
         // Write this
 
-        (void)lock;  // suppress warning until code gets written
+       // (void)lock;  // suppress warning until code gets written
 }
 
 void
 lock_release(struct lock *lock)
 {
-        // Write this
-
-        (void)lock;  // suppress warning until code gets written
+		//added by vasanth
+ 		KASSERT(lock != NULL);
+		spinlock_acquire(&lock->spn_lock);
+		if(lock->lock_owner==curthread)
+		{
+			lock->lock_owner=NULL;
+			wchan_wakeall(lock->lock_wchan);
+		}
+		spinlock_release(&lock->spn_lock);
+		// Write this
+
+
+        //(void)lock;  // suppress warning until code gets written
 }
 
 bool
 lock_do_i_hold(struct lock *lock)
 {
         // Write this
-
-        (void)lock;  // suppress warning until code gets written
-
-        return true; // dummy until code gets written
+	bool status;
+		spinlock_acquire(&lock->spn_lock);
+		if (lock->lock_owner==curthread)
+		{
+			status = true;
+		}
+		else
+		{
+			status = false;
+		}
+		spinlock_release(&lock->spn_lock);
+		return status;
+
+        //(void)lock;  // suppress warning until code gets written
+
+        //return true; // dummy until code gets written
 }
 
 ////////////////////////////////////////////////////////////
@@ -217,26 +264,36 @@ cv_create(const char *name)
 
         cv = kmalloc(sizeof(struct cv));
         if (cv == NULL) {
-                return NULL;
+        	return NULL;
         }
 
         cv->cv_name = kstrdup(name);
         if (cv->cv_name==NULL) {
-                kfree(cv);
-                return NULL;
+            kfree(cv);
+            return NULL;
         }
         
         // add stuff here as needed
+        /* Added by Babu :
+        * Adding a wait channel for making the threads wait during cv_acquire
+        */
+        cv->cv_waitchan = wchan_create(cv->cv_name);
+
         
         return cv;
 }
 
+
 void
 cv_destroy(struct cv *cv)
 {
         KASSERT(cv != NULL);
 
         // add stuff here as needed
+        /*
+         * Added by Babu : wchan destructor
+         */
+        wchan_destroy(cv->cv_waitchan);
         
         kfree(cv->cv_name);
         kfree(cv);
@@ -245,23 +302,180 @@ cv_destroy(struct cv *cv)
 void
 cv_wait(struct cv *cv, struct lock *lock)
 {
-        // Write this
-        (void)cv;    // suppress warning until code gets written
-        (void)lock;  // suppress warning until code gets written
+    // Write this
+	/** Release lock, wait and then acquire once awake */
+	KASSERT(cv != NULL);
+	KASSERT(lock != NULL);
+
+	//kprintf("Waiting in CV\n");
+
+	if(lock_do_i_hold(lock))
+		lock_release(lock);
+
+	//kprintf("Sleeping in CV\n");
+	wchan_lock(cv->cv_waitchan);
+	wchan_sleep(cv->cv_waitchan);
+
+	//kprintf("Came out of CV\n");
+
+	if(!lock_do_i_hold(lock))
+		lock_acquire(lock);
 }
 
 void
 cv_signal(struct cv *cv, struct lock *lock)
 {
-        // Write this
-	(void)cv;    // suppress warning until code gets written
-	(void)lock;  // suppress warning until code gets written
+    // Write this
+	KASSERT(cv != NULL);
+	KASSERT(lock != NULL);
+
+	/*if(!lock_do_i_hold(lock))
+		lock_acquire(lock);*/
+
+	/*if(lock_do_i_hold(lock))
+		lock_release(lock);*/
+
+	//kprintf("Signaling CV\n");
+
+	wchan_wakeone(cv->cv_waitchan);
+	//wchan_unlock(cv->cv_waitchan);
+
+	/*if(!lock_do_i_hold(lock))
+		lock_acquire(lock);*/
+	(void) lock;
 }
 
 void
 cv_broadcast(struct cv *cv, struct lock *lock)
 {
 	// Write this
-	(void)cv;    // suppress warning until code gets written
-	(void)lock;  // suppress warning until code gets written
+	KASSERT(cv != NULL);
+	KASSERT(lock != NULL);
+
+	/*if(!lock_do_i_hold(lock))
+		lock_acquire(lock);*/
+
+	/*if(lock_do_i_hold(lock))
+		lock_release(lock);*/
+
+	//kprintf("Broadcasting CV\n");
+	wchan_wakeall(cv->cv_waitchan);
+
+
+	/*if(!lock_do_i_hold(lock))
+		lock_acquire(lock);*/
+
+
+	(void) lock;
+}
+
+struct rwlock *
+rwlock_create(const char *name)
+{
+	struct rwlock *rwlock;
+	rwlock = kmalloc(sizeof(struct rwlock));
+	if (rwlock == NULL)
+	{
+		return NULL;
+	}
+	rwlock->rwlock_name=kstrdup(name);
+	if (rwlock->rwlock_name == NULL)
+	{
+	    kfree(rwlock);
+	    return NULL;
+	}
+	rwlock->rlock_wchan = wchan_create(rwlock->rwlock_name);
+	if (rwlock->rlock_wchan == NULL)
+	{
+		kfree(rwlock->rwlock_name);
+		kfree(rwlock);
+		return NULL;
+	}
+	rwlock->wlock_wchan = wchan_create(rwlock->rwlock_name);
+	if (rwlock->wlock_wchan == NULL)
+	{
+		kfree(rwlock->rwlock_name);
+		wchan_destroy(rwlock->rlock_wchan);
+		kfree(rwlock);
+		return NULL;
+	}
+	rwlock->num_reader=0;
+	rwlock->num_writer=0;
+	rwlock->rw_lock = lock_create(rwlock->rwlock_name);
+	if (rwlock->rw_lock == NULL)
+	{
+		kfree(rwlock->rwlock_name);
+		wchan_destroy(rwlock->rlock_wchan);
+		wchan_destroy(rwlock->wlock_wchan);
+		kfree(rwlock);
+		return NULL;
+	}
+	return rwlock;
+
+}
+void
+rwlock_destroy(struct rwlock *rwlock)
+{
+	KASSERT(rwlock != NULL);
+	lock_destroy(rwlock->rw_lock);
+	wchan_destroy(rwlock->rlock_wchan);
+	wchan_destroy(rwlock->wlock_wchan);
+	kfree(rwlock->rwlock_name);
+	kfree(rwlock);
+}
+
+void
+rwlock_acquire_read(struct rwlock *rwlock)
+{
+	KASSERT(rwlock != NULL);
+	lock_acquire(rwlock->rw_lock);
+	while (rwlock->num_writer>0)
+	{
+		wchan_lock(rwlock->rlock_wchan);
+		lock_release(rwlock->rw_lock);
+		wchan_sleep(rwlock->rlock_wchan);
+		lock_acquire(rwlock->rw_lock);
+	}
+	rwlock->num_reader++;
+	lock_release(rwlock->rw_lock);
+}
+void
+rwlock_release_read(struct rwlock *rwlock)
+{
+	KASSERT(rwlock != NULL);
+	KASSERT(rwlock->num_reader > 0);
+	lock_acquire(rwlock->rw_lock);
+	if(rwlock->num_reader > 0)
+	{
+		rwlock->num_reader--;
+	}
+	wchan_wakeall(rwlock->wlock_wchan);
+	wchan_wakeall(rwlock->rlock_wchan);
+	lock_release(rwlock->rw_lock);
+}
+void
+rwlock_acquire_write(struct rwlock *rwlock)
+{
+	KASSERT(rwlock != NULL);
+	lock_acquire(rwlock->rw_lock);
+	while ((rwlock->num_reader>0) || (rwlock->num_writer > 0))
+	{
+		wchan_lock(rwlock->wlock_wchan);
+		lock_release(rwlock->rw_lock);
+		wchan_sleep(rwlock->wlock_wchan);
+		lock_acquire(rwlock->rw_lock);
+	}
+	rwlock->num_writer++;
+	lock_release(rwlock->rw_lock);
+}
+void
+rwlock_release_write(struct rwlock *rwlock)
+{
+	KASSERT(rwlock != NULL);
+	KASSERT(rwlock->num_writer > 0);
+	lock_acquire(rwlock->rw_lock);
+	rwlock->num_writer--;
+	wchan_wakeall(rwlock->rlock_wchan);
+	wchan_wakeall(rwlock->wlock_wchan);
+	lock_release(rwlock->rw_lock);
 }
diff --git a/kern/thread/thread.c b/kern/thread/thread.c
index e7235e3..b1dcc73 100644
--- a/kern/thread/thread.c
+++ b/kern/thread/thread.c
@@ -47,6 +47,7 @@
 #include <addrspace.h>
 #include <mainbus.h>
 #include <vnode.h>
+#include <limits.h>
 
 #include "opt-synchprobs.h"
 #include "opt-defaultscheduler.h"
@@ -153,6 +154,19 @@ thread_create(const char *name)
 	thread->t_cwd = NULL;
 
 	/* If you add to struct thread, be sure to initialize here */
+	/*File descriptor*/
+		int i;
+		for (i=0;i<OPEN_MAX;i++)
+		{
+			thread->ft[i] = kmalloc(sizeof(struct file_table *));
+			if (thread->ft[i] == NULL)
+					{
+						kfree(thread);
+						return NULL;
+					}
+			thread->ft[i]=0;
+		}
+		thread->priority = 5;
 
 	return thread;
 }
@@ -263,6 +277,7 @@ thread_destroy(struct thread *thread)
 	thread->t_wchan_name = "DESTROYED";
 
 	kfree(thread->t_name);
+	//if(thread->ft!=NULL)kfree(thread->ft);
 	kfree(thread);
 }
 
@@ -483,7 +498,6 @@ thread_fork(const char *name,
 	    struct thread **ret)
 {
 	struct thread *newthread;
-
 	newthread = thread_create(name);
 	if (newthread == NULL) {
 		return ENOMEM;
@@ -520,6 +534,8 @@ thread_fork(const char *name,
 	 */
 	newthread->t_iplhigh_count++;
 
+	//Might have to add the copy of the file table --vasanth
+
 	/* Set up the switchframe so entrypoint() gets called */
 	switchframe_init(newthread, entrypoint, data1, data2);
 
@@ -574,6 +590,11 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
 
 	/* Check the stack guard band. */
 	thread_checkstack(cur);
+	if ( cur->priority > 0 && cur->priority< 10)
+	{
+		if (newstate == S_SLEEP)cur->priority--;     //increment priority if thread was sleeping
+		if (newstate == S_READY)cur->priority++;     //decrement priority if thread was ready
+	}
 
 	/* Lock the run queue. */
 	spinlock_acquire(&curcpu->c_runqueue_lock);
@@ -585,6 +606,7 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
 		return;
 	}
 
+
 	/* Put the thread in the right place. */
 	switch (newstate) {
 	    case S_RUN:
@@ -618,6 +640,7 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
 	}
 	cur->t_state = newstate;
 
+
 	/*
 	 * Get the next thread. While there isn't one, call md_idle().
 	 * curcpu->c_isidle must be true when md_idle is
@@ -853,6 +876,24 @@ schedule(void)
 {
   // 28 Feb 2012 : GWA : Implement your scheduler that prioritizes
   // "interactive" threads here.
+	spinlock_acquire(&curcpu->c_runqueue_lock);
+	if (curcpu->c_runqueue.tl_count>1)
+	{
+		struct threadlistnode *tnode = &curcpu->c_runqueue.tl_head;
+		while(tnode->tln_next->tln_next != NULL )
+		{
+			int head_priority =(int) curcpu->c_runqueue.tl_head.tln_next->tln_self->priority;
+			tnode = tnode->tln_next;
+			int curr_priority = tnode->tln_self->priority;
+			//kprintf("curr_priority %d\n",curr_priority);
+			if ( curr_priority < head_priority)
+			{
+				threadlist_remove(&curcpu->c_runqueue,tnode->tln_self);
+				threadlist_addhead(&curcpu->c_runqueue,tnode->tln_self);
+			}
+		}
+	}
+	spinlock_release(&curcpu->c_runqueue_lock);
 }
 #endif
 
diff --git a/mk/os161.config.mk b/mk/os161.config.mk
index 3de8771..8790d16 100644
--- a/mk/os161.config.mk
+++ b/mk/os161.config.mk
@@ -295,7 +295,7 @@
 #
 
 # Locations of things.
-OSTREE=$(HOME)/os161/root	# Root directory to install into.
+OSTREE=$(HOME)/os161/root-team	# Root directory to install into.
 WORKDIR=$(TOP)/build		# Top of tree to build into.
 BUILDSYMLINKS=yes		# yes => link build -> $(BUILDTOP)/$(HERE).
 
diff --git a/submit.patch b/submit.patch
new file mode 100644
index 0000000..45c474b
--- /dev/null
+++ b/submit.patch
@@ -0,0 +1,1815 @@
+diff --git a/defs.mk b/defs.mk
+new file mode 100644
+index 0000000..f62cde1
+--- /dev/null
++++ b/defs.mk
+@@ -0,0 +1,20 @@
++# This file was generated by configure. Edits will disappear if you rerun
++# configure. If you find that you need to edit this file to make things
++# work, let the course staff know and we'll try to fix the configure script.
++#
++# The purpose of this file is to hold all the makefile definitions
++# needed to adjust the OS/161 build process to any particular
++# environment. If I've done it right, all you need to do is rerun the
++# configure script and make clean if you start working on a different
++# host OS. If I've done it mostly right, you may need to edit this
++# file but you still hopefully won't need to edit any of the
++# makefiles.
++#
++# The things that can be set here are documented in mk/os161.config.mk.
++#
++
++OSTREE=$(HOME)/root-team
++PLATFORM=sys161
++MACHINE=mips
++COMPAT_CFLAGS=
++COMPAT_TARGETS=
+diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
+index 0f773bd..d205710 100644
+--- a/kern/arch/mips/syscall/syscall.c
++++ b/kern/arch/mips/syscall/syscall.c
+@@ -36,6 +36,8 @@
+ #include <current.h>
+ #include <syscall.h>
+ 
++#include <endian.h>
++#include <copyinout.h>
+ 
+ /*
+  * System call dispatcher.
+@@ -80,6 +82,9 @@ syscall(struct trapframe *tf)
+ {
+ 	int callno;
+ 	int32_t retval;
++	uint32_t retval2;
++	uint64_t ar2,ret;
++	int whence;
+ 	int err;
+ 
+ 	KASSERT(curthread != NULL);
+@@ -110,7 +115,52 @@ syscall(struct trapframe *tf)
+ 		break;
+ 
+ 	    /* Add stuff here */
+- 
++	    case SYS_open:
++	    retval = open((userptr_t)tf->tf_a0,
++	    		(int)tf->tf_a1,&err);
++	    break;
++
++   	    case SYS_close:
++   	    err = close(tf->tf_a0);
++        break;
++
++        case SYS_read:
++        retval = read(tf->tf_a0,(userptr_t)tf->tf_a1,tf->tf_a2,&err);
++        break;
++
++        case SYS_write:
++        retval = write(tf->tf_a0,(userptr_t)tf->tf_a1,
++        		tf->tf_a2,&err);
++        break;
++
++        case SYS_dup2:
++        err = dup2(tf->tf_a0,tf->tf_a1);
++        break;
++
++        case SYS_lseek:
++        join32to64(tf->tf_a2,tf->tf_a3,&ar2);
++        //kprintf("Correct lseek called\n");
++           if ((err = copyin((const_userptr_t)(tf->tf_sp+16), &whence, sizeof(whence))) != 0) {
++               break;
++           }
++        ret = lseek((int)tf->tf_a0,ar2,whence,&err);
++        //kprintf("ret value %llu\n",ret);
++        split64to32(ret,(uint32_t *)&retval,(uint32_t *)&retval2);
++        //kprintf("Retval %d,%d\n",retval,retval2);
++        if (!err)
++        {
++        tf->tf_v1 = retval2;
++        }
++        break;
++
++        case SYS_chdir:
++        err = chdir((const_userptr_t)tf->tf_a0);
++        break;
++
++        case SYS___getcwd:
++        err = __getcwd((userptr_t)tf->tf_a0,(size_t)tf->tf_a1);
++        break;
++
+ 	    default:
+ 		kprintf("Unknown syscall %d\n", callno);
+ 		err = ENOSYS;
+diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
+index d527f61..4f9c76f 100644
+--- a/kern/conf/conf.kern
++++ b/kern/conf/conf.kern
+@@ -367,6 +367,7 @@ file      vfs/devnull.c
+ file      syscall/loadelf.c
+ file      syscall/runprogram.c
+ file      syscall/time_syscalls.c
++file	  syscall/file_syscalls.c
+ 
+ #
+ # Startup and initialization
+diff --git a/kern/include/fcntl.h b/kern/include/fcntl.h
+new file mode 100644
+index 0000000..40e3f6c
+--- /dev/null
++++ b/kern/include/fcntl.h
+@@ -0,0 +1,100 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++#ifndef _KERN_FCNTL_H_
++#define _KERN_FCNTL_H_
++
++/*
++ * Constants for libc's <fcntl.h>.
++ */
++
++
++/*
++ * Important
++ */
++
++/* Flags for open: choose one of these: */
++#define O_RDONLY      0      /* Open for read */
++#define O_WRONLY      1      /* Open for write */
++#define O_RDWR        2      /* Open for read and write */
++/* then or in any of these: */
++#define O_CREAT       4      /* Create file if it doesn't exist */
++#define O_EXCL        8      /* With O_CREAT, fail if file already exists */
++#define O_TRUNC      16      /* Truncate file upon open */
++#define O_APPEND     32      /* All writes happen at EOF (optional feature) */
++#define O_NOCTTY     64      /* Required by POSIX, != 0, but does nothing */
++
++/* Additional related definition */
++#define O_ACCMODE     3      /* mask for O_RDONLY/O_WRONLY/O_RDWR */
++
++/*
++ * Not so important
++ */
++
++/* operation codes for flock() */
++#define LOCK_SH         1       /* shared lock */
++#define LOCK_EX         2       /* exclusive lock */
++#define LOCK_UN         3       /* release the lock */
++#define LOCK_NB         4       /* flag: don't block */
++
++/*
++ * Mostly pretty useless
++ */
++
++/* fcntl() operations */
++#define F_DUPFD         0       /* like dup() but not quite */  
++#define F_GETFD         1       /* get per-handle flags */
++#define F_SETFD         2       /* set per-handle flags */
++#define F_GETFL         3       /* get per-file flags (O_* open flags) */
++#define F_SETFL         4       /* set per-file flags (O_* open flags) */
++#define F_GETOWN        5       /* get process/pgroup for SIGURG and SIGIO */
++#define F_SETOWN        6       /* set process/pgroup for SIGURG and SIGIO */
++#define F_GETLK         7       /* inspect record locks */
++#define F_SETLK         8       /* acquire record locks nonblocking */
++#define F_SETLKW        9       /* acquire record locks and wait */
++
++/* flag for F_GETFD and F_SETFD */
++#define FD_CLOEXEC      1       /* close-on-exec */
++
++/* modes for fcntl (F_GETLK/SETLK) locking */
++#define F_RDLCK         0       /* shared lock */
++#define F_WRLCK         1       /* exclusive lock */
++#define F_UNLCK         2       /* unlock */
++
++/* struct for fcntl (F_GETLK/SETLK) locking */
++struct flock {
++	off_t l_start;          /* place in file */
++	int l_whence;           /* SEEK_SET, SEEK_CUR, or SEEK_END */
++	int l_type;             /* F_RDLCK or F_WRLCK */
++	off_t l_len;            /* length of locked region */
++	pid_t l_pid;            /* process that holds the lock */
++};
++
++
++#endif /* _KERN_FCNTL_H_ */
+diff --git a/kern/include/kern/limits.h b/kern/include/kern/limits.h
+index 3fad3f2..b2afe55 100644
+--- a/kern/include/kern/limits.h
++++ b/kern/include/kern/limits.h
+@@ -96,5 +96,7 @@
+ /* Max number of iovec structures at once for readv/writev/preadv/pwritev */
+ #define __IOV_MAX       1024
+ 
++/*Maximum length of file name */
++
+ 
+ #endif /* _KERN_LIMITS_H_ */
+diff --git a/kern/include/seek.h b/kern/include/seek.h
+new file mode 100644
+index 0000000..cf1cfe6
+--- /dev/null
++++ b/kern/include/seek.h
+@@ -0,0 +1,47 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++#ifndef _KERN_SEEK_H_
++#define _KERN_SEEK_H_
++
++/*
++ * Codes for lseek(), which are shared in libc between <fcntl.h> and
++ * <unistd.h> and thus get their own file.
++ *
++ * These are pretty important. Back in the day (like 20+ years ago)
++ * people would often just write the values 0, 1, and 2, but that's
++ * really not recommended.
++ */
++
++#define SEEK_SET      0      /* Seek relative to beginning of file */
++#define SEEK_CUR      1      /* Seek relative to current position in file */
++#define SEEK_END      2      /* Seek relative to end of file */
++
++
++#endif /* _KERN_SEEK_H_ */
+diff --git a/kern/include/synch.h b/kern/include/synch.h
+index ac3714b..35565c6 100644
+--- a/kern/include/synch.h
++++ b/kern/include/synch.h
+@@ -74,6 +74,10 @@ void V(struct semaphore *);
+  */
+ struct lock {
+         char *lk_name;
++        //added by vasanth
++        volatile struct thread *lock_owner;
++        struct wchan *lock_wchan;
++        struct spinlock spn_lock;
+         // add what you need here
+         // (don't forget to mark things volatile as needed)
+ };
+@@ -113,6 +117,7 @@ void lock_destroy(struct lock *);
+ 
+ struct cv {
+         char *cv_name;
++        struct wchan *cv_waitchan;
+         // add what you need here
+         // (don't forget to mark things volatile as needed)
+ };
+@@ -140,9 +145,18 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
+ /*
+  * 13 Feb 2012 : GWA : Reader-writer locks.
+  */
+-
++/* we use two waiting channels one for reader and one for writer we do this so that
++ *if a writer is waiting all the readers will be put on sleep until the writers are
++ *done with their writing
++ */
+ struct rwlock {
+         char *rwlock_name;
++        volatile int num_reader;
++        volatile int num_writer;
++        struct wchan *rlock_wchan;
++        struct wchan *wlock_wchan;
++        struct lock *rw_lock;
++
+ };
+ 
+ struct rwlock * rwlock_create(const char *);
+diff --git a/kern/include/syscall.h b/kern/include/syscall.h
+index befd3d8..6eb477d 100644
+--- a/kern/include/syscall.h
++++ b/kern/include/syscall.h
+@@ -57,5 +57,12 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+ 
+ int sys_reboot(int code);
+ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
+-
++int open(userptr_t filename, int flags,int *err);
++int close(int fd);
++int read(int fd, userptr_t buf, size_t buflen,int *err);
++int write(int fd, userptr_t buf, size_t buflen,int *err);
++int dup2(int oldfd, int newfd);
++off_t lseek(int fd,off_t pos, int whence, int *err);
++int chdir(const_userptr_t pathname);
++int __getcwd(userptr_t buf, size_t buflen);
+ #endif /* _SYSCALL_H_ */
+diff --git a/kern/include/test.h b/kern/include/test.h
+index 240d583..7e24bde 100644
+--- a/kern/include/test.h
++++ b/kern/include/test.h
+@@ -63,6 +63,17 @@ void whalemating_cleanup(void);
+  * Traffic light.
+  */
+ 
++//volatile unsigned long intersectionOccupied = 0;
++
++/**
++* Added by Babu:
++* Locks for each quadrants
++**/
++struct lock *lockquad0;
++struct lock *lockquad1;
++struct lock *lockquad2;
++struct lock *lockquad3;
++
+ void inQuadrant(int);
+ void leaveIntersection(void);
+ int stoplight(int, char **);
+@@ -72,6 +83,7 @@ void turnleft(void *, unsigned long);
+ void turnright(void *, unsigned long);
+ void stoplight_init(void);
+ void stoplight_cleanup(void);
++void inQuadrantSync(unsigned long);
+ 
+ /*
+  * Test code.
+diff --git a/kern/include/thread.h b/kern/include/thread.h
+index 86706ca..65e1f08 100644
+--- a/kern/include/thread.h
++++ b/kern/include/thread.h
+@@ -38,7 +38,7 @@
+ 
+ #include <spinlock.h>
+ #include <threadlist.h>
+-
++#include <limits.h>
+ struct addrspace;
+ struct cpu;
+ struct vnode;
+@@ -57,6 +57,7 @@ struct vnode;
+ #define SAME_STACK(p1, p2)     (((p1) & STACK_MASK) == ((p2) & STACK_MASK))
+ 
+ 
++
+ /* States a thread can be in. */
+ typedef enum {
+ 	S_RUN,		/* running */
+@@ -65,6 +66,15 @@ typedef enum {
+ 	S_ZOMBIE,	/* zombie; exited but not yet deleted */
+ } threadstate_t;
+ 
++struct fTable{
++	    char *name;
++	    int status;
++	    off_t offset;
++	    int ref_count;
++	    struct lock *lock;
++	    struct vnode *vn;
++	};
++
+ /* Thread structure. */
+ struct thread {
+ 	/*
+@@ -101,6 +111,8 @@ struct thread {
+ 	int t_curspl;			/* Current spl*() state */
+ 	int t_iplhigh_count;		/* # of times IPL has been raised */
+ 
++
++
+ 	/*
+ 	 * Public fields
+ 	 */
+@@ -112,8 +124,11 @@ struct thread {
+ 	struct vnode *t_cwd;		/* current working directory */
+ 
+ 	/* add more here as needed */
++	struct fTable *ft[OPEN_MAX];          /*File table pointer*/
++	int priority;
+ };
+ 
++
+ /* Call once during system startup to allocate data structures. */
+ void thread_bootstrap(void);
+ 
+diff --git a/kern/include/unistd.h b/kern/include/unistd.h
+new file mode 100644
+index 0000000..30f2678
+--- /dev/null
++++ b/kern/include/unistd.h
+@@ -0,0 +1,39 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++#ifndef _KERN_UNISTD_H_
++#define _KERN_UNISTD_H_
++
++/* Constants for read/write/etc: special file handles */
++#define STDIN_FILENO  0      /* Standard input */
++#define STDOUT_FILENO 1      /* Standard output */
++#define STDERR_FILENO 2      /* Standard error */
++
++
++#endif /* _KERN_UNISTD_H_ */
+diff --git a/kern/startup/main.c b/kern/startup/main.c
+index be4c4b8..969575b 100644
+--- a/kern/startup/main.c
++++ b/kern/startup/main.c
+@@ -1,3 +1,4 @@
++/*vsubrama@buffalo.edu*/
+ /*
+  * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+  *	The President and Fellows of Harvard College.
+diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
+index 81d2f0e..b1d2a35 100644
+--- a/kern/synchprobs/problems.c
++++ b/kern/synchprobs/problems.c
+@@ -35,6 +35,7 @@
+ #include <thread.h>
+ #include <test.h>
+ #include <synch.h>
++#include <wchan.h>
+ 
+ /*
+  * 08 Feb 2012 : GWA : Driver code is in kern/synchprobs/driver.c. We will
+@@ -46,8 +47,71 @@
+ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+ // functions will allow you to do local initialization. They are called at
+ // the top of the corresponding driver code.
+-
++struct whalemating{
++	volatile int num_male_whale;
++	volatile int num_female_whale;
++	volatile int num_matchmaker_whale;
++	struct wchan *male_wchan;
++	struct wchan *female_wchan;
++	struct wchan *matchmaker_wchan;
++	struct wchan *match_wchan;
++	volatile int match_found;
++	struct lock *lock;
++};
++struct whalemating *whale_mating;
+ void whalemating_init() {
++
++
++	whale_mating = kmalloc(sizeof(struct whalemating));
++	if (whale_mating == NULL)
++	{
++		return;
++	}
++	whale_mating->male_wchan = wchan_create("name");
++	if (whale_mating->male_wchan == NULL)
++	{
++		kfree(whale_mating);
++		return;
++	}
++	whale_mating->female_wchan = wchan_create("name");
++	if (whale_mating->female_wchan == NULL)
++	{
++		wchan_destroy(whale_mating->male_wchan);
++		kfree(whale_mating);
++		return;
++	}
++	whale_mating->matchmaker_wchan = wchan_create("name");
++	if (whale_mating->matchmaker_wchan == NULL)
++	{
++		wchan_destroy(whale_mating->male_wchan);
++		wchan_destroy(whale_mating->female_wchan);
++		kfree(whale_mating);
++		return;
++	}
++	whale_mating->match_wchan = wchan_create("name");
++	if (whale_mating->matchmaker_wchan == NULL)
++		{
++			wchan_destroy(whale_mating->male_wchan);
++			wchan_destroy(whale_mating->female_wchan);
++			wchan_destroy(whale_mating->match_wchan);
++			kfree(whale_mating);
++			return;
++		}
++	whale_mating->lock = lock_create("name");
++	if (whale_mating->lock == NULL)
++	{
++		wchan_destroy(whale_mating->male_wchan);
++		wchan_destroy(whale_mating->female_wchan);
++		wchan_destroy(whale_mating->matchmaker_wchan);
++		wchan_destroy(whale_mating->match_wchan);
++		kfree(whale_mating);
++		return;
++	}
++	whale_mating->num_male_whale = 0;
++	whale_mating->num_female_whale = 0;
++	whale_mating->num_matchmaker_whale = 0;
++	whale_mating->match_found=0;
++
+   return;
+ }
+ 
+@@ -55,6 +119,12 @@ void whalemating_init() {
+ // care if your problems leak memory, but if you do, use this to clean up.
+ 
+ void whalemating_cleanup() {
++	wchan_destroy(whale_mating->male_wchan);
++	wchan_destroy(whale_mating->female_wchan);
++	wchan_destroy(whale_mating->matchmaker_wchan);
++	wchan_destroy(whale_mating->match_wchan);
++	lock_destroy(whale_mating->lock);
++	kfree(whale_mating);
+   return;
+ }
+ 
+@@ -64,9 +134,28 @@ male(void *p, unsigned long which)
+ 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
+   (void)which;
+   
+-  male_start();
+-	// Implement this function 
+-  male_end();
++ male_start();
++	// Implement this function
++ lock_acquire(whale_mating->lock);
++ while(whale_mating->num_male_whale>1)
++ {
++   wchan_lock(whale_mating->male_wchan);
++   lock_release(whale_mating->lock);
++   wchan_sleep(whale_mating->male_wchan);
++   lock_acquire(whale_mating->lock);
++ }
++ whale_mating->num_male_whale++;
++ wchan_wakeall(whale_mating->match_wchan);
++ while(!(whale_mating->match_found==1))
++ {
++	 wchan_lock(whale_mating->match_wchan);
++	 lock_release(whale_mating->lock);
++	 wchan_sleep(whale_mating->match_wchan);
++	 lock_acquire(whale_mating->lock);
++ }
++ lock_release(whale_mating->lock);
++ male_end();
++
+ 
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // whalemating driver can return to the menu cleanly.
+@@ -81,15 +170,36 @@ female(void *p, unsigned long which)
+   (void)which;
+   
+   female_start();
+-	// Implement this function 
++
++	// Implement this function
++  lock_acquire(whale_mating->lock);
++   while(whale_mating->num_female_whale>1)
++   {
++     wchan_lock(whale_mating->female_wchan);
++     lock_release(whale_mating->lock);
++     wchan_sleep(whale_mating->female_wchan);
++     lock_acquire(whale_mating->lock);
++   }
++   whale_mating->num_female_whale++;
++   wchan_wakeall(whale_mating->match_wchan);
++   while(!(whale_mating->match_found==1))
++   {
++  	 wchan_lock(whale_mating->match_wchan);
++  	 lock_release(whale_mating->lock);
++  	 wchan_sleep(whale_mating->match_wchan);
++  	 lock_acquire(whale_mating->lock);
++   }
++   lock_release(whale_mating->lock);
+   female_end();
+-  
++
++
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // whalemating driver can return to the menu cleanly.
+   V(whalematingMenuSemaphore);
+   return;
+ }
+ 
++
+ void
+ matchmaker(void *p, unsigned long which)
+ {
+@@ -97,15 +207,43 @@ matchmaker(void *p, unsigned long which)
+   (void)which;
+   
+   matchmaker_start();
+-	// Implement this function 
++  lock_acquire(whale_mating->lock);
++  while(whale_mating->num_matchmaker_whale>1)
++  {
++     wchan_lock(whale_mating->matchmaker_wchan);
++     lock_release(whale_mating->lock);
++     wchan_sleep(whale_mating->matchmaker_wchan);
++     lock_acquire(whale_mating->lock);
++  }
++  whale_mating->num_matchmaker_whale++;
++  wchan_wakeall(whale_mating->match_wchan);
++  while((whale_mating->num_male_whale == 0) || (whale_mating->num_female_whale == 0))
++  {
++	  wchan_lock(whale_mating->match_wchan);
++	  lock_release(whale_mating->lock);
++	  wchan_sleep(whale_mating->match_wchan);
++	  lock_acquire(whale_mating->lock);
++  }
++  whale_mating->match_found=1;
++  wchan_wakeall(whale_mating->match_wchan);
++  whale_mating->num_male_whale--;
++  whale_mating->num_female_whale--;
++  whale_mating->num_matchmaker_whale--;
++  whale_mating->match_found=0;
++  wchan_wakeall(whale_mating->male_wchan);
++  wchan_wakeall(whale_mating->female_wchan);
++  wchan_wakeall(whale_mating->matchmaker_wchan);
++  lock_release(whale_mating->lock);
++	// Implement this function
+   matchmaker_end();
+-  
++
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // whalemating driver can return to the menu cleanly.
+   V(whalematingMenuSemaphore);
+   return;
+ }
+ 
++
+ /*
+  * You should implement your solution to the stoplight problem below. The
+  * quadrant and direction mappings for reference: (although the problem is,
+@@ -133,27 +271,48 @@ matchmaker(void *p, unsigned long which)
+  * functions in drivers.c.
+  */
+ 
++/**
++ * Added by Babu : 27 Feb 2012
++ * Solving Stop light problem with the help
++ * of locks and predefined semaphores.
++ */
++
++
+ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+ // functions will allow you to do local initialization. They are called at
+ // the top of the corresponding driver code.
+ 
+ void stoplight_init() {
+-  return;
++	lockquad0 = lock_create("quad0lk");
++	lockquad1 = lock_create("quad1lk");
++	lockquad2 = lock_create("quad2lk");
++	lockquad3 = lock_create("quad3lk");
++	return;
+ }
+ 
+ // 20 Feb 2012 : GWA : Adding at the suggestion of Nikhil Londhe. We don't
+ // care if your problems leak memory, but if you do, use this to clean up.
+ 
+ void stoplight_cleanup() {
+-  return;
++	lock_destroy(lockquad0);
++	lock_destroy(lockquad1);
++	lock_destroy(lockquad2);
++	lock_destroy(lockquad3);
++	return;
+ }
+ 
+ void
+ gostraight(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+-  (void)direction;
+-  
++	unsigned long destQuadrant1 = direction;
++	unsigned long destQuadrant2 = (direction + 3) % 4;
++	kprintf("go straight....\n");
++
++	inQuadrantSync(destQuadrant1);
++	inQuadrantSync(destQuadrant2);
++	leaveIntersection();
++
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+@@ -163,8 +322,16 @@ gostraight(void *p, unsigned long direction)
+ void
+ turnleft(void *p, unsigned long direction)
+ {
++	kprintf("turn left....\n");
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+-  (void)direction;
++	unsigned long destQuadrant1 = direction;
++	unsigned long destQuadrant2 = (direction + 3) % 4;
++	unsigned long destQuadrant3 = (direction + 2) % 4;
++
++	inQuadrantSync(destQuadrant1);
++	inQuadrantSync(destQuadrant2);
++	inQuadrantSync(destQuadrant3);
++	leaveIntersection();
+   
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+@@ -175,11 +342,54 @@ turnleft(void *p, unsigned long direction)
+ void
+ turnright(void *p, unsigned long direction)
+ {
++	kprintf("turn right....\n");
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+-  (void)direction;
++	unsigned long destQuadrant1 = direction;
++
++	inQuadrantSync(destQuadrant1);
++	leaveIntersection();
+ 
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+   return;
+ }
++
++/*
++ * Added by Babu
++ * Function which serve as a wrapper to inQuadrant operations
++ * along with synchronization primitive like lock
++ */
++void
++inQuadrantSync(unsigned long destQuadrant)
++{
++	struct lock *lockquad;
++	switch (destQuadrant)
++	{
++		case 0:
++			lockquad = lockquad0;
++			break;
++		case 1:
++			lockquad = lockquad1;
++			break;
++		case 2:
++			lockquad = lockquad2;
++			break;
++		case 3:
++			lockquad = lockquad3;
++			break;
++		default:
++			panic("unknown direction");
++			break;
++	}
++
++	/* If the lock is not held before, then acquire it */
++	if(lock_do_i_hold(lockquad))
++	{
++		lock_acquire(lockquad);
++		inQuadrant(destQuadrant);
++		kprintf("Releasing lock 0\n");
++		lock_release(lockquad);
++	}
++	return;
++}
+diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
+new file mode 100644
+index 0000000..83f4d58
+--- /dev/null
++++ b/kern/syscall/file_syscalls.c
+@@ -0,0 +1,341 @@
++/*
++ * file_syscalls.c
++ *
++ *  Created on: Mar 8, 2014
++ *      Author: trinity
++ */
++#include <types.h>
++#include <copyinout.h>
++#include <lib.h>
++#include <thread.h>
++#include <syscall.h>
++#include <vfs.h>
++#include <vnode.h>
++#include <fcntl.h>
++#include <current.h>
++#include <synch.h>
++
++#include <uio.h>
++#include <kern/iovec.h>
++#include <seek.h>
++#include <stat.h>
++#include <kern/errno.h>
++
++int
++open(userptr_t filename, int flags,int *err)
++{
++	char *iobuff;
++	int rFlag,vfs_ret;
++	size_t aSize;
++	if (filename == NULL)
++	{
++		*err = EFAULT;
++		 return -1;
++	}
++	int tflags = flags & O_ACCMODE;
++	if ( tflags != O_RDONLY && tflags != O_WRONLY && tflags !=O_RDWR )
++	{
++		kprintf("Failing in arguments\n");
++		*err = EINVAL;
++		return -1;
++	}
++	int i;
++	for ( i=0;i<OPEN_MAX;i++)
++	{
++		if (curthread->ft[i] == NULL)
++		{
++			curthread->ft[i] = kmalloc(sizeof(struct fTable));
++			if (curthread->ft[i] == NULL)
++			{
++				*err = ENOMEM;
++				return -1;
++			}
++			curthread->ft[i]->lock = lock_create(curthread->t_name);
++			if (curthread->ft[i]->lock == NULL)
++			{
++				kfree(curthread->ft[i]);
++				curthread->ft[i] = NULL;
++				*err = ENOMEM;
++				return -1;
++			}
++			curthread->ft[i]->offset=0;
++			curthread->ft[i]->ref_count=(curthread->ft[i]->ref_count) + 1;
++			curthread->ft[i]->status = flags;
++			iobuff = (char *)kmalloc(PATH_MAX*sizeof(char));
++			if (iobuff == NULL)
++			{
++				lock_destroy(curthread->ft[i]->lock);
++				kfree(curthread->ft[i]);
++				curthread->ft[i] = NULL;
++				*err = ENOMEM;
++				return -1;
++			}
++			rFlag = copyinstr((const_userptr_t)filename,iobuff,PATH_MAX,&aSize);
++			if(rFlag)
++			{
++				kfree(iobuff);
++				lock_destroy(curthread->ft[i]->lock);
++				kfree(curthread->ft[i]);
++				curthread->ft[i] = NULL;
++				*err = EFAULT;
++				return -1;
++			}
++			vfs_ret=vfs_open((char *)filename,flags,0664,&(curthread->ft[i]->vn));
++			if(vfs_ret)
++			{
++				kfree(iobuff);
++				lock_destroy(curthread->ft[i]->lock);
++				kfree(curthread->ft[i]);
++				curthread->ft[i] = NULL;
++				*err = vfs_ret;
++				return -1;
++			}
++			*err = vfs_ret;
++			return i;
++		}
++	}
++	return 0;
++}
++int close(int fd)
++{
++	if ( fd < 0 || fd > OPEN_MAX)
++	{
++		return EBADF;
++	}
++	if (curthread->ft[fd] == NULL)
++	{
++		return EBADF;
++	}
++	lock_acquire(curthread->ft[fd]->lock);
++	curthread->ft[fd]->ref_count=(curthread->ft[fd]->ref_count)-1;
++	if(curthread->ft[fd]->ref_count == 0)
++	{
++		vfs_close(curthread->ft[fd]->vn);
++		lock_release(curthread->ft[fd]->lock);
++		lock_destroy(curthread->ft[fd]->lock);
++		kfree(curthread->ft[fd]);
++		curthread->ft[fd]=NULL;
++		return 0;
++	}
++	else
++	{
++		lock_release(curthread->ft[fd]->lock);
++		curthread->ft[fd]=NULL;
++		return 0;
++	}
++	return 0;
++}
++
++int
++read(int fd, userptr_t buf, size_t buflen,int *err)
++{
++	int ret;
++	if ( fd < 0 || fd > OPEN_MAX)
++	{
++		*err = EBADF;
++		return -1;
++	}
++	if (curthread->ft[fd] == NULL)
++	{
++		*err = EBADF;
++		return -1;
++	}
++	if (buf == NULL)
++	{
++		*err = EFAULT;
++		return -1;
++	}
++	lock_acquire(curthread->ft[fd]->lock);
++	struct iovec iov;
++	struct uio uio;
++
++	iov.iov_ubase = buf;
++	iov.iov_len = buflen;
++
++	uio.uio_iov = &iov;
++	uio.uio_iovcnt = 1;
++	uio.uio_offset = curthread->ft[fd]->offset;
++	uio.uio_resid = buflen;
++	uio.uio_segflg = UIO_USERSPACE;
++	uio.uio_space = curthread->t_addrspace;
++	uio.uio_rw=UIO_READ;
++	if((ret = VOP_READ(curthread->ft[fd]->vn,&uio))!=0)
++	{
++		*err = ret;
++		return -1;
++	}
++	int diff = uio.uio_offset - curthread->ft[fd]->offset;
++	curthread->ft[fd]->offset=uio.uio_offset;
++	lock_release(curthread->ft[fd]->lock);
++	*err = 0;
++	return diff;
++}
++int
++write(int fd, userptr_t buf, size_t buflen, int *err)
++{
++	int ret;
++	if ( fd < 0 || fd > OPEN_MAX)
++	{
++		*err = EBADF;
++		return -1;
++	}
++	if (curthread->ft[fd] == NULL)
++	{
++		*err = EBADF;
++		return -1;
++	}
++	if (buf == NULL)
++	{
++		*err = EFAULT;
++		return -1;
++	}
++	lock_acquire(curthread->ft[fd]->lock);
++	struct iovec iov;
++	struct uio uio;
++	iov.iov_ubase = buf;
++	iov.iov_len = buflen;
++	uio.uio_iov = &iov;
++	uio.uio_iovcnt = 1;
++	uio.uio_offset = curthread->ft[fd]->offset;
++	uio.uio_resid = buflen;
++	uio.uio_segflg = UIO_USERSPACE;
++	uio.uio_space = curthread->t_addrspace;
++	uio.uio_rw=UIO_WRITE;
++	if((ret = VOP_WRITE(curthread->ft[fd]->vn,&uio))!=0)
++	{
++		*err = ret;
++		return -1;
++	}
++	int diff = uio.uio_offset - curthread->ft[fd]->offset ;
++	curthread->ft[fd]->offset=uio.uio_offset;
++	lock_release(curthread->ft[fd]->lock);
++	*err=0;
++	return diff;
++}
++off_t
++lseek(int fd,off_t pos, int whence,int *err)
++{
++	off_t nPos=0;
++	struct stat eoFILE;
++	//kprintf("lseek entered\n");
++	if (curthread->ft[fd] == NULL)
++	{
++		*err = EBADF;
++		 return -1;
++	}
++	//kprintf("curthread->ft[fd] == NULL\n");
++	if ( fd < 0 || fd > OPEN_MAX)
++	{
++		*err = EBADF;
++		 return -1;
++	}
++	//kprintf("fd < 0 || fd > OPEN_MAX\n");
++	if (whence != SEEK_SET && whence != SEEK_CUR && whence != SEEK_END)
++	{
++		*err = EINVAL;
++		return -1;
++	}
++	//kprintf("whence != SEEK_SET || whence != SEEK_CUR || whence != SEEK_END\n");
++	//kprintf("Acquiring lock\n");
++	lock_acquire(curthread->ft[fd]->lock);
++	//kprintf("Stat gathering\n");
++	VOP_STAT(curthread->ft[fd]->vn,&eoFILE);
++	if (whence == SEEK_SET)
++	{
++		nPos = pos;
++	}
++	if (whence == SEEK_CUR)
++	{
++		nPos = curthread->ft[fd]->offset+pos;
++	}
++	if (whence == SEEK_END)
++	{
++		nPos = eoFILE.st_size+pos;
++	}
++	if (nPos < 0)
++	{
++		*err = EINVAL;
++		lock_release(curthread->ft[fd]->lock);
++		return -1;
++	}
++	//kprintf("NPos %llu\n",nPos);
++	*err = VOP_TRYSEEK(curthread->ft[fd]->vn,nPos);
++	if (*err)
++	{
++		lock_release(curthread->ft[fd]->lock);
++	    return -1;
++	}
++	curthread->ft[fd]->offset = nPos;
++	lock_release(curthread->ft[fd]->lock);
++	//kprintf("New position  %llu\n",nPos);
++	return curthread->ft[fd]->offset;
++}
++int
++dup2(int oldfd, int newfd)
++{
++	int ret;
++		if ( oldfd < 0 || oldfd > OPEN_MAX || newfd < 0 || newfd > OPEN_MAX)
++		{
++			return -1;
++		}
++		if (curthread->ft[oldfd] == NULL || curthread->ft[newfd] == NULL)
++		{
++			return -1;
++		}
++		if (curthread->ft[oldfd] == curthread->ft[newfd] || oldfd == newfd)
++		{
++		    return oldfd;
++		}
++		if (curthread->ft[newfd] != NULL)
++		{
++		   ret = close(newfd);
++		   if (ret)
++		      return -1;
++		}
++		curthread->ft[newfd] = curthread->ft[oldfd];
++		lock_acquire(curthread->ft[newfd]->lock);
++		curthread->ft[newfd]->ref_count++;
++		lock_release(curthread->ft[newfd]->lock);
++		return newfd;
++}
++
++int
++chdir(const_userptr_t pathname)
++{
++	char new_path[PATH_MAX];
++	size_t get;
++
++	if (pathname == NULL)
++	{
++		return -1;
++	}
++
++	int ret = copyinstr(pathname,new_path,PATH_MAX,&get);
++
++	if (ret)
++	{
++		return -1;
++	}
++
++	return vfs_chdir(new_path);
++}
++int
++__getcwd(userptr_t buf, size_t buflen)
++{
++	char path[PATH_MAX];
++	int ret;
++	struct iovec iov;
++	struct uio uio;
++	uio_kinit(&iov,&uio,path,PATH_MAX,0,UIO_READ);
++	ret = vfs_getcwd(&uio);
++	if (ret)
++	{
++		return -1;
++	}
++	ret = copyout((userptr_t)path,buf,buflen);
++	if (ret)
++	{
++		return -1;
++	}
++	return uio.uio_offset;
++}
+diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
+index a6f45c8..d18567f 100644
+--- a/kern/syscall/runprogram.c
++++ b/kern/syscall/runprogram.c
+@@ -44,7 +44,8 @@
+ #include <vfs.h>
+ #include <syscall.h>
+ #include <test.h>
+-
++#include <synch.h>
++#include <unistd.h>
+ /*
+  * Load program "progname" and start running it in usermode.
+  * Does not return except on error.
+@@ -58,6 +59,56 @@ runprogram(char *progname)
+ 	vaddr_t entrypoint, stackptr;
+ 	int result;
+ 
++	struct vnode *o, *i, *e;
++	char *con0 = kstrdup("con:");
++	char *con1 = kstrdup("con:");
++	char *con2 = kstrdup("con:");
++	int inpTemp = vfs_open(con0,O_RDONLY,0664,&i);
++	int outTemp = vfs_open(con1,O_WRONLY,0664,&o);
++	int errTemp = vfs_open(con2,O_WRONLY,0664,&e);
++	KASSERT(inpTemp!=1);
++	KASSERT(outTemp!=1);
++	KASSERT(errTemp!=1);
++
++	struct fTable *input, *output, *error;
++	input= kmalloc(sizeof(struct fTable));
++	output = kmalloc(sizeof(struct fTable));
++	error = kmalloc(sizeof(struct fTable));
++	KASSERT(input!=NULL);
++	KASSERT(output!=NULL);
++	KASSERT(error!=NULL);
++
++	input->name=kstrdup("Standard_Input");
++	input->offset=0;
++	input->ref_count =0;
++	input->status=O_RDONLY;
++	input->vn=i;
++	input->lock=lock_create("Standard Input");
++
++	output->name=kstrdup("Standard_Output");
++	output->offset=0;
++	output->ref_count =0;
++	output->status=O_WRONLY;
++	output->vn=o;
++	output->lock=lock_create("Standard Output");
++
++	error->name=kstrdup("Standard_Error");
++	error->offset=0;
++	error->ref_count =0;
++	error->status=O_WRONLY;
++	error->vn=e;
++	error->lock=lock_create("Standard Error");
++	KASSERT(input->lock!=NULL);
++	KASSERT(output->lock!=NULL);
++	KASSERT(error->lock!=NULL);
++
++	curthread->ft[STDIN_FILENO]=input;
++	curthread->ft[STDOUT_FILENO]=output;
++	curthread->ft[STDERR_FILENO]=error;
++	kfree(con0);
++	kfree(con1);
++	kfree(con2);
++	//kprintf("IO fd's initialized\n");
+ 	/* Open the file. */
+ 	result = vfs_open(progname, O_RDONLY, 0, &v);
+ 	if (result) {
+diff --git a/kern/test/malloctest.c b/kern/test/malloctest.c
+index b4dd87c..a8e4ba8 100644
+--- a/kern/test/malloctest.c
++++ b/kern/test/malloctest.c
+@@ -60,7 +60,6 @@ mallocthread(void *sm, unsigned long num)
+ 	void *oldptr=NULL;
+ 	void *oldptr2=NULL;
+ 	int i;
+-
+ 	for (i=0; i<NTRIES; i++) {
+ 		ptr = kmalloc(ITEMSIZE);
+ 		if (ptr==NULL) {
+diff --git a/kern/test/synchtest.c b/kern/test/synchtest.c
+index d072469..f106f4a 100644
+--- a/kern/test/synchtest.c
++++ b/kern/test/synchtest.c
+@@ -309,21 +309,23 @@ cvtest2thread(void *junk, unsigned long num)
+ {
+ 	int i;
+ 	(void)junk;
+-
+ 	for (i=0; i<NCVLOOPS; i++) {
+ 		lock_acquire(testlock);
+ 		while (testval1 != num) {
+-      testval2 = 0;
++			testval2 = 0;
++
+ 			cv_wait(testcv, testlock);
+-      testval2 = 0xFFFFFFFF;
++			testval2 = 0xFFFFFFFF;
+ 		}
+ 		testval2 = num;
++
+ 		cv_broadcast(testcv, testlock);
+ 		thread_yield();
+ 		kprintf("Thread %lu\n", testval2);
+ 		testval1 = (testval1 + NTHREADS - 1)%NTHREADS;
+ 		lock_release(testlock);
+ 	}
++	kprintf("cv2 test exiting\n");
+ 	V(donesem);
+ }
+ 
+@@ -344,6 +346,7 @@ cvtest2(int nargs, char **args)
+ 	for (i=0; i<NTHREADS; i++) {
+ 		result = thread_fork("synchtest", cvtest2thread, NULL, i,
+ 				      NULL);
++		//kprintf("Thread fork failure\n");
+ 		if (result) {
+ 			panic("cvtest: thread_fork failed: %s\n",
+ 			      strerror(result));
+diff --git a/kern/thread/synch.c b/kern/thread/synch.c
+index 9a7468c..7828129 100644
+--- a/kern/thread/synch.c
++++ b/kern/thread/synch.c
+@@ -47,20 +47,20 @@
+ struct semaphore *
+ sem_create(const char *name, int initial_count)
+ {
+-        struct semaphore *sem;
++	struct semaphore *sem;
+ 
+-        KASSERT(initial_count >= 0);
++	KASSERT(initial_count >= 0);
+ 
+-        sem = kmalloc(sizeof(struct semaphore));
+-        if (sem == NULL) {
+-                return NULL;
+-        }
++	sem = kmalloc(sizeof(struct semaphore));
++	if (sem == NULL) {
++			return NULL;
++	}
+ 
+-        sem->sem_name = kstrdup(name);
+-        if (sem->sem_name == NULL) {
+-                kfree(sem);
+-                return NULL;
+-        }
++	sem->sem_name = kstrdup(name);
++	if (sem->sem_name == NULL) {
++			kfree(sem);
++			return NULL;
++	}
+ 
+ 	sem->sem_wchan = wchan_create(sem->sem_name);
+ 	if (sem->sem_wchan == NULL) {
+@@ -70,9 +70,9 @@ sem_create(const char *name, int initial_count)
+ 	}
+ 
+ 	spinlock_init(&sem->sem_lock);
+-        sem->sem_count = initial_count;
++    sem->sem_count = initial_count;
+ 
+-        return sem;
++    return sem;
+ }
+ 
+ void
+@@ -81,8 +81,8 @@ sem_destroy(struct semaphore *sem)
+         KASSERT(sem != NULL);
+ 
+ 	/* wchan_cleanup will assert if anyone's waiting on it */
+-	spinlock_cleanup(&sem->sem_lock);
+-	wchan_destroy(sem->sem_wchan);
++		spinlock_cleanup(&sem->sem_lock);
++		wchan_destroy(sem->sem_wchan);
+         kfree(sem->sem_name);
+         kfree(sem);
+ }
+@@ -100,7 +100,7 @@ P(struct semaphore *sem)
+          */
+         KASSERT(curthread->t_in_interrupt == false);
+ 
+-	spinlock_acquire(&sem->sem_lock);
++        spinlock_acquire(&sem->sem_lock);
+         while (sem->sem_count == 0) {
+ 		/*
+ 		 * Bridge to the wchan lock, so if someone else comes
+@@ -120,24 +120,22 @@ P(struct semaphore *sem)
+ 		 */
+ 		wchan_lock(sem->sem_wchan);
+ 		spinlock_release(&sem->sem_lock);
+-                wchan_sleep(sem->sem_wchan);
+-
++	        wchan_sleep(sem->sem_wchan);
+ 		spinlock_acquire(&sem->sem_lock);
+-        }
+-        KASSERT(sem->sem_count > 0);
+-        sem->sem_count--;
++	}
++	KASSERT(sem->sem_count > 0);
++	sem->sem_count--;
+ 	spinlock_release(&sem->sem_lock);
+ }
+ 
+ void
+ V(struct semaphore *sem)
+ {
+-        KASSERT(sem != NULL);
++    KASSERT(sem != NULL);
++	spinlock_acquire(&sem->sem_lock); 
+ 
+-	spinlock_acquire(&sem->sem_lock);
+-
+-        sem->sem_count++;
+-        KASSERT(sem->sem_count > 0);
++	sem->sem_count++;
++	KASSERT(sem->sem_count > 0);
+ 	wchan_wakeone(sem->sem_wchan);
+ 
+ 	spinlock_release(&sem->sem_lock);
+@@ -158,20 +156,35 @@ lock_create(const char *name)
+         }
+ 
+         lock->lk_name = kstrdup(name);
++
+         if (lock->lk_name == NULL) {
+                 kfree(lock);
+                 return NULL;
+         }
+-        
++        //added by vasanth
++        lock->lock_owner=NULL;
++        lock->lock_wchan = wchan_create(lock->lk_name);
++		if (lock->lock_wchan == NULL)
++		{
++			kfree(lock->lk_name);
++			kfree(lock);
++			return NULL;
++		}
++		spinlock_init(&lock->spn_lock);
++
+         // add stuff here as needed
+-        
+         return lock;
+ }
+ 
+ void
+ lock_destroy(struct lock *lock)
+ {
++
+         KASSERT(lock != NULL);
++        //added by vasanth
++        //KASSERT(lock->lock_owner == NULL);
++        spinlock_cleanup(&lock->spn_lock);
++        wchan_destroy(lock->lock_wchan);
+ 
+         // add stuff here as needed
+         
+@@ -182,27 +195,61 @@ lock_destroy(struct lock *lock)
+ void
+ lock_acquire(struct lock *lock)
+ {
++		//added by vasanth
++		KASSERT(lock != NULL);
++		spinlock_acquire(&lock->spn_lock);
++		while (lock->lock_owner!=NULL)
++		{
++			wchan_lock(lock->lock_wchan);
++			spinlock_release(&lock->spn_lock);
++			wchan_sleep(lock->lock_wchan);
++			spinlock_acquire(&lock->spn_lock);
++		}
++		lock->lock_owner=curthread;
++		spinlock_release(&lock->spn_lock);
+         // Write this
+ 
+-        (void)lock;  // suppress warning until code gets written
++       // (void)lock;  // suppress warning until code gets written
+ }
+ 
+ void
+ lock_release(struct lock *lock)
+ {
+-        // Write this
+-
+-        (void)lock;  // suppress warning until code gets written
++		//added by vasanth
++ 		KASSERT(lock != NULL);
++		spinlock_acquire(&lock->spn_lock);
++		if(lock->lock_owner==curthread)
++		{
++			lock->lock_owner=NULL;
++			wchan_wakeall(lock->lock_wchan);
++		}
++		spinlock_release(&lock->spn_lock);
++		// Write this
++
++
++        //(void)lock;  // suppress warning until code gets written
+ }
+ 
+ bool
+ lock_do_i_hold(struct lock *lock)
+ {
+         // Write this
+-
+-        (void)lock;  // suppress warning until code gets written
+-
+-        return true; // dummy until code gets written
++	bool status;
++		spinlock_acquire(&lock->spn_lock);
++		if (lock->lock_owner==curthread)
++		{
++			status = true;
++		}
++		else
++		{
++			status = false;
++		}
++		spinlock_release(&lock->spn_lock);
++		return status;
++
++        //(void)lock;  // suppress warning until code gets written
++
++        //return true; // dummy until code gets written
+ }
+ 
+ ////////////////////////////////////////////////////////////
+@@ -217,26 +264,36 @@ cv_create(const char *name)
+ 
+         cv = kmalloc(sizeof(struct cv));
+         if (cv == NULL) {
+-                return NULL;
++        	return NULL;
+         }
+ 
+         cv->cv_name = kstrdup(name);
+         if (cv->cv_name==NULL) {
+-                kfree(cv);
+-                return NULL;
++            kfree(cv);
++            return NULL;
+         }
+         
+         // add stuff here as needed
++        /* Added by Babu :
++        * Adding a wait channel for making the threads wait during cv_acquire
++        */
++        cv->cv_waitchan = wchan_create(cv->cv_name);
++
+         
+         return cv;
+ }
+ 
++
+ void
+ cv_destroy(struct cv *cv)
+ {
+         KASSERT(cv != NULL);
+ 
+         // add stuff here as needed
++        /*
++         * Added by Babu : wchan destructor
++         */
++        wchan_destroy(cv->cv_waitchan);
+         
+         kfree(cv->cv_name);
+         kfree(cv);
+@@ -245,23 +302,180 @@ cv_destroy(struct cv *cv)
+ void
+ cv_wait(struct cv *cv, struct lock *lock)
+ {
+-        // Write this
+-        (void)cv;    // suppress warning until code gets written
+-        (void)lock;  // suppress warning until code gets written
++    // Write this
++	/** Release lock, wait and then acquire once awake */
++	KASSERT(cv != NULL);
++	KASSERT(lock != NULL);
++
++	//kprintf("Waiting in CV\n");
++
++	if(lock_do_i_hold(lock))
++		lock_release(lock);
++
++	//kprintf("Sleeping in CV\n");
++	wchan_lock(cv->cv_waitchan);
++	wchan_sleep(cv->cv_waitchan);
++
++	//kprintf("Came out of CV\n");
++
++	if(!lock_do_i_hold(lock))
++		lock_acquire(lock);
+ }
+ 
+ void
+ cv_signal(struct cv *cv, struct lock *lock)
+ {
+-        // Write this
+-	(void)cv;    // suppress warning until code gets written
+-	(void)lock;  // suppress warning until code gets written
++    // Write this
++	KASSERT(cv != NULL);
++	KASSERT(lock != NULL);
++
++	/*if(!lock_do_i_hold(lock))
++		lock_acquire(lock);*/
++
++	/*if(lock_do_i_hold(lock))
++		lock_release(lock);*/
++
++	//kprintf("Signaling CV\n");
++
++	wchan_wakeone(cv->cv_waitchan);
++	//wchan_unlock(cv->cv_waitchan);
++
++	/*if(!lock_do_i_hold(lock))
++		lock_acquire(lock);*/
++	(void) lock;
+ }
+ 
+ void
+ cv_broadcast(struct cv *cv, struct lock *lock)
+ {
+ 	// Write this
+-	(void)cv;    // suppress warning until code gets written
+-	(void)lock;  // suppress warning until code gets written
++	KASSERT(cv != NULL);
++	KASSERT(lock != NULL);
++
++	/*if(!lock_do_i_hold(lock))
++		lock_acquire(lock);*/
++
++	/*if(lock_do_i_hold(lock))
++		lock_release(lock);*/
++
++	//kprintf("Broadcasting CV\n");
++	wchan_wakeall(cv->cv_waitchan);
++
++
++	/*if(!lock_do_i_hold(lock))
++		lock_acquire(lock);*/
++
++
++	(void) lock;
++}
++
++struct rwlock *
++rwlock_create(const char *name)
++{
++	struct rwlock *rwlock;
++	rwlock = kmalloc(sizeof(struct rwlock));
++	if (rwlock == NULL)
++	{
++		return NULL;
++	}
++	rwlock->rwlock_name=kstrdup(name);
++	if (rwlock->rwlock_name == NULL)
++	{
++	    kfree(rwlock);
++	    return NULL;
++	}
++	rwlock->rlock_wchan = wchan_create(rwlock->rwlock_name);
++	if (rwlock->rlock_wchan == NULL)
++	{
++		kfree(rwlock->rwlock_name);
++		kfree(rwlock);
++		return NULL;
++	}
++	rwlock->wlock_wchan = wchan_create(rwlock->rwlock_name);
++	if (rwlock->wlock_wchan == NULL)
++	{
++		kfree(rwlock->rwlock_name);
++		wchan_destroy(rwlock->rlock_wchan);
++		kfree(rwlock);
++		return NULL;
++	}
++	rwlock->num_reader=0;
++	rwlock->num_writer=0;
++	rwlock->rw_lock = lock_create(rwlock->rwlock_name);
++	if (rwlock->rw_lock == NULL)
++	{
++		kfree(rwlock->rwlock_name);
++		wchan_destroy(rwlock->rlock_wchan);
++		wchan_destroy(rwlock->wlock_wchan);
++		kfree(rwlock);
++		return NULL;
++	}
++	return rwlock;
++
++}
++void
++rwlock_destroy(struct rwlock *rwlock)
++{
++	KASSERT(rwlock != NULL);
++	lock_destroy(rwlock->rw_lock);
++	wchan_destroy(rwlock->rlock_wchan);
++	wchan_destroy(rwlock->wlock_wchan);
++	kfree(rwlock->rwlock_name);
++	kfree(rwlock);
++}
++
++void
++rwlock_acquire_read(struct rwlock *rwlock)
++{
++	KASSERT(rwlock != NULL);
++	lock_acquire(rwlock->rw_lock);
++	while (rwlock->num_writer>0)
++	{
++		wchan_lock(rwlock->rlock_wchan);
++		lock_release(rwlock->rw_lock);
++		wchan_sleep(rwlock->rlock_wchan);
++		lock_acquire(rwlock->rw_lock);
++	}
++	rwlock->num_reader++;
++	lock_release(rwlock->rw_lock);
++}
++void
++rwlock_release_read(struct rwlock *rwlock)
++{
++	KASSERT(rwlock != NULL);
++	KASSERT(rwlock->num_reader > 0);
++	lock_acquire(rwlock->rw_lock);
++	if(rwlock->num_reader > 0)
++	{
++		rwlock->num_reader--;
++	}
++	wchan_wakeall(rwlock->wlock_wchan);
++	wchan_wakeall(rwlock->rlock_wchan);
++	lock_release(rwlock->rw_lock);
++}
++void
++rwlock_acquire_write(struct rwlock *rwlock)
++{
++	KASSERT(rwlock != NULL);
++	lock_acquire(rwlock->rw_lock);
++	while ((rwlock->num_reader>0) || (rwlock->num_writer > 0))
++	{
++		wchan_lock(rwlock->wlock_wchan);
++		lock_release(rwlock->rw_lock);
++		wchan_sleep(rwlock->wlock_wchan);
++		lock_acquire(rwlock->rw_lock);
++	}
++	rwlock->num_writer++;
++	lock_release(rwlock->rw_lock);
++}
++void
++rwlock_release_write(struct rwlock *rwlock)
++{
++	KASSERT(rwlock != NULL);
++	KASSERT(rwlock->num_writer > 0);
++	lock_acquire(rwlock->rw_lock);
++	rwlock->num_writer--;
++	wchan_wakeall(rwlock->rlock_wchan);
++	wchan_wakeall(rwlock->wlock_wchan);
++	lock_release(rwlock->rw_lock);
+ }
+diff --git a/kern/thread/thread.c b/kern/thread/thread.c
+index e7235e3..b1dcc73 100644
+--- a/kern/thread/thread.c
++++ b/kern/thread/thread.c
+@@ -47,6 +47,7 @@
+ #include <addrspace.h>
+ #include <mainbus.h>
+ #include <vnode.h>
++#include <limits.h>
+ 
+ #include "opt-synchprobs.h"
+ #include "opt-defaultscheduler.h"
+@@ -153,6 +154,19 @@ thread_create(const char *name)
+ 	thread->t_cwd = NULL;
+ 
+ 	/* If you add to struct thread, be sure to initialize here */
++	/*File descriptor*/
++		int i;
++		for (i=0;i<OPEN_MAX;i++)
++		{
++			thread->ft[i] = kmalloc(sizeof(struct file_table *));
++			if (thread->ft[i] == NULL)
++					{
++						kfree(thread);
++						return NULL;
++					}
++			thread->ft[i]=0;
++		}
++		thread->priority = 5;
+ 
+ 	return thread;
+ }
+@@ -263,6 +277,7 @@ thread_destroy(struct thread *thread)
+ 	thread->t_wchan_name = "DESTROYED";
+ 
+ 	kfree(thread->t_name);
++	//if(thread->ft!=NULL)kfree(thread->ft);
+ 	kfree(thread);
+ }
+ 
+@@ -483,7 +498,6 @@ thread_fork(const char *name,
+ 	    struct thread **ret)
+ {
+ 	struct thread *newthread;
+-
+ 	newthread = thread_create(name);
+ 	if (newthread == NULL) {
+ 		return ENOMEM;
+@@ -520,6 +534,8 @@ thread_fork(const char *name,
+ 	 */
+ 	newthread->t_iplhigh_count++;
+ 
++	//Might have to add the copy of the file table --vasanth
++
+ 	/* Set up the switchframe so entrypoint() gets called */
+ 	switchframe_init(newthread, entrypoint, data1, data2);
+ 
+@@ -574,6 +590,11 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
+ 
+ 	/* Check the stack guard band. */
+ 	thread_checkstack(cur);
++	if ( cur->priority > 0 && cur->priority< 10)
++	{
++		if (newstate == S_SLEEP)cur->priority--;     //increment priority if thread was sleeping
++		if (newstate == S_READY)cur->priority++;     //decrement priority if thread was ready
++	}
+ 
+ 	/* Lock the run queue. */
+ 	spinlock_acquire(&curcpu->c_runqueue_lock);
+@@ -585,6 +606,7 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
+ 		return;
+ 	}
+ 
++
+ 	/* Put the thread in the right place. */
+ 	switch (newstate) {
+ 	    case S_
\ No newline at end of file
diff --git a/user/testbin/fileonlytest/fileonlytest.c b/user/testbin/fileonlytest/fileonlytest.c
index b807ff6..7776818 100644
--- a/user/testbin/fileonlytest/fileonlytest.c
+++ b/user/testbin/fileonlytest/fileonlytest.c
@@ -83,6 +83,7 @@ main(int argc, char **argv)
 			writebuf[j] = i * 2 * j;
 		}
 		len = write(fh, writebuf, sizeof(writebuf));
+		printf("Written %d bytes.\n",len);
 		if (len != sizeof(writebuf)) {
 			err(1, "write failed");
 		}
