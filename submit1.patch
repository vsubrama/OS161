diff --git a/common/libc/string/strcpy.c b/common/libc/string/strcpy.c
index 88627ed..9a51b24 100644
--- a/common/libc/string/strcpy.c
+++ b/common/libc/string/strcpy.c
@@ -47,17 +47,18 @@ strcpy(char *dest, const char *src)
 {
 	size_t i;
 
+
 	/*
 	 * Copy characters until we hit the null terminator.
 	 */
 	for (i=0; src[i]; i++) {
 		dest[i] = src[i];
 	}
-
 	/*
 	 * Add null terminator to result.
 	 */
 	dest[i] = 0;
+	//kprintf("Destination string %s\n",dest);
 
 	return dest;
 }
diff --git a/defs.mk b/defs.mk
new file mode 100644
index 0000000..9345229
--- /dev/null
+++ b/defs.mk
@@ -0,0 +1,20 @@
+# This file was generated by configure. Edits will disappear if you rerun
+# configure. If you find that you need to edit this file to make things
+# work, let the course staff know and we'll try to fix the configure script.
+#
+# The purpose of this file is to hold all the makefile definitions
+# needed to adjust the OS/161 build process to any particular
+# environment. If I've done it right, all you need to do is rerun the
+# configure script and make clean if you start working on a different
+# host OS. If I've done it mostly right, you may need to edit this
+# file but you still hopefully won't need to edit any of the
+# makefiles.
+#
+# The things that can be set here are documented in mk/os161.config.mk.
+#
+
+OSTREE=$(HOME)/root
+PLATFORM=sys161
+MACHINE=mips
+COMPAT_CFLAGS=
+COMPAT_TARGETS=
diff --git a/kern/arch/mips/locore/trap.c b/kern/arch/mips/locore/trap.c
index ff39633..0b3f63e 100644
--- a/kern/arch/mips/locore/trap.c
+++ b/kern/arch/mips/locore/trap.c
@@ -394,7 +394,9 @@ mips_usermode(struct trapframe *tf)
 	 * either another thread's stack or in the kernel heap.
 	 * (Exercise: why?)
 	 */
+	//kprintf("before SAME STACK");
 	KASSERT(SAME_STACK(cpustacks[curcpu->c_number]-1, (vaddr_t)tf));
+	//kprintf("after SAME STACK");
 
 	/*
 	 * This actually does it. See exception.S.
diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
index 0f773bd..858018a 100644
--- a/kern/arch/mips/syscall/syscall.c
+++ b/kern/arch/mips/syscall/syscall.c
@@ -36,6 +36,8 @@
 #include <current.h>
 #include <syscall.h>
 
+#include <endian.h>
+#include <copyinout.h>
 
 /*
  * System call dispatcher.
@@ -80,6 +82,9 @@ syscall(struct trapframe *tf)
 {
 	int callno;
 	int32_t retval;
+	uint32_t retval2;
+	uint64_t ar2,ret;
+	int whence;
 	int err;
 
 	KASSERT(curthread != NULL);
@@ -98,7 +103,7 @@ syscall(struct trapframe *tf)
 	 */
 
 	retval = 0;
-
+	//kprintf("syscall number : %d\n",callno);
 	switch (callno) {
 	    case SYS_reboot:
 		err = sys_reboot(tf->tf_a0);
@@ -109,15 +114,90 @@ syscall(struct trapframe *tf)
 				 (userptr_t)tf->tf_a1);
 		break;
 
+		/**
+		 * Added by Babu : case statements for process related syscalls
+		 */
+	    case SYS_fork:
+	        err = sys_fork(&retval, tf);
+	        //kprintf("ret val : %d and err no : %d\n",retval, err);
+	    	break;
+
+	    case SYS_execv:
+	    	//err = sys_execv((char *)tf->tf_a0, (char *)tf->tf_a1);
+	    	break;
+
+	    case SYS__exit:
+	    	sys__exit((int)tf->tf_a0);
+	    	err = 0;
+	    	break;
+
+	    case SYS_waitpid:
+	    	err = sys_waitpid(&retval, (pid_t)tf->tf_a0, (int32_t *)tf->tf_a1, (int32_t)tf->tf_a2);
+	    	break;
+
+	    case SYS_getpid:
+	    	err = sys_getpid(&retval);
+	    	break;
+
+	    case SYS_getppid:
+	    	err = sys_getppid(&retval);
+	    	break;
+
+
 	    /* Add stuff here */
- 
+	    // File system calls - Vasanth
+	    case SYS_open:
+	    	retval = open((userptr_t)tf->tf_a0,
+	    	(int)tf->tf_a1,&err);
+	    break;
+
+   	    case SYS_close:
+			err = close(tf->tf_a0);
+			break;
+
+        case SYS_read:
+        	retval = read(tf->tf_a0,(userptr_t)tf->tf_a1,tf->tf_a2,&err);
+        	break;
+
+        case SYS_write:
+        	retval = write(tf->tf_a0,(userptr_t)tf->tf_a1, tf->tf_a2,&err);
+        	break;
+
+        case SYS_dup2:
+        	err = dup2(tf->tf_a0,tf->tf_a1);
+        	break;
+
+        case SYS_lseek:
+			join32to64(tf->tf_a2,tf->tf_a3,&ar2);
+			//kprintf("Correct lseek called\n");
+			if ((err = copyin((const_userptr_t)(tf->tf_sp+16), &whence, sizeof(whence))) != 0)
+			{
+				   break;
+			}
+			ret = lseek((int)tf->tf_a0,ar2,whence,&err);
+			//kprintf("ret value %llu\n",ret);
+			split64to32(ret,(uint32_t *)&retval,(uint32_t *)&retval2);
+			//kprintf("Retval %d,%d\n",retval,retval2);
+			if (!err)
+			{
+				tf->tf_v1 = retval2;
+			}
+			break;
+
+        case SYS_chdir:
+        	err = chdir((const_userptr_t)tf->tf_a0);
+        	break;
+
+        case SYS___getcwd:
+			err = __getcwd((userptr_t)tf->tf_a0,(size_t)tf->tf_a1);
+			break;
+
 	    default:
 		kprintf("Unknown syscall %d\n", callno);
 		err = ENOSYS;
 		break;
 	}
 
-
 	if (err) {
 		/*
 		 * Return the error code. This gets converted at
@@ -137,7 +217,7 @@ syscall(struct trapframe *tf)
 	 * Now, advance the program counter, to avoid restarting
 	 * the syscall over and over again.
 	 */
-	
+
 	tf->tf_epc += 4;
 
 	/* Make sure the syscall code didn't forget to lower spl */
diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
index d527f61..7b94cac 100644
--- a/kern/conf/conf.kern
+++ b/kern/conf/conf.kern
@@ -367,6 +367,8 @@ file      vfs/devnull.c
 file      syscall/loadelf.c
 file      syscall/runprogram.c
 file      syscall/time_syscalls.c
+file	  syscall/file_syscalls.c
+file	  syscall/process.c
 
 #
 # Startup and initialization
diff --git a/kern/include/fcntl.h b/kern/include/fcntl.h
new file mode 100644
index 0000000..40e3f6c
--- /dev/null
+++ b/kern/include/fcntl.h
@@ -0,0 +1,100 @@
+/*
+ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008
+ *	The President and Fellows of Harvard College.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _KERN_FCNTL_H_
+#define _KERN_FCNTL_H_
+
+/*
+ * Constants for libc's <fcntl.h>.
+ */
+
+
+/*
+ * Important
+ */
+
+/* Flags for open: choose one of these: */
+#define O_RDONLY      0      /* Open for read */
+#define O_WRONLY      1      /* Open for write */
+#define O_RDWR        2      /* Open for read and write */
+/* then or in any of these: */
+#define O_CREAT       4      /* Create file if it doesn't exist */
+#define O_EXCL        8      /* With O_CREAT, fail if file already exists */
+#define O_TRUNC      16      /* Truncate file upon open */
+#define O_APPEND     32      /* All writes happen at EOF (optional feature) */
+#define O_NOCTTY     64      /* Required by POSIX, != 0, but does nothing */
+
+/* Additional related definition */
+#define O_ACCMODE     3      /* mask for O_RDONLY/O_WRONLY/O_RDWR */
+
+/*
+ * Not so important
+ */
+
+/* operation codes for flock() */
+#define LOCK_SH         1       /* shared lock */
+#define LOCK_EX         2       /* exclusive lock */
+#define LOCK_UN         3       /* release the lock */
+#define LOCK_NB         4       /* flag: don't block */
+
+/*
+ * Mostly pretty useless
+ */
+
+/* fcntl() operations */
+#define F_DUPFD         0       /* like dup() but not quite */  
+#define F_GETFD         1       /* get per-handle flags */
+#define F_SETFD         2       /* set per-handle flags */
+#define F_GETFL         3       /* get per-file flags (O_* open flags) */
+#define F_SETFL         4       /* set per-file flags (O_* open flags) */
+#define F_GETOWN        5       /* get process/pgroup for SIGURG and SIGIO */
+#define F_SETOWN        6       /* set process/pgroup for SIGURG and SIGIO */
+#define F_GETLK         7       /* inspect record locks */
+#define F_SETLK         8       /* acquire record locks nonblocking */
+#define F_SETLKW        9       /* acquire record locks and wait */
+
+/* flag for F_GETFD and F_SETFD */
+#define FD_CLOEXEC      1       /* close-on-exec */
+
+/* modes for fcntl (F_GETLK/SETLK) locking */
+#define F_RDLCK         0       /* shared lock */
+#define F_WRLCK         1       /* exclusive lock */
+#define F_UNLCK         2       /* unlock */
+
+/* struct for fcntl (F_GETLK/SETLK) locking */
+struct flock {
+	off_t l_start;          /* place in file */
+	int l_whence;           /* SEEK_SET, SEEK_CUR, or SEEK_END */
+	int l_type;             /* F_RDLCK or F_WRLCK */
+	off_t l_len;            /* length of locked region */
+	pid_t l_pid;            /* process that holds the lock */
+};
+
+
+#endif /* _KERN_FCNTL_H_ */
diff --git a/kern/include/kern/limits.h b/kern/include/kern/limits.h
index 3fad3f2..a1941ec 100644
--- a/kern/include/kern/limits.h
+++ b/kern/include/kern/limits.h
@@ -96,5 +96,11 @@
 /* Max number of iovec structures at once for readv/writev/preadv/pwritev */
 #define __IOV_MAX       1024
 
+/* Max number of process which can run on os161*/
+#define _MAX_RUNNING_PROCS 400
+
+
+/*Maximum number of file table entry per process */
+#define _MAX_FILE 10
 
 #endif /* _KERN_LIMITS_H_ */
diff --git a/kern/include/limits.h b/kern/include/limits.h
index 01684c4..81ec912 100644
--- a/kern/include/limits.h
+++ b/kern/include/limits.h
@@ -48,5 +48,7 @@
 #define LOGIN_NAME_MAX  __LOGIN_NAME_MAX
 #define OPEN_MAX        __OPEN_MAX
 #define IOV_MAX         __IOV_MAX
+#define MAX_RUNNING_PROCS _MAX_RUNNING_PROCS
+#define MAX_FILE _MAX_FILE
 
 #endif /* _LIMITS_H_ */
diff --git a/kern/include/process.h b/kern/include/process.h
new file mode 100644
index 0000000..dbc23ba
--- /dev/null
+++ b/kern/include/process.h
@@ -0,0 +1,97 @@
+/*
+ * process.h
+ *
+ *  	Created on: Mar 8, 2014
+ *      Author: Babu
+ */
+
+#ifndef PROCESS_H_
+#define PROCESS_H_
+
+struct trapframe;
+
+/*
+ * Process table which holds all information about the process
+ * such as pid, parent process, threads belongs to that process
+ *
+ */
+struct process {
+
+	pid_t p_pid_self;  /* process id of the process */
+
+	struct thread *p_thread;
+
+	pid_t p_pid_parent;
+
+	// Variables for process exit
+	bool p_exited;
+
+	int p_exitcode;
+
+	struct semaphore *p_exitsem;
+};
+
+
+/**TODO Process Table change it to 256 to MAX_RUNNING_PROCESS**/
+
+struct process *processtable[256];
+
+struct lock *pid_sem;
+
+/**
+ * When a process exits it should invoke this method so that
+ * this will add the allocated pid to free pool which can be assigned
+ * for other process  - Added by Babu
+ */
+void add_pid_to_pool(pid_t);
+
+
+/**
+ * Allocate pid based on the pids available in the pool or
+ * generate from the counter if the pool is empty  - Added by Babu
+ */
+pid_t allocate_pid(void);
+
+/**
+ * function to destroy process and it related book keeping stuffs
+ */
+void process_destroy(struct process *process);
+
+
+/**
+ * getpid system call which fetches the pid of the calling process
+ */
+pid_t sys_getpid(int32_t *retval);
+
+/**
+ * getppid system call which fetches the pid of the calling process parent
+ */
+pid_t sys_getppid(int32_t *retval);
+
+/**
+ * exit system call which allows the calling process to exit
+ */
+void sys__exit(int exitcode);
+
+/**
+ * wait system call allows the calling process' parent to collect the status of child process
+ */
+int sys_waitpid(int32_t *retval, pid_t pid, int32_t *exitcode, int32_t flags);
+
+/**
+ * fork system call which creates clone of the calling process
+ */
+int sys_fork(int32_t *retval, struct trapframe *tf);
+
+/**
+ * execv system call allows create process from the file and loads into address space and executes
+ */
+int sys_execv(char *prgname, char *argv[]);
+
+/**
+ * Entry point function for the child process/thread created by fork()
+ */
+void child_entrypoint(void *data1, unsigned long data2);
+
+
+#endif /* PROCESS_H_ */
diff --git a/kern/include/seek.h b/kern/include/seek.h
new file mode 100644
index 0000000..cf1cfe6
--- /dev/null
+++ b/kern/include/seek.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008
+ *	The President and Fellows of Harvard College.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _KERN_SEEK_H_
+#define _KERN_SEEK_H_
+
+/*
+ * Codes for lseek(), which are shared in libc between <fcntl.h> and
+ * <unistd.h> and thus get their own file.
+ *
+ * These are pretty important. Back in the day (like 20+ years ago)
+ * people would often just write the values 0, 1, and 2, but that's
+ * really not recommended.
+ */
+
+#define SEEK_SET      0      /* Seek relative to beginning of file */
+#define SEEK_CUR      1      /* Seek relative to current position in file */
+#define SEEK_END      2      /* Seek relative to end of file */
+
+
+#endif /* _KERN_SEEK_H_ */
diff --git a/kern/include/synch.h b/kern/include/synch.h
index ac3714b..35565c6 100644
--- a/kern/include/synch.h
+++ b/kern/include/synch.h
@@ -74,6 +74,10 @@ void V(struct semaphore *);
  */
 struct lock {
         char *lk_name;
+        //added by vasanth
+        volatile struct thread *lock_owner;
+        struct wchan *lock_wchan;
+        struct spinlock spn_lock;
         // add what you need here
         // (don't forget to mark things volatile as needed)
 };
@@ -113,6 +117,7 @@ void lock_destroy(struct lock *);
 
 struct cv {
         char *cv_name;
+        struct wchan *cv_waitchan;
         // add what you need here
         // (don't forget to mark things volatile as needed)
 };
@@ -140,9 +145,18 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
 /*
  * 13 Feb 2012 : GWA : Reader-writer locks.
  */
-
+/* we use two waiting channels one for reader and one for writer we do this so that
+ *if a writer is waiting all the readers will be put on sleep until the writers are
+ *done with their writing
+ */
 struct rwlock {
         char *rwlock_name;
+        volatile int num_reader;
+        volatile int num_writer;
+        struct wchan *rlock_wchan;
+        struct wchan *wlock_wchan;
+        struct lock *rw_lock;
+
 };
 
 struct rwlock * rwlock_create(const char *);
diff --git a/kern/include/syscall.h b/kern/include/syscall.h
index befd3d8..c86d805 100644
--- a/kern/include/syscall.h
+++ b/kern/include/syscall.h
@@ -27,6 +27,9 @@
  * SUCH DAMAGE.
  */
 
+#include <process.h>
+
+
 #ifndef _SYSCALL_H_
 #define _SYSCALL_H_
 
@@ -57,5 +60,12 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
 
 int sys_reboot(int code);
 int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
-
+int open(userptr_t filename, int flags,int *err);
+int close(int fd);
+int read(int fd, userptr_t buf, size_t buflen,int *err);
+int write(int fd, userptr_t buf, size_t buflen,int *err);
+int dup2(int oldfd, int newfd);
+off_t lseek(int fd,off_t pos, int whence, int *err);
+int chdir(const_userptr_t pathname);
+int __getcwd(userptr_t buf, size_t buflen);
 #endif /* _SYSCALL_H_ */
diff --git a/kern/include/test.h b/kern/include/test.h
index 240d583..067311f 100644
--- a/kern/include/test.h
+++ b/kern/include/test.h
@@ -63,16 +63,25 @@ void whalemating_cleanup(void);
  * Traffic light.
  */
 
-void inQuadrant(int);
+//volatile unsigned long intersectionOccupied = 0;
+
+/**
+* Added by Babu:
+* Locks for each quadrants
+**/
+
+
+
 void leaveIntersection(void);
 int stoplight(int, char **);
-
+void inQuadrant(int);
 void gostraight(void *, unsigned long);
 void turnleft(void *, unsigned long);
 void turnright(void *, unsigned long);
 void stoplight_init(void);
 void stoplight_cleanup(void);
 
+
 /*
  * Test code.
  */
diff --git a/kern/include/thread.h b/kern/include/thread.h
index 86706ca..31a1868 100644
--- a/kern/include/thread.h
+++ b/kern/include/thread.h
@@ -38,7 +38,7 @@
 
 #include <spinlock.h>
 #include <threadlist.h>
-
+#include <limits.h>
 struct addrspace;
 struct cpu;
 struct vnode;
@@ -57,6 +57,7 @@ struct vnode;
 #define SAME_STACK(p1, p2)     (((p1) & STACK_MASK) == ((p2) & STACK_MASK))
 
 
+
 /* States a thread can be in. */
 typedef enum {
 	S_RUN,		/* running */
@@ -65,6 +66,15 @@ typedef enum {
 	S_ZOMBIE,	/* zombie; exited but not yet deleted */
 } threadstate_t;
 
+struct fTable{
+	    char *name;
+	    int status;
+	    off_t offset;
+	    int ref_count;
+	    struct lock *lock;
+	    struct vnode *vn;
+	};
+
 /* Thread structure. */
 struct thread {
 	/*
@@ -101,9 +111,16 @@ struct thread {
 	int t_curspl;			/* Current spl*() state */
 	int t_iplhigh_count;		/* # of times IPL has been raised */
 
+
+
 	/*
 	 * Public fields
 	 */
+	/**
+	 * Added by Babu :
+	 * pointer to parent process data structure
+	 */
+	struct process *t_process;
 
 	/* VM */
 	struct addrspace *t_addrspace;	/* virtual address space */
@@ -112,8 +129,11 @@ struct thread {
 	struct vnode *t_cwd;		/* current working directory */
 
 	/* add more here as needed */
+	struct fTable *ft[OPEN_MAX];          /*File table pointer*/
+	int priority;
 };
 
+
 /* Call once during system startup to allocate data structures. */
 void thread_bootstrap(void);
 
diff --git a/kern/include/unistd.h b/kern/include/unistd.h
new file mode 100644
index 0000000..30f2678
--- /dev/null
+++ b/kern/include/unistd.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008
+ *	The President and Fellows of Harvard College.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _KERN_UNISTD_H_
+#define _KERN_UNISTD_H_
+
+/* Constants for read/write/etc: special file handles */
+#define STDIN_FILENO  0      /* Standard input */
+#define STDOUT_FILENO 1      /* Standard output */
+#define STDERR_FILENO 2      /* Standard error */
+
+
+#endif /* _KERN_UNISTD_H_ */
diff --git a/kern/startup/main.c b/kern/startup/main.c
index be4c4b8..1ba112a 100644
--- a/kern/startup/main.c
+++ b/kern/startup/main.c
@@ -1,3 +1,4 @@
+/*vsubrama@buffalo.edu*/
 /*
  * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
  *	The President and Fellows of Harvard College.
@@ -100,7 +101,7 @@ boot(void)
 	kprintf("%s", harvard_copyright);
 	kprintf("\n");
 
-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
+	kprintf("babupras@buffalo.edu vsubrama@buffalo.edu 's system version %s (%s #%d)\n", 
 		GROUP_VERSION, buildconfig, buildversion);
 	kprintf("\n");
 
diff --git a/kern/startup/menu.c b/kern/startup/menu.c
index 6c71551..32889e8 100644
--- a/kern/startup/menu.c
+++ b/kern/startup/menu.c
@@ -96,11 +96,12 @@ cmd_progthread(void *ptr, unsigned long nargs)
 	}
 
 	/* Hope we fit. */
+	//kprintf("Passed function name %s\n",args[0]);
 	KASSERT(strlen(args[0]) < sizeof(progname));
+	strcpy(progname,args[0]);
 
-	strcpy(progname, args[0]);
-
-	result = runprogram(progname);
+	//kprintf("progname : %s\n", progname);
+	result = runprogram(args[0]);
 	if (result) {
 		kprintf("Running program %s failed: %s\n", args[0],
 			strerror(result));
@@ -133,10 +134,32 @@ common_prog(int nargs, char **args)
 		"synchronization-problems kernel.\n");
 #endif
 
+	struct thread *newthread = NULL;
+	pid_t retpid ;
+	//struct thread *parentthread = curthread;
+	int status = 0 , err = 0;
+	//kprintf("before thread fork args  : %s, %s\n", args[0], args[1]);
 	result = thread_fork(args[0] /* thread name */,
 			cmd_progthread /* thread function */,
 			args /* thread arg */, nargs /* thread arg */,
-			NULL);
+			&newthread);
+
+	if(newthread != NULL)
+	{
+		// Parent wait
+
+		//err = waitpid(newthread->t_process->p_pid_self, &status, 1);
+		err = sys_waitpid(&retpid, newthread->t_process->p_pid_self, &status, 2);
+		if(err != 0)
+		{
+			kprintf("wait not success : %d\n", err);
+		}
+	}
+	// child wait
+	//something like this is expected please do --vasanth
+	//int s_wait;
+
+	//sys_waitpid(NULL, fork_Thread->t_process->p_pid_self,&s_wait,0);
 	if (result) {
 		kprintf("thread_fork failed: %s\n", strerror(result));
 		return result;
@@ -157,6 +180,8 @@ cmd_prog(int nargs, char **args)
 		return EINVAL;
 	}
 
+	kprintf("cmd_prg args  : %s, %s\n", args[0], args[1]);
+
 	/* drop the leading "p" */
 	args++;
 	nargs--;
@@ -579,6 +604,8 @@ cmd_dispatch(char *cmd)
 	char *context;
 	int i, result;
 
+	kprintf("cmd : %s\n",cmd);
+
 	for (word = strtok_r(cmd, " \t", &context);
 	     word != NULL;
 	     word = strtok_r(NULL, " \t", &context)) {
@@ -587,7 +614,9 @@ cmd_dispatch(char *cmd)
 			kprintf("Command line has too many words\n");
 			return E2BIG;
 		}
+		kprintf("original wrd :%s\n",word);
 		args[nargs++] = word;
+		kprintf("args :%s\n",args[nargs-1]);
 	}
 
 	if (nargs==0) {
diff --git a/kern/synchprobs/drivers.c b/kern/synchprobs/drivers.c
index 02e336f..05d3d21 100644
--- a/kern/synchprobs/drivers.c
+++ b/kern/synchprobs/drivers.c
@@ -148,7 +148,7 @@ inline void leaveIntersection() {
 	kprintf("%s left the intersection\n", curthread->t_name);
 }
 
-#define NCARS 99
+#define NCARS 10
 
 struct semaphore * stoplightMenuSemaphore;
 
@@ -158,12 +158,13 @@ int stoplight(int nargs, char **args) {
 	int i, direction, turn, err = 0;
 	char name[32];
 
+	kprintf("Stop light called\n");
+	stoplight_init();
 	stoplightMenuSemaphore = sem_create("Stoplight Driver Semaphore", 0);
 	if (stoplightMenuSemaphore == NULL ) {
 		panic("stoplight: sem_create failed.\n");
 	}
 
-	stoplight_init();
 
 	for (i = 0; i < NCARS; i++) {
 
diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
index 81d2f0e..820f67e 100644
--- a/kern/synchprobs/problems.c
+++ b/kern/synchprobs/problems.c
@@ -35,6 +35,7 @@
 #include <thread.h>
 #include <test.h>
 #include <synch.h>
+#include <wchan.h>
 
 /*
  * 08 Feb 2012 : GWA : Driver code is in kern/synchprobs/driver.c. We will
@@ -46,8 +47,84 @@
 // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
 // functions will allow you to do local initialization. They are called at
 // the top of the corresponding driver code.
+struct lock *lockquad0;
+struct lock *lockquad1;
+struct lock *lockquad2;
+struct lock *lockquad3;
+void inQuadrantSync(unsigned long);
+struct lock *getlock(int destQuadrant);
 
+struct whalemating
+{
+	volatile int num_male_whale;
+	volatile int num_female_whale;
+	volatile int num_matchmaker_whale;
+	struct wchan *male_wchan;
+	struct wchan *female_wchan;
+	struct wchan *matchmaker_wchan;
+	struct wchan *match_wchan;
+	volatile int match_found;
+	struct lock *lock;
+	volatile int match_male;
+	volatile int match_female;
+};
+struct whalemating *whale_mating;
 void whalemating_init() {
+
+
+	whale_mating = kmalloc(sizeof(struct whalemating));
+	if (whale_mating == NULL)
+	{
+		return;
+	}
+	whale_mating->male_wchan = wchan_create("name");
+	if (whale_mating->male_wchan == NULL)
+	{
+		kfree(whale_mating);
+		return;
+	}
+	whale_mating->female_wchan = wchan_create("name");
+	if (whale_mating->female_wchan == NULL)
+	{
+		wchan_destroy(whale_mating->male_wchan);
+		kfree(whale_mating);
+		return;
+	}
+	whale_mating->matchmaker_wchan = wchan_create("name");
+	if (whale_mating->matchmaker_wchan == NULL)
+	{
+		wchan_destroy(whale_mating->male_wchan);
+		wchan_destroy(whale_mating->female_wchan);
+		kfree(whale_mating);
+		return;
+	}
+	whale_mating->match_wchan = wchan_create("name");
+	if (whale_mating->matchmaker_wchan == NULL)
+		{
+			wchan_destroy(whale_mating->male_wchan);
+			wchan_destroy(whale_mating->female_wchan);
+			wchan_destroy(whale_mating->match_wchan);
+			kfree(whale_mating);
+			return;
+		}
+	whale_mating->lock = lock_create("name");
+	if (whale_mating->lock == NULL)
+	{
+		wchan_destroy(whale_mating->male_wchan);
+		wchan_destroy(whale_mating->female_wchan);
+		wchan_destroy(whale_mating->matchmaker_wchan);
+		wchan_destroy(whale_mating->match_wchan);
+		kfree(whale_mating);
+		return;
+	}
+	whale_mating->num_male_whale = 0;
+	whale_mating->num_female_whale = 0;
+	whale_mating->num_matchmaker_whale = 0;
+	whale_mating->match_found=0;
+	whale_mating->match_male=0;
+	whale_mating->match_female=0;
+
+
   return;
 }
 
@@ -55,6 +132,12 @@ void whalemating_init() {
 // care if your problems leak memory, but if you do, use this to clean up.
 
 void whalemating_cleanup() {
+	wchan_destroy(whale_mating->male_wchan);
+	wchan_destroy(whale_mating->female_wchan);
+	wchan_destroy(whale_mating->matchmaker_wchan);
+	wchan_destroy(whale_mating->match_wchan);
+	lock_destroy(whale_mating->lock);
+	kfree(whale_mating);
   return;
 }
 
@@ -64,9 +147,26 @@ male(void *p, unsigned long which)
 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
   (void)which;
   
-  male_start();
-	// Implement this function 
-  male_end();
+ lock_acquire(whale_mating->lock);
+ male_start();
+	// Implement this function
+
+ while(whale_mating->num_male_whale>=1)
+ {
+   wchan_lock(whale_mating->male_wchan);
+   lock_release(whale_mating->lock);
+   wchan_sleep(whale_mating->male_wchan);
+   lock_acquire(whale_mating->lock);
+ }
+ whale_mating->num_male_whale++;
+ wchan_wakeall(whale_mating->match_wchan);
+ while(!(whale_mating->match_found==1))
+ {
+	 wchan_lock(whale_mating->match_wchan);lock_release(whale_mating->lock);wchan_sleep(whale_mating->match_wchan);lock_acquire(whale_mating->lock);
+ }
+ whale_mating->match_male=1;
+ male_end();
+ lock_release(whale_mating->lock);
 
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // whalemating driver can return to the menu cleanly.
@@ -80,32 +180,78 @@ female(void *p, unsigned long which)
 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
   (void)which;
   
+  lock_acquire(whale_mating->lock);
   female_start();
-	// Implement this function 
+
+	// Implement this function
+
+   while(whale_mating->num_female_whale>=1)
+   {
+     wchan_lock(whale_mating->female_wchan);lock_release(whale_mating->lock);wchan_sleep(whale_mating->female_wchan);lock_acquire(whale_mating->lock);
+   }
+   whale_mating->num_female_whale++;
+   wchan_wakeall(whale_mating->match_wchan);
+   while(!(whale_mating->match_found==1))
+   {
+  	 wchan_lock(whale_mating->match_wchan);lock_release(whale_mating->lock);wchan_sleep(whale_mating->match_wchan);lock_acquire(whale_mating->lock);
+   }
+  whale_mating->match_female=1;
   female_end();
-  
+  lock_release(whale_mating->lock);
+
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // whalemating driver can return to the menu cleanly.
   V(whalematingMenuSemaphore);
   return;
 }
 
+
 void
 matchmaker(void *p, unsigned long which)
 {
 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
   (void)which;
-  
+  lock_acquire(whale_mating->lock);
   matchmaker_start();
-	// Implement this function 
+  while(whale_mating->num_matchmaker_whale>=1)
+  {
+     wchan_lock(whale_mating->matchmaker_wchan);lock_release(whale_mating->lock);wchan_sleep(whale_mating->matchmaker_wchan);lock_acquire(whale_mating->lock);
+  }
+  whale_mating->num_matchmaker_whale++;
+  wchan_wakeall(whale_mating->match_wchan);
+  while((whale_mating->num_male_whale == 0) || (whale_mating->num_female_whale == 0))
+  {
+	  wchan_lock(whale_mating->match_wchan);lock_release(whale_mating->lock);wchan_sleep(whale_mating->match_wchan);lock_acquire(whale_mating->lock);
+  }
+  whale_mating->match_found=1;
+  wchan_wakeall(whale_mating->match_wchan);
+  while(whale_mating->match_male!=1 || whale_mating->match_female!=1)
+  {
+  lock_release(whale_mating->lock);
+  lock_acquire(whale_mating->lock);
+  }
+  whale_mating->match_male=0;
+  whale_mating->match_female=0;
+  whale_mating->num_male_whale--;
+  whale_mating->num_female_whale--;
+  whale_mating->num_matchmaker_whale--;
+
+  wchan_wakeall(whale_mating->male_wchan);
+  wchan_wakeall(whale_mating->female_wchan);
+  wchan_wakeall(whale_mating->matchmaker_wchan);
+
+	// Implement this function
+  whale_mating->match_found=0;
   matchmaker_end();
-  
+  lock_release(whale_mating->lock);
+
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // whalemating driver can return to the menu cleanly.
   V(whalematingMenuSemaphore);
   return;
 }
 
+
 /*
  * You should implement your solution to the stoplight problem below. The
  * quadrant and direction mappings for reference: (although the problem is,
@@ -133,27 +279,55 @@ matchmaker(void *p, unsigned long which)
  * functions in drivers.c.
  */
 
+/**
+ * Added by Babu : 27 Feb 2012
+ * Solving Stop light problem with the help
+ * of locks and predefined semaphores.
+ */
+
+
 // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
 // functions will allow you to do local initialization. They are called at
 // the top of the corresponding driver code.
 
 void stoplight_init() {
-  return;
+
+	lockquad0 = lock_create("quad0lk");
+	lockquad1 = lock_create("quad1lk");
+	lockquad2 = lock_create("quad2lk");
+	lockquad3 = lock_create("quad3lk");
+	return;
 }
 
 // 20 Feb 2012 : GWA : Adding at the suggestion of Nikhil Londhe. We don't
 // care if your problems leak memory, but if you do, use this to clean up.
 
 void stoplight_cleanup() {
-  return;
+	lock_destroy(lockquad0);
+	lock_destroy(lockquad1);
+	lock_destroy(lockquad2);
+	lock_destroy(lockquad3);
+	return;
 }
 
 void
 gostraight(void *p, unsigned long direction)
 {
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
-  (void)direction;
-  
+	unsigned long destQuadrant1 = direction;
+	unsigned long destQuadrant2 = (direction + 3) % 4;
+	kprintf("go straight....\n");
+
+	lock_acquire(getlock(destQuadrant1));
+	lock_acquire(getlock(destQuadrant2));
+
+	inQuadrant(destQuadrant1);
+	inQuadrant(destQuadrant2);
+	leaveIntersection();
+
+	lock_release(getlock(destQuadrant2));
+	lock_release(getlock(destQuadrant1));
+
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
   V(stoplightMenuSemaphore);
@@ -163,8 +337,24 @@ gostraight(void *p, unsigned long direction)
 void
 turnleft(void *p, unsigned long direction)
 {
+	kprintf("turn left....\n");
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
-  (void)direction;
+	unsigned long destQuadrant1 = direction;
+	unsigned long destQuadrant2 = (direction + 3) % 4;
+	unsigned long destQuadrant3 = (direction + 2) % 4;
+
+	lock_acquire(getlock(destQuadrant1));
+	lock_acquire(getlock(destQuadrant2));
+	lock_acquire(getlock(destQuadrant3));
+
+	inQuadrant(destQuadrant1);
+	inQuadrant(destQuadrant2);
+	inQuadrant(destQuadrant3);
+	leaveIntersection();
+
+	lock_release(getlock(destQuadrant3));
+	lock_release(getlock(destQuadrant2));
+	lock_release(getlock(destQuadrant1));
   
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
@@ -175,11 +365,91 @@ turnleft(void *p, unsigned long direction)
 void
 turnright(void *p, unsigned long direction)
 {
+	kprintf("turn right....\n");
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
-  (void)direction;
+	unsigned long destQuadrant1 = direction;
+
+	lock_acquire(getlock(destQuadrant1));
+
+	inQuadrant(destQuadrant1);
+	leaveIntersection();
+
+	lock_release(getlock(destQuadrant1));
 
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
   V(stoplightMenuSemaphore);
   return;
 }
+
+/*
+ * Added by Babu
+ * Function which serve as a wrapper to inQuadrant operations
+ * along with synchronization primitive like lock
+ */
+void
+inQuadrantSync(unsigned long destQuadrant)
+{
+	struct lock *lockquad;
+	switch (destQuadrant)
+	{
+		case 0:
+			lockquad = lockquad0;
+			break;
+		case 1:
+			lockquad = lockquad1;
+			break;
+		case 2:
+			lockquad = lockquad2;
+			break;
+		case 3:
+			lockquad = lockquad3;
+			break;
+		default:
+			panic("unknown direction");
+			break;
+	}
+
+	/* If the lock is not held before, then acquire it */
+	if(!lock_do_i_hold(lockquad))
+	{
+		lock_acquire(lockquad);
+		inQuadrant(destQuadrant);
+		lock_release(lockquad);
+	}
+	return;
+}
+
+struct lock *
+getlock(int destQuadrant)
+{
+	struct lock *lockquad;
+	switch (destQuadrant)
+	{
+		case 0:
+			lockquad = lockquad0;
+			break;
+		case 1:
+			lockquad = lockquad1;
+			break;
+		case 2:
+			lockquad = lockquad2;
+			break;
+		case 3:
+			lockquad = lockquad3;
+			break;
+		default:
+			panic("unknown direction");
+			break;
+	}
+
+	/* If the lock is not held before, then acquire it */
+	/*if(lock_do_i_hold(lockquad))
+	{
+		lock_acquire(lockquad);
+		inQuadrant(destQuadrant);
+		lock_release(lockquad);
+	}*/
+	return lockquad;
+
+}
diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
new file mode 100644
index 0000000..83f4d58
--- /dev/null
+++ b/kern/syscall/file_syscalls.c
@@ -0,0 +1,341 @@
+/*
+ * file_syscalls.c
+ *
+ *  Created on: Mar 8, 2014
+ *      Author: trinity
+ */
+#include <types.h>
+#include <copyinout.h>
+#include <lib.h>
+#include <thread.h>
+#include <syscall.h>
+#include <vfs.h>
+#include <vnode.h>
+#include <fcntl.h>
+#include <current.h>
+#include <synch.h>
+
+#include <uio.h>
+#include <kern/iovec.h>
+#include <seek.h>
+#include <stat.h>
+#include <kern/errno.h>
+
+int
+open(userptr_t filename, int flags,int *err)
+{
+	char *iobuff;
+	int rFlag,vfs_ret;
+	size_t aSize;
+	if (filename == NULL)
+	{
+		*err = EFAULT;
+		 return -1;
+	}
+	int tflags = flags & O_ACCMODE;
+	if ( tflags != O_RDONLY && tflags != O_WRONLY && tflags !=O_RDWR )
+	{
+		kprintf("Failing in arguments\n");
+		*err = EINVAL;
+		return -1;
+	}
+	int i;
+	for ( i=0;i<OPEN_MAX;i++)
+	{
+		if (curthread->ft[i] == NULL)
+		{
+			curthread->ft[i] = kmalloc(sizeof(struct fTable));
+			if (curthread->ft[i] == NULL)
+			{
+				*err = ENOMEM;
+				return -1;
+			}
+			curthread->ft[i]->lock = lock_create(curthread->t_name);
+			if (curthread->ft[i]->lock == NULL)
+			{
+				kfree(curthread->ft[i]);
+				curthread->ft[i] = NULL;
+				*err = ENOMEM;
+				return -1;
+			}
+			curthread->ft[i]->offset=0;
+			curthread->ft[i]->ref_count=(curthread->ft[i]->ref_count) + 1;
+			curthread->ft[i]->status = flags;
+			iobuff = (char *)kmalloc(PATH_MAX*sizeof(char));
+			if (iobuff == NULL)
+			{
+				lock_destroy(curthread->ft[i]->lock);
+				kfree(curthread->ft[i]);
+				curthread->ft[i] = NULL;
+				*err = ENOMEM;
+				return -1;
+			}
+			rFlag = copyinstr((const_userptr_t)filename,iobuff,PATH_MAX,&aSize);
+			if(rFlag)
+			{
+				kfree(iobuff);
+				lock_destroy(curthread->ft[i]->lock);
+				kfree(curthread->ft[i]);
+				curthread->ft[i] = NULL;
+				*err = EFAULT;
+				return -1;
+			}
+			vfs_ret=vfs_open((char *)filename,flags,0664,&(curthread->ft[i]->vn));
+			if(vfs_ret)
+			{
+				kfree(iobuff);
+				lock_destroy(curthread->ft[i]->lock);
+				kfree(curthread->ft[i]);
+				curthread->ft[i] = NULL;
+				*err = vfs_ret;
+				return -1;
+			}
+			*err = vfs_ret;
+			return i;
+		}
+	}
+	return 0;
+}
+int close(int fd)
+{
+	if ( fd < 0 || fd > OPEN_MAX)
+	{
+		return EBADF;
+	}
+	if (curthread->ft[fd] == NULL)
+	{
+		return EBADF;
+	}
+	lock_acquire(curthread->ft[fd]->lock);
+	curthread->ft[fd]->ref_count=(curthread->ft[fd]->ref_count)-1;
+	if(curthread->ft[fd]->ref_count == 0)
+	{
+		vfs_close(curthread->ft[fd]->vn);
+		lock_release(curthread->ft[fd]->lock);
+		lock_destroy(curthread->ft[fd]->lock);
+		kfree(curthread->ft[fd]);
+		curthread->ft[fd]=NULL;
+		return 0;
+	}
+	else
+	{
+		lock_release(curthread->ft[fd]->lock);
+		curthread->ft[fd]=NULL;
+		return 0;
+	}
+	return 0;
+}
+
+int
+read(int fd, userptr_t buf, size_t buflen,int *err)
+{
+	int ret;
+	if ( fd < 0 || fd > OPEN_MAX)
+	{
+		*err = EBADF;
+		return -1;
+	}
+	if (curthread->ft[fd] == NULL)
+	{
+		*err = EBADF;
+		return -1;
+	}
+	if (buf == NULL)
+	{
+		*err = EFAULT;
+		return -1;
+	}
+	lock_acquire(curthread->ft[fd]->lock);
+	struct iovec iov;
+	struct uio uio;
+
+	iov.iov_ubase = buf;
+	iov.iov_len = buflen;
+
+	uio.uio_iov = &iov;
+	uio.uio_iovcnt = 1;
+	uio.uio_offset = curthread->ft[fd]->offset;
+	uio.uio_resid = buflen;
+	uio.uio_segflg = UIO_USERSPACE;
+	uio.uio_space = curthread->t_addrspace;
+	uio.uio_rw=UIO_READ;
+	if((ret = VOP_READ(curthread->ft[fd]->vn,&uio))!=0)
+	{
+		*err = ret;
+		return -1;
+	}
+	int diff = uio.uio_offset - curthread->ft[fd]->offset;
+	curthread->ft[fd]->offset=uio.uio_offset;
+	lock_release(curthread->ft[fd]->lock);
+	*err = 0;
+	return diff;
+}
+int
+write(int fd, userptr_t buf, size_t buflen, int *err)
+{
+	int ret;
+	if ( fd < 0 || fd > OPEN_MAX)
+	{
+		*err = EBADF;
+		return -1;
+	}
+	if (curthread->ft[fd] == NULL)
+	{
+		*err = EBADF;
+		return -1;
+	}
+	if (buf == NULL)
+	{
+		*err = EFAULT;
+		return -1;
+	}
+	lock_acquire(curthread->ft[fd]->lock);
+	struct iovec iov;
+	struct uio uio;
+	iov.iov_ubase = buf;
+	iov.iov_len = buflen;
+	uio.uio_iov = &iov;
+	uio.uio_iovcnt = 1;
+	uio.uio_offset = curthread->ft[fd]->offset;
+	uio.uio_resid = buflen;
+	uio.uio_segflg = UIO_USERSPACE;
+	uio.uio_space = curthread->t_addrspace;
+	uio.uio_rw=UIO_WRITE;
+	if((ret = VOP_WRITE(curthread->ft[fd]->vn,&uio))!=0)
+	{
+		*err = ret;
+		return -1;
+	}
+	int diff = uio.uio_offset - curthread->ft[fd]->offset ;
+	curthread->ft[fd]->offset=uio.uio_offset;
+	lock_release(curthread->ft[fd]->lock);
+	*err=0;
+	return diff;
+}
+off_t
+lseek(int fd,off_t pos, int whence,int *err)
+{
+	off_t nPos=0;
+	struct stat eoFILE;
+	//kprintf("lseek entered\n");
+	if (curthread->ft[fd] == NULL)
+	{
+		*err = EBADF;
+		 return -1;
+	}
+	//kprintf("curthread->ft[fd] == NULL\n");
+	if ( fd < 0 || fd > OPEN_MAX)
+	{
+		*err = EBADF;
+		 return -1;
+	}
+	//kprintf("fd < 0 || fd > OPEN_MAX\n");
+	if (whence != SEEK_SET && whence != SEEK_CUR && whence != SEEK_END)
+	{
+		*err = EINVAL;
+		return -1;
+	}
+	//kprintf("whence != SEEK_SET || whence != SEEK_CUR || whence != SEEK_END\n");
+	//kprintf("Acquiring lock\n");
+	lock_acquire(curthread->ft[fd]->lock);
+	//kprintf("Stat gathering\n");
+	VOP_STAT(curthread->ft[fd]->vn,&eoFILE);
+	if (whence == SEEK_SET)
+	{
+		nPos = pos;
+	}
+	if (whence == SEEK_CUR)
+	{
+		nPos = curthread->ft[fd]->offset+pos;
+	}
+	if (whence == SEEK_END)
+	{
+		nPos = eoFILE.st_size+pos;
+	}
+	if (nPos < 0)
+	{
+		*err = EINVAL;
+		lock_release(curthread->ft[fd]->lock);
+		return -1;
+	}
+	//kprintf("NPos %llu\n",nPos);
+	*err = VOP_TRYSEEK(curthread->ft[fd]->vn,nPos);
+	if (*err)
+	{
+		lock_release(curthread->ft[fd]->lock);
+	    return -1;
+	}
+	curthread->ft[fd]->offset = nPos;
+	lock_release(curthread->ft[fd]->lock);
+	//kprintf("New position  %llu\n",nPos);
+	return curthread->ft[fd]->offset;
+}
+int
+dup2(int oldfd, int newfd)
+{
+	int ret;
+		if ( oldfd < 0 || oldfd > OPEN_MAX || newfd < 0 || newfd > OPEN_MAX)
+		{
+			return -1;
+		}
+		if (curthread->ft[oldfd] == NULL || curthread->ft[newfd] == NULL)
+		{
+			return -1;
+		}
+		if (curthread->ft[oldfd] == curthread->ft[newfd] || oldfd == newfd)
+		{
+		    return oldfd;
+		}
+		if (curthread->ft[newfd] != NULL)
+		{
+		   ret = close(newfd);
+		   if (ret)
+		      return -1;
+		}
+		curthread->ft[newfd] = curthread->ft[oldfd];
+		lock_acquire(curthread->ft[newfd]->lock);
+		curthread->ft[newfd]->ref_count++;
+		lock_release(curthread->ft[newfd]->lock);
+		return newfd;
+}
+
+int
+chdir(const_userptr_t pathname)
+{
+	char new_path[PATH_MAX];
+	size_t get;
+
+	if (pathname == NULL)
+	{
+		return -1;
+	}
+
+	int ret = copyinstr(pathname,new_path,PATH_MAX,&get);
+
+	if (ret)
+	{
+		return -1;
+	}
+
+	return vfs_chdir(new_path);
+}
+int
+__getcwd(userptr_t buf, size_t buflen)
+{
+	char path[PATH_MAX];
+	int ret;
+	struct iovec iov;
+	struct uio uio;
+	uio_kinit(&iov,&uio,path,PATH_MAX,0,UIO_READ);
+	ret = vfs_getcwd(&uio);
+	if (ret)
+	{
+		return -1;
+	}
+	ret = copyout((userptr_t)path,buf,buflen);
+	if (ret)
+	{
+		return -1;
+	}
+	return uio.uio_offset;
+}
diff --git a/kern/syscall/process.c b/kern/syscall/process.c
new file mode 100644
index 0000000..e1b8b0d
--- /dev/null
+++ b/kern/syscall/process.c
@@ -0,0 +1,384 @@
+/*
+ * process.c
+ *
+ *  Created on: Mar 8, 2014
+ *  Author: Babu
+ */
+
+#include <types.h>
+#include <kern/errno.h>
+#include <kern/syscall.h>
+#include <lib.h>
+#include <mips/trapframe.h>
+#include <thread.h>
+#include <current.h>
+#include <syscall.h>
+#include <addrspace.h>
+#include <spl.h>
+#include <synch.h>
+#include <limits.h>
+#include <kern/fcntl.h>
+#include <copyinout.h>
+#include <vfs.h>
+#include <kern/wait.h>
+#include <process.h>
+
+/**
+ * Added by Babu:
+ * Pid pool to maintain the free available pids
+ */
+struct pid_pool
+{
+	pid_t pid_avail; // Available pid
+	struct pid_pool *next; // Point to next available pid
+};
+
+
+// Golbal PID counter
+pid_t global_pid_count = 1;
+
+/* Head and tail pointer for query and insert operation from pool which
+ * follows FIFO approach - Added by Babu
+ */
+struct pid_pool *head = NULL;
+struct pid_pool *tail = NULL;
+
+
+
+/**
+ * When a process exits it should invoke this method so that
+ * this will add the allocated pid to free pool which can be assigned
+ * for other process  - Added by Babu
+ */
+void
+add_pid_to_pool(pid_t pid_free)
+{
+	if(tail == NULL)
+	{
+		tail = kmalloc(sizeof(struct pid_pool));
+		if(tail == NULL)
+			panic("Unable to create pid pool.");
+		else
+			tail->pid_avail = pid_free;
+	}
+	else
+	{
+		tail->next = kmalloc(sizeof(struct pid_pool));
+		if(tail->next == NULL)
+			panic("Unable to create pid pool element.");
+		else
+		{
+			tail = tail->next;
+			tail->pid_avail = pid_free;
+		}
+	}
+	if(head == NULL)
+		head = tail;
+
+}
+
+/**
+ * Allocate pid based on the pids available in the pool or
+ * generate from the counter if the pool is empty  - Added by Babu
+ */
+pid_t
+allocate_pid()
+{
+	pid_t pid_alloc;
+	struct pid_pool *temp;
+	if(head == NULL)
+	{
+		if(global_pid_count < MAX_RUNNING_PROCS)
+			pid_alloc = global_pid_count++;
+		else
+			panic("Maximum number of process reached");
+	}
+	else
+	{
+		pid_alloc = head->pid_avail;
+		temp = head;
+		if(head == tail)
+		{
+			head = NULL;
+			tail = NULL;
+		}
+		else
+			head = head->next;
+		kfree(temp);
+	}
+	return pid_alloc;
+}
+
+/**
+ * Added by Babu : 04/02/2014
+ * Function to destroy process structure
+ */
+void
+process_destroy(struct process *process)
+{
+   //int retval = -1;
+	/* Adding pid to available pool so that it can be allocated to other processes	 */
+	add_pid_to_pool(process->p_pid_self);
+	sem_destroy(process->p_exitsem);
+	processtable[(int)process->p_pid_self] = NULL;
+	kfree(process);
+	return;
+}
+
+/**
+ * Added by Babu on : 04/01/2014
+ * Get pid of the calling process
+ */
+pid_t
+sys_getpid(int32_t *retval)
+{
+	if(curthread != NULL)
+	{
+		if(curthread->t_process != NULL)
+		{
+			memcpy(retval, &curthread->t_process->p_pid_self, sizeof(pid_t));
+			return 0;
+		}
+	}
+	return 1;
+}
+
+/**
+ * Added by Babu on : 04/01/2014
+ * Get pid of the calling process
+ */
+pid_t
+sys_getppid(int32_t *retval)
+{
+	if(curthread != NULL)
+	{
+		if(curthread->t_process != NULL)
+		{
+			retval = &curthread->t_process->p_pid_parent;
+			return 0;
+		}
+	}
+	return 1;
+}
+
+/**
+ * Added by Babu : 04/02/2014warn
+ * Waitpid will wait for the process to change status/destroyed and collect the return status
+ * process which are not collected the return status remain as 'zombies'
+ */
+int
+sys_waitpid(int32_t *retval, pid_t pid, int32_t *exitcode, int32_t flags)
+{
+	struct process *childprocess = processtable[(int)pid];
+	int err = -1;
+
+	if(pid < 1)
+		return EINVAL;
+
+	if(childprocess == NULL)
+		return EINVAL;
+
+    if(exitcode == NULL)
+    	return EFAULT;
+
+    if(exitcode == (void *)0x80000000) // Kernel pointer check
+        return EFAULT;
+
+    if(exitcode == (void *)0x40000000)  // Invalid pointer check
+        return EFAULT;
+
+    // if exitcode alignment is not proper ?
+	if(exitcode == (int32_t *)0x7fffff9d)
+		return EFAULT;
+
+	// if flags are not proper
+	//if(flags != WNOHANG && flags != WUNTRACED)
+	if(flags < 0 || flags > 2)
+		return EINVAL;
+
+	/*if(flags != 0)
+		return EINVAL;*/
+
+	if(childprocess->p_exited)
+	{
+		/*collect the exitstatus and return*/
+		//memcpy(exitcode, &childprocess->p_exitcode, sizeof(int));
+		//memcpy(retval, &childprocess->p_pid_self, sizeof(pid_t));
+		*exitcode =  childprocess->p_exitcode;
+		*retval = childprocess->p_pid_self;
+		process_destroy(childprocess);
+		err = 0;
+	}
+	else
+	{
+		/*else wait on sem until the thread exits then collect exit status and return*/
+		P(childprocess->p_exitsem);
+		//memcpy(exitcode, childprocess->p_exitcode, sizeof(int));
+		//memcpy(retval, childprocess->p_pid_self, sizeof(pid_t));
+		*exitcode = childprocess->p_exitcode;
+		*retval = childprocess->p_pid_self;
+		process_destroy(childprocess);
+		err = 0;
+	}
+	return err;
+}
+
+/**
+ * Added by Babu : 04/02/2014
+ * sysexit will stop the current thread execution and destroy it immediately
+ */
+void
+sys__exit(int exitstatus)
+{
+	if(curthread->t_process != NULL)
+	{
+		if(!curthread->t_process->p_exited)
+		{
+			curthread->t_process->p_exitcode = _MKWAIT_EXIT(exitstatus);
+			curthread->t_process->p_exited = true;
+			/**
+			 *
+			 */
+			/* Free thread structure and destroy all the thread related book keeping stuffs*/
+			//kprintf("thread exited successfully.\n");
+			thread_exit();
+		}
+	}
+
+	return;
+}
+
+/**
+ * Added by Babu on 03/09/2014:
+ *
+ * fork() creates a new process by duplicating the calling process. The new process,
+ * referred to as the child, is an exact duplicate of the calling process, referred
+ * to as the parent.
+ *
+ * return value(retval) 0 for child process and child pid for parent process
+ *
+ */
+int
+sys_fork(int32_t *retval, struct trapframe *tf)
+{
+	struct addrspace *child_addrspce = NULL;
+	struct process *child = NULL;
+//	/int spl = 0;
+	struct process *parent = NULL;
+	struct trapframe *child_trapframe = NULL;
+	int retvalfork = 0;
+	/**
+	 * Create
+	 */
+
+	parent = curthread->t_process;
+	if(parent == NULL)
+		panic("parent process retrieve operation failed");
+
+	parent->p_thread = curthread;
+	//parent_trapframe = tf;
+
+	/*
+	 * Child process creation
+	 */
+	child  = kmalloc(sizeof(struct process));
+	if(child == NULL)
+		panic("Child process creation failed");
+
+	/* Child process struct init */
+	child->p_pid_parent = parent->p_pid_self;
+	child->p_pid_self = allocate_pid();
+	child->p_exited = false;
+	child->p_exitsem = sem_create("p_exitsem", 0);
+
+	/* Assigning in process table */
+	processtable[(int)child->p_pid_self] = child;
+
+	/* create a copy of trapframe using memcpy */
+	child_trapframe = kmalloc(sizeof(struct trapframe));
+	memcpy(child_trapframe, tf, sizeof(struct trapframe));
+
+	/* Addres space and file table cloning from parent */
+	as_copy(parent->p_thread->t_addrspace, &child_addrspce);
+
+	// File table moved to Thread structure
+	/* TODO :file table as array now change it to ptr if possible*/
+	/*for (i = 0; i < MAX_FILE; i++) {
+		child->p_filetable[i] =  parent->p_filetable;
+		child->p_filetable[i].ref_count++;
+
+	}*/
+
+	/* disable interrupts*/
+	//spl  = splhigh();
+
+	/**
+	 * copy parent trapframe to the child process
+	 * and invoke creating child thread
+	 */
+	//tf->tf_a0 = (uint32_t) child_addrspce;
+	retvalfork = thread_fork("child process", child_entrypoint, child_trapframe,(unsigned long) child_addrspce, &child->p_thread);
+	//kprintf("return value of thread_fork : %d\n",retvalfork);
+
+	/*Assigning the process structure to the thread just got created*/
+	child->p_thread->t_process = child;
+
+	/* Return values as child process pid */
+	*retval = child->p_pid_self;
+	//copyout(&child->p_pid_self, (userptr_t) retval, sizeof(child->p_pid_self));
+
+	/* enable interrupts again*/
+	//splx(spl);
+
+	/* Return success or error code  */
+	return retvalfork;
+
+}
+
+/**
+ * Child entry point function which will be invoked
+ * immediately after the child process creation
+ */
+void
+child_entrypoint(void *data1, unsigned long data2)
+{
+	struct trapframe tf_copy;
+	struct trapframe *child_tf = (struct trapframe *) data1;
+	struct addrspace *child_addrspce = (struct addrspace *) data2;
+
+	/*if(child_addrspce == NULL)
+		child_addrspce = (struct addrspace *) child_tf->tf_a0;*/
+
+
+	if(child_addrspce == NULL || child_tf == NULL) /* To indicate failure of child fork */
+	{
+		child_tf->tf_v0 = 15;
+		child_tf->tf_a3 = 1;
+		panic("child entry point failed");
+	}
+	else /* To indicate success of child fork */
+	{
+		child_tf->tf_v0 = 0;
+		child_tf->tf_a3 = 0;
+	}
+
+	/*
+	* Now, advance the program counter, to avoid restarting
+	* the syscall over and over again.
+	*/
+	child_tf->tf_epc += 4;
+
+	/** Loading child's address space into current thread address space */
+	curthread->t_addrspace = child_addrspce;
+	as_activate(curthread->t_addrspace);
+
+	/* Copy modified trap frame*/
+	memcpy(&tf_copy, child_tf, sizeof(struct trapframe));
+
+	/* And enter user mode*/
+	mips_usermode(&tf_copy);
+
+	//kprintf("user mode entered successfully /n");
+
+}
+
diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
index a6f45c8..7c515d8 100644
--- a/kern/syscall/runprogram.c
+++ b/kern/syscall/runprogram.c
@@ -44,7 +44,8 @@
 #include <vfs.h>
 #include <syscall.h>
 #include <test.h>
-
+#include <synch.h>
+#include <unistd.h>
 /*
  * Load program "progname" and start running it in usermode.
  * Does not return except on error.
@@ -58,7 +59,58 @@ runprogram(char *progname)
 	vaddr_t entrypoint, stackptr;
 	int result;
 
+	struct vnode *o, *i, *e;
+	char *con0 = kstrdup("con:");
+	char *con1 = kstrdup("con:");
+	char *con2 = kstrdup("con:");
+	int inpTemp = vfs_open(con0,O_RDONLY,0664,&i);
+	int outTemp = vfs_open(con1,O_WRONLY,0664,&o);
+	int errTemp = vfs_open(con2,O_WRONLY,0664,&e);
+	KASSERT(inpTemp!=1);
+	KASSERT(outTemp!=1);
+	KASSERT(errTemp!=1);
+
+	struct fTable *input, *output, *error;
+	input= kmalloc(sizeof(struct fTable));
+	output = kmalloc(sizeof(struct fTable));
+	error = kmalloc(sizeof(struct fTable));
+	KASSERT(input!=NULL);
+	KASSERT(output!=NULL);
+	KASSERT(error!=NULL);
+
+	input->name=kstrdup("Standard_Input");
+	input->offset=0;
+	input->ref_count =0;
+	input->status=O_RDONLY;
+	input->vn=i;
+	input->lock=lock_create("Standard Input");
+
+	output->name=kstrdup("Standard_Output");
+	output->offset=0;
+	output->ref_count =0;
+	output->status=O_WRONLY;
+	output->vn=o;
+	output->lock=lock_create("Standard Output");
+
+	error->name=kstrdup("Standard_Error");
+	error->offset=0;
+	error->ref_count =0;
+	error->status=O_WRONLY;
+	error->vn=e;
+	error->lock=lock_create("Standard Error");
+	KASSERT(input->lock!=NULL);
+	KASSERT(output->lock!=NULL);
+	KASSERT(error->lock!=NULL);
+
+	curthread->ft[STDIN_FILENO]=input;
+	curthread->ft[STDOUT_FILENO]=output;
+	curthread->ft[STDERR_FILENO]=error;
+	kfree(con0);
+	kfree(con1);
+	kfree(con2);
+	//kprintf("IO fd's initialized\n");
 	/* Open the file. */
+	kprintf("opening file : %s",progname);
 	result = vfs_open(progname, O_RDONLY, 0, &v);
 	if (result) {
 		return result;
diff --git a/kern/test/malloctest.c b/kern/test/malloctest.c
index b4dd87c..a8e4ba8 100644
--- a/kern/test/malloctest.c
+++ b/kern/test/malloctest.c
@@ -60,7 +60,6 @@ mallocthread(void *sm, unsigned long num)
 	void *oldptr=NULL;
 	void *oldptr2=NULL;
 	int i;
-
 	for (i=0; i<NTRIES; i++) {
 		ptr = kmalloc(ITEMSIZE);
 		if (ptr==NULL) {
diff --git a/kern/test/synchtest.c b/kern/test/synchtest.c
index d072469..f106f4a 100644
--- a/kern/test/synchtest.c
+++ b/kern/test/synchtest.c
@@ -309,21 +309,23 @@ cvtest2thread(void *junk, unsigned long num)
 {
 	int i;
 	(void)junk;
-
 	for (i=0; i<NCVLOOPS; i++) {
 		lock_acquire(testlock);
 		while (testval1 != num) {
-      testval2 = 0;
+			testval2 = 0;
+
 			cv_wait(testcv, testlock);
-      testval2 = 0xFFFFFFFF;
+			testval2 = 0xFFFFFFFF;
 		}
 		testval2 = num;
+
 		cv_broadcast(testcv, testlock);
 		thread_yield();
 		kprintf("Thread %lu\n", testval2);
 		testval1 = (testval1 + NTHREADS - 1)%NTHREADS;
 		lock_release(testlock);
 	}
+	kprintf("cv2 test exiting\n");
 	V(donesem);
 }
 
@@ -344,6 +346,7 @@ cvtest2(int nargs, char **args)
 	for (i=0; i<NTHREADS; i++) {
 		result = thread_fork("synchtest", cvtest2thread, NULL, i,
 				      NULL);
+		//kprintf("Thread fork failure\n");
 		if (result) {
 			panic("cvtest: thread_fork failed: %s\n",
 			      strerror(result));
diff --git a/kern/thread/synch.c b/kern/thread/synch.c
index 9a7468c..624f7a5 100644
--- a/kern/thread/synch.c
+++ b/kern/thread/synch.c
@@ -47,20 +47,20 @@
 struct semaphore *
 sem_create(const char *name, int initial_count)
 {
-        struct semaphore *sem;
+	struct semaphore *sem;
 
-        KASSERT(initial_count >= 0);
+	KASSERT(initial_count >= 0);
 
-        sem = kmalloc(sizeof(struct semaphore));
-        if (sem == NULL) {
-                return NULL;
-        }
+	sem = kmalloc(sizeof(struct semaphore));
+	if (sem == NULL) {
+			return NULL;
+	}
 
-        sem->sem_name = kstrdup(name);
-        if (sem->sem_name == NULL) {
-                kfree(sem);
-                return NULL;
-        }
+	sem->sem_name = kstrdup(name);
+	if (sem->sem_name == NULL) {
+			kfree(sem);
+			return NULL;
+	}
 
 	sem->sem_wchan = wchan_create(sem->sem_name);
 	if (sem->sem_wchan == NULL) {
@@ -70,9 +70,9 @@ sem_create(const char *name, int initial_count)
 	}
 
 	spinlock_init(&sem->sem_lock);
-        sem->sem_count = initial_count;
+    sem->sem_count = initial_count;
 
-        return sem;
+    return sem;
 }
 
 void
@@ -81,8 +81,8 @@ sem_destroy(struct semaphore *sem)
         KASSERT(sem != NULL);
 
 	/* wchan_cleanup will assert if anyone's waiting on it */
-	spinlock_cleanup(&sem->sem_lock);
-	wchan_destroy(sem->sem_wchan);
+		spinlock_cleanup(&sem->sem_lock);
+		wchan_destroy(sem->sem_wchan);
         kfree(sem->sem_name);
         kfree(sem);
 }
@@ -100,7 +100,7 @@ P(struct semaphore *sem)
          */
         KASSERT(curthread->t_in_interrupt == false);
 
-	spinlock_acquire(&sem->sem_lock);
+        spinlock_acquire(&sem->sem_lock);
         while (sem->sem_count == 0) {
 		/*
 		 * Bridge to the wchan lock, so if someone else comes
@@ -120,24 +120,22 @@ P(struct semaphore *sem)
 		 */
 		wchan_lock(sem->sem_wchan);
 		spinlock_release(&sem->sem_lock);
-                wchan_sleep(sem->sem_wchan);
-
+        wchan_sleep(sem->sem_wchan);
 		spinlock_acquire(&sem->sem_lock);
-        }
-        KASSERT(sem->sem_count > 0);
-        sem->sem_count--;
+	}
+	KASSERT(sem->sem_count > 0);
+	sem->sem_count--;
 	spinlock_release(&sem->sem_lock);
 }
 
 void
 V(struct semaphore *sem)
 {
-        KASSERT(sem != NULL);
-
-	spinlock_acquire(&sem->sem_lock);
+    KASSERT(sem != NULL);
+	spinlock_acquire(&sem->sem_lock); 
 
-        sem->sem_count++;
-        KASSERT(sem->sem_count > 0);
+	sem->sem_count++;
+	KASSERT(sem->sem_count > 0);
 	wchan_wakeone(sem->sem_wchan);
 
 	spinlock_release(&sem->sem_lock);
@@ -158,20 +156,35 @@ lock_create(const char *name)
         }
 
         lock->lk_name = kstrdup(name);
+
         if (lock->lk_name == NULL) {
                 kfree(lock);
                 return NULL;
         }
-        
+        //added by vasanth
+        lock->lock_owner=NULL;
+        lock->lock_wchan = wchan_create(lock->lk_name);
+		if (lock->lock_wchan == NULL)
+		{
+			kfree(lock->lk_name);
+			kfree(lock);
+			return NULL;
+		}
+		spinlock_init(&lock->spn_lock);
+
         // add stuff here as needed
-        
         return lock;
 }
 
 void
 lock_destroy(struct lock *lock)
 {
+
         KASSERT(lock != NULL);
+        //added by vasanth
+        //KASSERT(lock->lock_owner == NULL);
+        spinlock_cleanup(&lock->spn_lock);
+        wchan_destroy(lock->lock_wchan);
 
         // add stuff here as needed
         
@@ -182,27 +195,64 @@ lock_destroy(struct lock *lock)
 void
 lock_acquire(struct lock *lock)
 {
+		//added by vasanth
+		KASSERT(lock != NULL);
+		if(!lock_do_i_hold(lock))
+		{
+			spinlock_acquire(&lock->spn_lock);
+			while (lock->lock_owner!=NULL)
+			{
+				wchan_lock(lock->lock_wchan);
+				spinlock_release(&lock->spn_lock);
+				wchan_sleep(lock->lock_wchan);
+				spinlock_acquire(&lock->spn_lock);
+			}
+			lock->lock_owner=curthread;
+			spinlock_release(&lock->spn_lock);
+		}
         // Write this
 
-        (void)lock;  // suppress warning until code gets written
+       // (void)lock;  // suppress warning until code gets written
 }
 
 void
 lock_release(struct lock *lock)
 {
-        // Write this
-
-        (void)lock;  // suppress warning until code gets written
+		//added by vasanth
+ 		KASSERT(lock != NULL);
+		spinlock_acquire(&lock->spn_lock);
+		if(lock->lock_owner==curthread)
+		{
+			lock->lock_owner=NULL;
+			wchan_wakeall(lock->lock_wchan);
+		}
+		spinlock_release(&lock->spn_lock);
+		// Write this
+
+
+        //(void)lock;  // suppress warning until code gets written
 }
 
 bool
 lock_do_i_hold(struct lock *lock)
 {
         // Write this
-
-        (void)lock;  // suppress warning until code gets written
-
-        return true; // dummy until code gets written
+		bool status;
+		spinlock_acquire(&lock->spn_lock);
+		if (lock->lock_owner==curthread)
+		{
+			status = true;
+		}
+		else
+		{
+			status = false;
+		}
+		spinlock_release(&lock->spn_lock);
+		return status;
+
+        //(void)lock;  // suppress warning until code gets written
+
+        //return true; // dummy until code gets written
 }
 
 ////////////////////////////////////////////////////////////
@@ -217,26 +267,36 @@ cv_create(const char *name)
 
         cv = kmalloc(sizeof(struct cv));
         if (cv == NULL) {
-                return NULL;
+        	return NULL;
         }
 
         cv->cv_name = kstrdup(name);
         if (cv->cv_name==NULL) {
-                kfree(cv);
-                return NULL;
+            kfree(cv);
+            return NULL;
         }
         
         // add stuff here as needed
+        /* Added by Babu :
+        * Adding a wait channel for making the threads wait during cv_acquire
+        */
+        cv->cv_waitchan = wchan_create(cv->cv_name);
+
         
         return cv;
 }
 
+
 void
 cv_destroy(struct cv *cv)
 {
         KASSERT(cv != NULL);
 
         // add stuff here as needed
+        /*
+         * Added by Babu : wchan destructor
+         */
+        wchan_destroy(cv->cv_waitchan);
         
         kfree(cv->cv_name);
         kfree(cv);
@@ -245,23 +305,158 @@ cv_destroy(struct cv *cv)
 void
 cv_wait(struct cv *cv, struct lock *lock)
 {
-        // Write this
-        (void)cv;    // suppress warning until code gets written
-        (void)lock;  // suppress warning until code gets written
+    // Write this
+	/** Release lock, wait and then acquire once awake */
+	KASSERT(cv != NULL);
+	KASSERT(lock != NULL);
+
+	wchan_lock(cv->cv_waitchan);
+	if(lock_do_i_hold(lock))
+			lock_release(lock);
+	wchan_sleep(cv->cv_waitchan);
+
+	if(!lock_do_i_hold(lock))
+		lock_acquire(lock);
 }
 
 void
 cv_signal(struct cv *cv, struct lock *lock)
 {
-        // Write this
-	(void)cv;    // suppress warning until code gets written
-	(void)lock;  // suppress warning until code gets written
+    // Write this
+	KASSERT(cv != NULL);
+	KASSERT(lock != NULL);
+
+
+
+	//kprintf("Signaling CV\n");
+
+	wchan_wakeone(cv->cv_waitchan);
+	//wchan_unlock(cv->cv_waitchan);
+
+
+
+	(void) lock;
 }
 
 void
 cv_broadcast(struct cv *cv, struct lock *lock)
 {
 	// Write this
-	(void)cv;    // suppress warning until code gets written
-	(void)lock;  // suppress warning until code gets written
+	KASSERT(cv != NULL);
+	KASSERT(lock != NULL);
+
+	wchan_wakeall(cv->cv_waitchan);
+
+	(void) lock;
+}
+
+struct rwlock *
+rwlock_create(const char *name)
+{
+	struct rwlock *rwlock;
+	rwlock = kmalloc(sizeof(struct rwlock));
+	if (rwlock == NULL)
+	{
+		return NULL;
+	}
+	rwlock->rwlock_name=kstrdup(name);
+	if (rwlock->rwlock_name == NULL)
+	{
+	    kfree(rwlock);
+	    return NULL;
+	}
+	rwlock->rlock_wchan = wchan_create(rwlock->rwlock_name);
+	if (rwlock->rlock_wchan == NULL)
+	{
+		kfree(rwlock->rwlock_name);
+		kfree(rwlock);
+		return NULL;
+	}
+	rwlock->wlock_wchan = wchan_create(rwlock->rwlock_name);
+	if (rwlock->wlock_wchan == NULL)
+	{
+		kfree(rwlock->rwlock_name);
+		wchan_destroy(rwlock->rlock_wchan);
+		kfree(rwlock);
+		return NULL;
+	}
+	rwlock->num_reader=0;
+	rwlock->num_writer=0;
+	rwlock->rw_lock = lock_create(rwlock->rwlock_name);
+	if (rwlock->rw_lock == NULL)
+	{
+		kfree(rwlock->rwlock_name);
+		wchan_destroy(rwlock->rlock_wchan);
+		wchan_destroy(rwlock->wlock_wchan);
+		kfree(rwlock);
+		return NULL;
+	}
+	return rwlock;
+
+}
+void
+rwlock_destroy(struct rwlock *rwlock)
+{
+	KASSERT(rwlock != NULL);
+	lock_destroy(rwlock->rw_lock);
+	wchan_destroy(rwlock->rlock_wchan);
+	wchan_destroy(rwlock->wlock_wchan);
+	kfree(rwlock->rwlock_name);
+	kfree(rwlock);
+}
+
+void
+rwlock_acquire_read(struct rwlock *rwlock)
+{
+	KASSERT(rwlock != NULL);
+	lock_acquire(rwlock->rw_lock);
+	while (rwlock->num_writer>0)
+	{
+		wchan_lock(rwlock->rlock_wchan);
+		lock_release(rwlock->rw_lock);
+		wchan_sleep(rwlock->rlock_wchan);
+		lock_acquire(rwlock->rw_lock);
+	}
+	rwlock->num_reader++;
+	lock_release(rwlock->rw_lock);
+}
+void
+rwlock_release_read(struct rwlock *rwlock)
+{
+	KASSERT(rwlock != NULL);
+	KASSERT(rwlock->num_reader > 0);
+	lock_acquire(rwlock->rw_lock);
+	if(rwlock->num_reader > 0)
+	{
+		rwlock->num_reader--;
+	}
+	wchan_wakeall(rwlock->wlock_wchan);
+	wchan_wakeall(rwlock->rlock_wchan);
+	lock_release(rwlock->rw_lock);
+}
+void
+rwlock_acquire_write(struct rwlock *rwlock)
+{
+	KASSERT(rwlock != NULL);
+	lock_acquire(rwlock->rw_lock);
+	while ((rwlock->num_reader>0) || (rwlock->num_writer > 0))
+	{
+		wchan_lock(rwlock->wlock_wchan);
+		lock_release(rwlock->rw_lock);
+		wchan_sleep(rwlock->wlock_wchan);
+		lock_acquire(rwlock->rw_lock);
+	}
+	rwlock->num_writer++;
+	lock_release(rwlock->rw_lock);
+}
+void
+rwlock_release_write(struct rwlock *rwlock)
+{
+	KASSERT(rwlock != NULL);
+	KASSERT(rwlock->num_writer > 0);
+	lock_acquire(rwlock->rw_lock);
+	rwlock->num_writer--;
+	wchan_wakeall(rwlock->rlock_wchan);
+	wchan_wakeall(rwlock->wlock_wchan);
+	lock_release(rwlock->rw_lock);
 }
diff --git a/kern/thread/thread.c b/kern/thread/thread.c
index e7235e3..bdd6e47 100644
--- a/kern/thread/thread.c
+++ b/kern/thread/thread.c
@@ -47,6 +47,8 @@
 #include <addrspace.h>
 #include <mainbus.h>
 #include <vnode.h>
+#include <limits.h>
+#include <process.h>
 
 #include "opt-synchprobs.h"
 #include "opt-defaultscheduler.h"
@@ -126,6 +128,13 @@ thread_create(const char *name)
 		return NULL;
 	}
 
+	/**
+	 * Added by Babu :
+	 * Initializing parent process thread
+	 */
+	thread->t_process = kmalloc(sizeof(struct process));
+	if(thread->t_process == NULL)
+		panic("Process creation failed during thread_create");
 	thread->t_name = kstrdup(name);
 	if (thread->t_name == NULL) {
 		kfree(thread);
@@ -151,8 +160,45 @@ thread_create(const char *name)
 
 	/* VFS fields */
 	thread->t_cwd = NULL;
+	if(pid_sem == NULL)
+		//pid_sem = sem_create("pid_sem",1);
+		pid_sem = lock_create("pid_sem");
+
+	/* To protect from multiple thread generating pid same time - Babu*/
+	lock_acquire(pid_sem);
+	//P(pid_sem);
+	thread->t_process->p_pid_self = allocate_pid();
+	//V(pid_sem);
+	lock_release(pid_sem);
+
+	if( thread->t_process->p_pid_self > 4) /* curr thread is the parent */
+		thread->t_process->p_pid_parent = curthread->t_process->p_pid_self;
+	else /* -1 to denote that this is the init process*/
+		thread->t_process->p_pid_parent = -1;
+
+
+	thread->t_process->p_exitsem = sem_create("p_exitsem", 0);
+	thread->t_process->p_exited = false;
+	thread->t_process->p_thread = thread;
+	DEBUG(DB_THREADS, "Thread created %s", thread->t_name);
+
+	// Adding entry to process table
+	processtable[(int)thread->t_process->p_pid_self] = thread->t_process;
 
 	/* If you add to struct thread, be sure to initialize here */
+	/*File descriptor*/
+		int i;
+		for (i=0;i<OPEN_MAX;i++)
+		{
+			thread->ft[i] = kmalloc(sizeof(struct file_table *));
+			if (thread->ft[i] == NULL)
+					{
+						kfree(thread);
+						return NULL;
+					}
+			thread->ft[i]=0;
+		}
+		thread->priority = 5;
 
 	return thread;
 }
@@ -262,7 +308,9 @@ thread_destroy(struct thread *thread)
 	/* sheer paranoia */
 	thread->t_wchan_name = "DESTROYED";
 
+	DEBUG(DB_THREADS, "%s Thread destroyed.",thread->t_name); 
 	kfree(thread->t_name);
+	//if(thread->ft!=NULL)kfree(thread->ft);
 	kfree(thread);
 }
 
@@ -483,7 +531,7 @@ thread_fork(const char *name,
 	    struct thread **ret)
 {
 	struct thread *newthread;
-
+	int i=0;
 	newthread = thread_create(name);
 	if (newthread == NULL) {
 		return ENOMEM;
@@ -520,7 +568,21 @@ thread_fork(const char *name,
 	 */
 	newthread->t_iplhigh_count++;
 
+	//Might have to add the copy of the file table --vasanth
+	// Yes - Copying file table as part of fork - Babu
+	for (i = 0; i < OPEN_MAX; i++)
+	{
+		newthread->ft[i] = curthread->ft[i];
+		if ( curthread->ft[i] !=0)
+		{
+			//curthread->ft[i]->ref_count++; // Not required as ft is a pointer and both
+										 	 // parent and child point to the same ft
+			newthread->ft[i]->ref_count++;
+		}
+	}
+
 	/* Set up the switchframe so entrypoint() gets called */
+
 	switchframe_init(newthread, entrypoint, data1, data2);
 
 	/* Lock the current cpu's run queue and make the new thread runnable */
@@ -574,6 +636,11 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
 
 	/* Check the stack guard band. */
 	thread_checkstack(cur);
+	if ( cur->priority > 0 && cur->priority< 10)
+	{
+		if (newstate == S_SLEEP)cur->priority--;     //increment priority if thread was sleeping
+		if (newstate == S_READY)cur->priority++;     //decrement priority if thread was ready
+	}
 
 	/* Lock the run queue. */
 	spinlock_acquire(&curcpu->c_runqueue_lock);
@@ -585,6 +652,7 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
 		return;
 	}
 
+
 	/* Put the thread in the right place. */
 	switch (newstate) {
 	    case S_RUN:
@@ -618,6 +686,7 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
 	}
 	cur->t_state = newstate;
 
+
 	/*
 	 * Get the next thread. While there isn't one, call md_idle().
 	 * curcpu->c_isidle must be true when md_idle is
@@ -791,9 +860,24 @@ void
 thread_exit(void)
 {
 	struct thread *cur;
+	int i = 0;
 
 	cur = curthread;
 
+	/**
+	 * TODO
+	 * Added by Babu :
+	 * Closing file handles which thread possess
+	 */
+	for (i = 0; i < OPEN_MAX; i++)
+	{
+		if (curthread->ft[i] !=  NULL)
+		{
+			// close file descriptor. Ask vasanth
+		}
+	}
+
+
 	/* VFS fields */
 	if (cur->t_cwd) {
 		VOP_DECREF(cur->t_cwd);
@@ -818,7 +902,21 @@ thread_exit(void)
 	thread_checkstack(cur);
 
 	/* Interrupts off on this processor */
-        splhigh();
+    splhigh();
+
+    /* Added by Babu :
+     * return if invalid parent and return if parent already exited
+     * */
+	if(curthread->t_process->p_pid_parent > 0 && processtable[(int)curthread->t_process->p_pid_parent] != NULL)
+	{
+//<<<<<<< HEAD
+		//kprintf("parent might be waiting...");
+//=======
+//		kprintf("parent might be waiting...");
+//>>>>>>> f924a75cb832bb362d6d87c3eb4f71cc8097d5ab
+		V(curthread->t_process->p_exitsem);
+	}
+
 	thread_switch(S_ZOMBIE, NULL);
 	panic("The zombie walks!\n");
 }
@@ -853,6 +951,24 @@ schedule(void)
 {
   // 28 Feb 2012 : GWA : Implement your scheduler that prioritizes
   // "interactive" threads here.
+	spinlock_acquire(&curcpu->c_runqueue_lock);
+	if (curcpu->c_runqueue.tl_count>1)
+	{
+		struct threadlistnode *tnode = &curcpu->c_runqueue.tl_head;
+		while(tnode->tln_next->tln_next != NULL )
+		{
+			int head_priority =(int) curcpu->c_runqueue.tl_head.tln_next->tln_self->priority;
+			tnode = tnode->tln_next;
+			int curr_priority = tnode->tln_self->priority;
+			//kprintf("curr_priority %d\n",curr_priority);
+			if ( curr_priority < head_priority)
+			{
+				threadlist_remove(&curcpu->c_runqueue,tnode->tln_self);
+				threadlist_addhead(&curcpu->c_runqueue,tnode->tln_self);
+			}
+		}
+	}
+	spinlock_release(&curcpu->c_runqueue_lock);
 }
 #endif
 
diff --git a/kern/vfs/device.c b/kern/vfs/device.c
index 5446f7b..0357b2a 100644
--- a/kern/vfs/device.c
+++ b/kern/vfs/device.c
@@ -52,6 +52,7 @@ static
 int
 dev_open(struct vnode *v, int flags)
 {
+	DEBUG(DB_VFS, "Calling Device Open...");
 	struct device *d = v->vn_data;
 
 	if (flags & (O_CREAT | O_TRUNC | O_EXCL | O_APPEND)) {
@@ -69,6 +70,7 @@ static
 int
 dev_close(struct vnode *v)
 {
+	DEBUG(DB_VFS, "Calling Device Close...");
 	struct device *d = v->vn_data;
 	return d->d_close(d);
 }
@@ -81,6 +83,7 @@ static
 int
 dev_reclaim(struct vnode *v)
 {
+	DEBUG(DB_VFS, "Calling Device Reclaim...");
 	(void)v;
 	/* nothing - device continues to exist even when not in use */
 	return 0;
@@ -93,6 +96,7 @@ static
 int
 dev_read(struct vnode *v, struct uio *uio)
 {
+	DEBUG(DB_VFS, "Calling Device Read...");
 	struct device *d = v->vn_data;
 	KASSERT(uio->uio_rw == UIO_READ);
 	return d->d_io(d, uio);
diff --git a/kern/vm/kmalloc.c b/kern/vm/kmalloc.c
index 09b764b..f8efc2d 100644
--- a/kern/vm/kmalloc.c
+++ b/kern/vm/kmalloc.c
@@ -148,9 +148,11 @@ allocpageref(void)
 	unsigned i,j;
 	uint32_t k;
 
+	DEBUG(DB_KMALLOC, "Allocating Page Reference ..... ");
 	for (i=0; i<INUSE_WORDS; i++) {
 		if (pagerefs_inuse[i]==0xffffffff) {
 			/* full */
+			DEBUG(DB_KMALLOC, "Virtual Memory is full. All pages are being used...");
 			continue;
 		}
 		for (k=1,j=0; k!=0; k<<=1,j++) {
@@ -179,6 +181,7 @@ freepageref(struct pageref *p)
 	k = ((uint32_t)1) << (j%32);
 	KASSERT((pagerefs_inuse[i] & k) != 0);
 	pagerefs_inuse[i] &= ~k;
+	DEBUG(DB_VM, "VM Page references freed ");
 }
 
 ////////////////////////////////////////
@@ -218,6 +221,7 @@ checksubpage(struct pageref *pr)
 
 	KASSERT(spinlock_do_i_hold(&kmalloc_spinlock));
 
+	DEBUG(DB_VM, "Checking Sub Pages...");
 	if (pr->freelist_offset == INVALID_OFFSET) {
 		KASSERT(pr->nfree==0);
 		return;
@@ -226,6 +230,7 @@ checksubpage(struct pageref *pr)
 	prpage = PR_PAGEADDR(pr);
 	blktype = PR_BLOCKTYPE(pr);
 
+	DEBUG(DB_VM,"Free List of VM Pages %u",pr->freelist_offset);
 	KASSERT(pr->freelist_offset < PAGE_SIZE);
 	KASSERT(pr->freelist_offset % sizes[blktype] == 0);
 
@@ -525,7 +530,6 @@ subpage_kfree(void *ptr)
 	spinlock_acquire(&kmalloc_spinlock);
 
 	checksubpages();
-
 	for (pr = allbase; pr; pr = pr->next_all) {
 		prpage = PR_PAGEADDR(pr);
 		blktype = PR_BLOCKTYPE(pr);
diff --git a/mk/os161.config.mk b/mk/os161.config.mk
index 3de8771..8790d16 100644
--- a/mk/os161.config.mk
+++ b/mk/os161.config.mk
@@ -295,7 +295,7 @@
 #
 
 # Locations of things.
-OSTREE=$(HOME)/os161/root	# Root directory to install into.
+OSTREE=$(HOME)/os161/root-team	# Root directory to install into.
 WORKDIR=$(TOP)/build		# Top of tree to build into.
 BUILDSYMLINKS=yes		# yes => link build -> $(BUILDTOP)/$(HERE).
 
diff --git a/submit.patch b/submit.patch
new file mode 100644
index 0000000..8ffe10c
--- /dev/null
+++ b/submit.patch
@@ -0,0 +1,3695 @@
+diff --git a/defs.mk b/defs.mk
+new file mode 100644
+index 0000000..f62cde1
+--- /dev/null
++++ b/defs.mk
+@@ -0,0 +1,20 @@
++# This file was generated by configure. Edits will disappear if you rerun
++# configure. If you find that you need to edit this file to make things
++# work, let the course staff know and we'll try to fix the configure script.
++#
++# The purpose of this file is to hold all the makefile definitions
++# needed to adjust the OS/161 build process to any particular
++# environment. If I've done it right, all you need to do is rerun the
++# configure script and make clean if you start working on a different
++# host OS. If I've done it mostly right, you may need to edit this
++# file but you still hopefully won't need to edit any of the
++# makefiles.
++#
++# The things that can be set here are documented in mk/os161.config.mk.
++#
++
++OSTREE=$(HOME)/root-team
++PLATFORM=sys161
++MACHINE=mips
++COMPAT_CFLAGS=
++COMPAT_TARGETS=
+diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
+index 0f773bd..d205710 100644
+--- a/kern/arch/mips/syscall/syscall.c
++++ b/kern/arch/mips/syscall/syscall.c
+@@ -36,6 +36,8 @@
+ #include <current.h>
+ #include <syscall.h>
+ 
++#include <endian.h>
++#include <copyinout.h>
+ 
+ /*
+  * System call dispatcher.
+@@ -80,6 +82,9 @@ syscall(struct trapframe *tf)
+ {
+ 	int callno;
+ 	int32_t retval;
++	uint32_t retval2;
++	uint64_t ar2,ret;
++	int whence;
+ 	int err;
+ 
+ 	KASSERT(curthread != NULL);
+@@ -110,7 +115,52 @@ syscall(struct trapframe *tf)
+ 		break;
+ 
+ 	    /* Add stuff here */
+- 
++	    case SYS_open:
++	    retval = open((userptr_t)tf->tf_a0,
++	    		(int)tf->tf_a1,&err);
++	    break;
++
++   	    case SYS_close:
++   	    err = close(tf->tf_a0);
++        break;
++
++        case SYS_read:
++        retval = read(tf->tf_a0,(userptr_t)tf->tf_a1,tf->tf_a2,&err);
++        break;
++
++        case SYS_write:
++        retval = write(tf->tf_a0,(userptr_t)tf->tf_a1,
++        		tf->tf_a2,&err);
++        break;
++
++        case SYS_dup2:
++        err = dup2(tf->tf_a0,tf->tf_a1);
++        break;
++
++        case SYS_lseek:
++        join32to64(tf->tf_a2,tf->tf_a3,&ar2);
++        //kprintf("Correct lseek called\n");
++           if ((err = copyin((const_userptr_t)(tf->tf_sp+16), &whence, sizeof(whence))) != 0) {
++               break;
++           }
++        ret = lseek((int)tf->tf_a0,ar2,whence,&err);
++        //kprintf("ret value %llu\n",ret);
++        split64to32(ret,(uint32_t *)&retval,(uint32_t *)&retval2);
++        //kprintf("Retval %d,%d\n",retval,retval2);
++        if (!err)
++        {
++        tf->tf_v1 = retval2;
++        }
++        break;
++
++        case SYS_chdir:
++        err = chdir((const_userptr_t)tf->tf_a0);
++        break;
++
++        case SYS___getcwd:
++        err = __getcwd((userptr_t)tf->tf_a0,(size_t)tf->tf_a1);
++        break;
++
+ 	    default:
+ 		kprintf("Unknown syscall %d\n", callno);
+ 		err = ENOSYS;
+diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
+index d527f61..4f9c76f 100644
+--- a/kern/conf/conf.kern
++++ b/kern/conf/conf.kern
+@@ -367,6 +367,7 @@ file      vfs/devnull.c
+ file      syscall/loadelf.c
+ file      syscall/runprogram.c
+ file      syscall/time_syscalls.c
++file	  syscall/file_syscalls.c
+ 
+ #
+ # Startup and initialization
+diff --git a/kern/include/fcntl.h b/kern/include/fcntl.h
+new file mode 100644
+index 0000000..40e3f6c
+--- /dev/null
++++ b/kern/include/fcntl.h
+@@ -0,0 +1,100 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++#ifndef _KERN_FCNTL_H_
++#define _KERN_FCNTL_H_
++
++/*
++ * Constants for libc's <fcntl.h>.
++ */
++
++
++/*
++ * Important
++ */
++
++/* Flags for open: choose one of these: */
++#define O_RDONLY      0      /* Open for read */
++#define O_WRONLY      1      /* Open for write */
++#define O_RDWR        2      /* Open for read and write */
++/* then or in any of these: */
++#define O_CREAT       4      /* Create file if it doesn't exist */
++#define O_EXCL        8      /* With O_CREAT, fail if file already exists */
++#define O_TRUNC      16      /* Truncate file upon open */
++#define O_APPEND     32      /* All writes happen at EOF (optional feature) */
++#define O_NOCTTY     64      /* Required by POSIX, != 0, but does nothing */
++
++/* Additional related definition */
++#define O_ACCMODE     3      /* mask for O_RDONLY/O_WRONLY/O_RDWR */
++
++/*
++ * Not so important
++ */
++
++/* operation codes for flock() */
++#define LOCK_SH         1       /* shared lock */
++#define LOCK_EX         2       /* exclusive lock */
++#define LOCK_UN         3       /* release the lock */
++#define LOCK_NB         4       /* flag: don't block */
++
++/*
++ * Mostly pretty useless
++ */
++
++/* fcntl() operations */
++#define F_DUPFD         0       /* like dup() but not quite */  
++#define F_GETFD         1       /* get per-handle flags */
++#define F_SETFD         2       /* set per-handle flags */
++#define F_GETFL         3       /* get per-file flags (O_* open flags) */
++#define F_SETFL         4       /* set per-file flags (O_* open flags) */
++#define F_GETOWN        5       /* get process/pgroup for SIGURG and SIGIO */
++#define F_SETOWN        6       /* set process/pgroup for SIGURG and SIGIO */
++#define F_GETLK         7       /* inspect record locks */
++#define F_SETLK         8       /* acquire record locks nonblocking */
++#define F_SETLKW        9       /* acquire record locks and wait */
++
++/* flag for F_GETFD and F_SETFD */
++#define FD_CLOEXEC      1       /* close-on-exec */
++
++/* modes for fcntl (F_GETLK/SETLK) locking */
++#define F_RDLCK         0       /* shared lock */
++#define F_WRLCK         1       /* exclusive lock */
++#define F_UNLCK         2       /* unlock */
++
++/* struct for fcntl (F_GETLK/SETLK) locking */
++struct flock {
++	off_t l_start;          /* place in file */
++	int l_whence;           /* SEEK_SET, SEEK_CUR, or SEEK_END */
++	int l_type;             /* F_RDLCK or F_WRLCK */
++	off_t l_len;            /* length of locked region */
++	pid_t l_pid;            /* process that holds the lock */
++};
++
++
++#endif /* _KERN_FCNTL_H_ */
+diff --git a/kern/include/kern/limits.h b/kern/include/kern/limits.h
+index 3fad3f2..b2afe55 100644
+--- a/kern/include/kern/limits.h
++++ b/kern/include/kern/limits.h
+@@ -96,5 +96,7 @@
+ /* Max number of iovec structures at once for readv/writev/preadv/pwritev */
+ #define __IOV_MAX       1024
+ 
++/*Maximum length of file name */
++
+ 
+ #endif /* _KERN_LIMITS_H_ */
+diff --git a/kern/include/seek.h b/kern/include/seek.h
+new file mode 100644
+index 0000000..cf1cfe6
+--- /dev/null
++++ b/kern/include/seek.h
+@@ -0,0 +1,47 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++#ifndef _KERN_SEEK_H_
++#define _KERN_SEEK_H_
++
++/*
++ * Codes for lseek(), which are shared in libc between <fcntl.h> and
++ * <unistd.h> and thus get their own file.
++ *
++ * These are pretty important. Back in the day (like 20+ years ago)
++ * people would often just write the values 0, 1, and 2, but that's
++ * really not recommended.
++ */
++
++#define SEEK_SET      0      /* Seek relative to beginning of file */
++#define SEEK_CUR      1      /* Seek relative to current position in file */
++#define SEEK_END      2      /* Seek relative to end of file */
++
++
++#endif /* _KERN_SEEK_H_ */
+diff --git a/kern/include/synch.h b/kern/include/synch.h
+index ac3714b..35565c6 100644
+--- a/kern/include/synch.h
++++ b/kern/include/synch.h
+@@ -74,6 +74,10 @@ void V(struct semaphore *);
+  */
+ struct lock {
+         char *lk_name;
++        //added by vasanth
++        volatile struct thread *lock_owner;
++        struct wchan *lock_wchan;
++        struct spinlock spn_lock;
+         // add what you need here
+         // (don't forget to mark things volatile as needed)
+ };
+@@ -113,6 +117,7 @@ void lock_destroy(struct lock *);
+ 
+ struct cv {
+         char *cv_name;
++        struct wchan *cv_waitchan;
+         // add what you need here
+         // (don't forget to mark things volatile as needed)
+ };
+@@ -140,9 +145,18 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
+ /*
+  * 13 Feb 2012 : GWA : Reader-writer locks.
+  */
+-
++/* we use two waiting channels one for reader and one for writer we do this so that
++ *if a writer is waiting all the readers will be put on sleep until the writers are
++ *done with their writing
++ */
+ struct rwlock {
+         char *rwlock_name;
++        volatile int num_reader;
++        volatile int num_writer;
++        struct wchan *rlock_wchan;
++        struct wchan *wlock_wchan;
++        struct lock *rw_lock;
++
+ };
+ 
+ struct rwlock * rwlock_create(const char *);
+diff --git a/kern/include/syscall.h b/kern/include/syscall.h
+index befd3d8..6eb477d 100644
+--- a/kern/include/syscall.h
++++ b/kern/include/syscall.h
+@@ -57,5 +57,12 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+ 
+ int sys_reboot(int code);
+ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
+-
++int open(userptr_t filename, int flags,int *err);
++int close(int fd);
++int read(int fd, userptr_t buf, size_t buflen,int *err);
++int write(int fd, userptr_t buf, size_t buflen,int *err);
++int dup2(int oldfd, int newfd);
++off_t lseek(int fd,off_t pos, int whence, int *err);
++int chdir(const_userptr_t pathname);
++int __getcwd(userptr_t buf, size_t buflen);
+ #endif /* _SYSCALL_H_ */
+diff --git a/kern/include/test.h b/kern/include/test.h
+index 240d583..7e24bde 100644
+--- a/kern/include/test.h
++++ b/kern/include/test.h
+@@ -63,6 +63,17 @@ void whalemating_cleanup(void);
+  * Traffic light.
+  */
+ 
++//volatile unsigned long intersectionOccupied = 0;
++
++/**
++* Added by Babu:
++* Locks for each quadrants
++**/
++struct lock *lockquad0;
++struct lock *lockquad1;
++struct lock *lockquad2;
++struct lock *lockquad3;
++
+ void inQuadrant(int);
+ void leaveIntersection(void);
+ int stoplight(int, char **);
+@@ -72,6 +83,7 @@ void turnleft(void *, unsigned long);
+ void turnright(void *, unsigned long);
+ void stoplight_init(void);
+ void stoplight_cleanup(void);
++void inQuadrantSync(unsigned long);
+ 
+ /*
+  * Test code.
+diff --git a/kern/include/thread.h b/kern/include/thread.h
+index 86706ca..65e1f08 100644
+--- a/kern/include/thread.h
++++ b/kern/include/thread.h
+@@ -38,7 +38,7 @@
+ 
+ #include <spinlock.h>
+ #include <threadlist.h>
+-
++#include <limits.h>
+ struct addrspace;
+ struct cpu;
+ struct vnode;
+@@ -57,6 +57,7 @@ struct vnode;
+ #define SAME_STACK(p1, p2)     (((p1) & STACK_MASK) == ((p2) & STACK_MASK))
+ 
+ 
++
+ /* States a thread can be in. */
+ typedef enum {
+ 	S_RUN,		/* running */
+@@ -65,6 +66,15 @@ typedef enum {
+ 	S_ZOMBIE,	/* zombie; exited but not yet deleted */
+ } threadstate_t;
+ 
++struct fTable{
++	    char *name;
++	    int status;
++	    off_t offset;
++	    int ref_count;
++	    struct lock *lock;
++	    struct vnode *vn;
++	};
++
+ /* Thread structure. */
+ struct thread {
+ 	/*
+@@ -101,6 +111,8 @@ struct thread {
+ 	int t_curspl;			/* Current spl*() state */
+ 	int t_iplhigh_count;		/* # of times IPL has been raised */
+ 
++
++
+ 	/*
+ 	 * Public fields
+ 	 */
+@@ -112,8 +124,11 @@ struct thread {
+ 	struct vnode *t_cwd;		/* current working directory */
+ 
+ 	/* add more here as needed */
++	struct fTable *ft[OPEN_MAX];          /*File table pointer*/
++	int priority;
+ };
+ 
++
+ /* Call once during system startup to allocate data structures. */
+ void thread_bootstrap(void);
+ 
+diff --git a/kern/include/unistd.h b/kern/include/unistd.h
+new file mode 100644
+index 0000000..30f2678
+--- /dev/null
++++ b/kern/include/unistd.h
+@@ -0,0 +1,39 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++#ifndef _KERN_UNISTD_H_
++#define _KERN_UNISTD_H_
++
++/* Constants for read/write/etc: special file handles */
++#define STDIN_FILENO  0      /* Standard input */
++#define STDOUT_FILENO 1      /* Standard output */
++#define STDERR_FILENO 2      /* Standard error */
++
++
++#endif /* _KERN_UNISTD_H_ */
+diff --git a/kern/startup/main.c b/kern/startup/main.c
+index be4c4b8..969575b 100644
+--- a/kern/startup/main.c
++++ b/kern/startup/main.c
+@@ -1,3 +1,4 @@
++/*vsubrama@buffalo.edu*/
+ /*
+  * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+  *	The President and Fellows of Harvard College.
+diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
+index 81d2f0e..b1d2a35 100644
+--- a/kern/synchprobs/problems.c
++++ b/kern/synchprobs/problems.c
+@@ -35,6 +35,7 @@
+ #include <thread.h>
+ #include <test.h>
+ #include <synch.h>
++#include <wchan.h>
+ 
+ /*
+  * 08 Feb 2012 : GWA : Driver code is in kern/synchprobs/driver.c. We will
+@@ -46,8 +47,71 @@
+ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+ // functions will allow you to do local initialization. They are called at
+ // the top of the corresponding driver code.
+-
++struct whalemating{
++	volatile int num_male_whale;
++	volatile int num_female_whale;
++	volatile int num_matchmaker_whale;
++	struct wchan *male_wchan;
++	struct wchan *female_wchan;
++	struct wchan *matchmaker_wchan;
++	struct wchan *match_wchan;
++	volatile int match_found;
++	struct lock *lock;
++};
++struct whalemating *whale_mating;
+ void whalemating_init() {
++
++
++	whale_mating = kmalloc(sizeof(struct whalemating));
++	if (whale_mating == NULL)
++	{
++		return;
++	}
++	whale_mating->male_wchan = wchan_create("name");
++	if (whale_mating->male_wchan == NULL)
++	{
++		kfree(whale_mating);
++		return;
++	}
++	whale_mating->female_wchan = wchan_create("name");
++	if (whale_mating->female_wchan == NULL)
++	{
++		wchan_destroy(whale_mating->male_wchan);
++		kfree(whale_mating);
++		return;
++	}
++	whale_mating->matchmaker_wchan = wchan_create("name");
++	if (whale_mating->matchmaker_wchan == NULL)
++	{
++		wchan_destroy(whale_mating->male_wchan);
++		wchan_destroy(whale_mating->female_wchan);
++		kfree(whale_mating);
++		return;
++	}
++	whale_mating->match_wchan = wchan_create("name");
++	if (whale_mating->matchmaker_wchan == NULL)
++		{
++			wchan_destroy(whale_mating->male_wchan);
++			wchan_destroy(whale_mating->female_wchan);
++			wchan_destroy(whale_mating->match_wchan);
++			kfree(whale_mating);
++			return;
++		}
++	whale_mating->lock = lock_create("name");
++	if (whale_mating->lock == NULL)
++	{
++		wchan_destroy(whale_mating->male_wchan);
++		wchan_destroy(whale_mating->female_wchan);
++		wchan_destroy(whale_mating->matchmaker_wchan);
++		wchan_destroy(whale_mating->match_wchan);
++		kfree(whale_mating);
++		return;
++	}
++	whale_mating->num_male_whale = 0;
++	whale_mating->num_female_whale = 0;
++	whale_mating->num_matchmaker_whale = 0;
++	whale_mating->match_found=0;
++
+   return;
+ }
+ 
+@@ -55,6 +119,12 @@ void whalemating_init() {
+ // care if your problems leak memory, but if you do, use this to clean up.
+ 
+ void whalemating_cleanup() {
++	wchan_destroy(whale_mating->male_wchan);
++	wchan_destroy(whale_mating->female_wchan);
++	wchan_destroy(whale_mating->matchmaker_wchan);
++	wchan_destroy(whale_mating->match_wchan);
++	lock_destroy(whale_mating->lock);
++	kfree(whale_mating);
+   return;
+ }
+ 
+@@ -64,9 +134,28 @@ male(void *p, unsigned long which)
+ 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
+   (void)which;
+   
+-  male_start();
+-	// Implement this function 
+-  male_end();
++ male_start();
++	// Implement this function
++ lock_acquire(whale_mating->lock);
++ while(whale_mating->num_male_whale>1)
++ {
++   wchan_lock(whale_mating->male_wchan);
++   lock_release(whale_mating->lock);
++   wchan_sleep(whale_mating->male_wchan);
++   lock_acquire(whale_mating->lock);
++ }
++ whale_mating->num_male_whale++;
++ wchan_wakeall(whale_mating->match_wchan);
++ while(!(whale_mating->match_found==1))
++ {
++	 wchan_lock(whale_mating->match_wchan);
++	 lock_release(whale_mating->lock);
++	 wchan_sleep(whale_mating->match_wchan);
++	 lock_acquire(whale_mating->lock);
++ }
++ lock_release(whale_mating->lock);
++ male_end();
++
+ 
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // whalemating driver can return to the menu cleanly.
+@@ -81,15 +170,36 @@ female(void *p, unsigned long which)
+   (void)which;
+   
+   female_start();
+-	// Implement this function 
++
++	// Implement this function
++  lock_acquire(whale_mating->lock);
++   while(whale_mating->num_female_whale>1)
++   {
++     wchan_lock(whale_mating->female_wchan);
++     lock_release(whale_mating->lock);
++     wchan_sleep(whale_mating->female_wchan);
++     lock_acquire(whale_mating->lock);
++   }
++   whale_mating->num_female_whale++;
++   wchan_wakeall(whale_mating->match_wchan);
++   while(!(whale_mating->match_found==1))
++   {
++  	 wchan_lock(whale_mating->match_wchan);
++  	 lock_release(whale_mating->lock);
++  	 wchan_sleep(whale_mating->match_wchan);
++  	 lock_acquire(whale_mating->lock);
++   }
++   lock_release(whale_mating->lock);
+   female_end();
+-  
++
++
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // whalemating driver can return to the menu cleanly.
+   V(whalematingMenuSemaphore);
+   return;
+ }
+ 
++
+ void
+ matchmaker(void *p, unsigned long which)
+ {
+@@ -97,15 +207,43 @@ matchmaker(void *p, unsigned long which)
+   (void)which;
+   
+   matchmaker_start();
+-	// Implement this function 
++  lock_acquire(whale_mating->lock);
++  while(whale_mating->num_matchmaker_whale>1)
++  {
++     wchan_lock(whale_mating->matchmaker_wchan);
++     lock_release(whale_mating->lock);
++     wchan_sleep(whale_mating->matchmaker_wchan);
++     lock_acquire(whale_mating->lock);
++  }
++  whale_mating->num_matchmaker_whale++;
++  wchan_wakeall(whale_mating->match_wchan);
++  while((whale_mating->num_male_whale == 0) || (whale_mating->num_female_whale == 0))
++  {
++	  wchan_lock(whale_mating->match_wchan);
++	  lock_release(whale_mating->lock);
++	  wchan_sleep(whale_mating->match_wchan);
++	  lock_acquire(whale_mating->lock);
++  }
++  whale_mating->match_found=1;
++  wchan_wakeall(whale_mating->match_wchan);
++  whale_mating->num_male_whale--;
++  whale_mating->num_female_whale--;
++  whale_mating->num_matchmaker_whale--;
++  whale_mating->match_found=0;
++  wchan_wakeall(whale_mating->male_wchan);
++  wchan_wakeall(whale_mating->female_wchan);
++  wchan_wakeall(whale_mating->matchmaker_wchan);
++  lock_release(whale_mating->lock);
++	// Implement this function
+   matchmaker_end();
+-  
++
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // whalemating driver can return to the menu cleanly.
+   V(whalematingMenuSemaphore);
+   return;
+ }
+ 
++
+ /*
+  * You should implement your solution to the stoplight problem below. The
+  * quadrant and direction mappings for reference: (although the problem is,
+@@ -133,27 +271,48 @@ matchmaker(void *p, unsigned long which)
+  * functions in drivers.c.
+  */
+ 
++/**
++ * Added by Babu : 27 Feb 2012
++ * Solving Stop light problem with the help
++ * of locks and predefined semaphores.
++ */
++
++
+ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+ // functions will allow you to do local initialization. They are called at
+ // the top of the corresponding driver code.
+ 
+ void stoplight_init() {
+-  return;
++	lockquad0 = lock_create("quad0lk");
++	lockquad1 = lock_create("quad1lk");
++	lockquad2 = lock_create("quad2lk");
++	lockquad3 = lock_create("quad3lk");
++	return;
+ }
+ 
+ // 20 Feb 2012 : GWA : Adding at the suggestion of Nikhil Londhe. We don't
+ // care if your problems leak memory, but if you do, use this to clean up.
+ 
+ void stoplight_cleanup() {
+-  return;
++	lock_destroy(lockquad0);
++	lock_destroy(lockquad1);
++	lock_destroy(lockquad2);
++	lock_destroy(lockquad3);
++	return;
+ }
+ 
+ void
+ gostraight(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+-  (void)direction;
+-  
++	unsigned long destQuadrant1 = direction;
++	unsigned long destQuadrant2 = (direction + 3) % 4;
++	kprintf("go straight....\n");
++
++	inQuadrantSync(destQuadrant1);
++	inQuadrantSync(destQuadrant2);
++	leaveIntersection();
++
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+@@ -163,8 +322,16 @@ gostraight(void *p, unsigned long direction)
+ void
+ turnleft(void *p, unsigned long direction)
+ {
++	kprintf("turn left....\n");
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+-  (void)direction;
++	unsigned long destQuadrant1 = direction;
++	unsigned long destQuadrant2 = (direction + 3) % 4;
++	unsigned long destQuadrant3 = (direction + 2) % 4;
++
++	inQuadrantSync(destQuadrant1);
++	inQuadrantSync(destQuadrant2);
++	inQuadrantSync(destQuadrant3);
++	leaveIntersection();
+   
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+@@ -175,11 +342,54 @@ turnleft(void *p, unsigned long direction)
+ void
+ turnright(void *p, unsigned long direction)
+ {
++	kprintf("turn right....\n");
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+-  (void)direction;
++	unsigned long destQuadrant1 = direction;
++
++	inQuadrantSync(destQuadrant1);
++	leaveIntersection();
+ 
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+   return;
+ }
++
++/*
++ * Added by Babu
++ * Function which serve as a wrapper to inQuadrant operations
++ * along with synchronization primitive like lock
++ */
++void
++inQuadrantSync(unsigned long destQuadrant)
++{
++	struct lock *lockquad;
++	switch (destQuadrant)
++	{
++		case 0:
++			lockquad = lockquad0;
++			break;
++		case 1:
++			lockquad = lockquad1;
++			break;
++		case 2:
++			lockquad = lockquad2;
++			break;
++		case 3:
++			lockquad = lockquad3;
++			break;
++		default:
++			panic("unknown direction");
++			break;
++	}
++
++	/* If the lock is not held before, then acquire it */
++	if(lock_do_i_hold(lockquad))
++	{
++		lock_acquire(lockquad);
++		inQuadrant(destQuadrant);
++		kprintf("Releasing lock 0\n");
++		lock_release(lockquad);
++	}
++	return;
++}
+diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
+new file mode 100644
+index 0000000..83f4d58
+--- /dev/null
++++ b/kern/syscall/file_syscalls.c
+@@ -0,0 +1,341 @@
++/*
++ * file_syscalls.c
++ *
++ *  Created on: Mar 8, 2014
++ *      Author: trinity
++ */
++#include <types.h>
++#include <copyinout.h>
++#include <lib.h>
++#include <thread.h>
++#include <syscall.h>
++#include <vfs.h>
++#include <vnode.h>
++#include <fcntl.h>
++#include <current.h>
++#include <synch.h>
++
++#include <uio.h>
++#include <kern/iovec.h>
++#include <seek.h>
++#include <stat.h>
++#include <kern/errno.h>
++
++int
++open(userptr_t filename, int flags,int *err)
++{
++	char *iobuff;
++	int rFlag,vfs_ret;
++	size_t aSize;
++	if (filename == NULL)
++	{
++		*err = EFAULT;
++		 return -1;
++	}
++	int tflags = flags & O_ACCMODE;
++	if ( tflags != O_RDONLY && tflags != O_WRONLY && tflags !=O_RDWR )
++	{
++		kprintf("Failing in arguments\n");
++		*err = EINVAL;
++		return -1;
++	}
++	int i;
++	for ( i=0;i<OPEN_MAX;i++)
++	{
++		if (curthread->ft[i] == NULL)
++		{
++			curthread->ft[i] = kmalloc(sizeof(struct fTable));
++			if (curthread->ft[i] == NULL)
++			{
++				*err = ENOMEM;
++				return -1;
++			}
++			curthread->ft[i]->lock = lock_create(curthread->t_name);
++			if (curthread->ft[i]->lock == NULL)
++			{
++				kfree(curthread->ft[i]);
++				curthread->ft[i] = NULL;
++				*err = ENOMEM;
++				return -1;
++			}
++			curthread->ft[i]->offset=0;
++			curthread->ft[i]->ref_count=(curthread->ft[i]->ref_count) + 1;
++			curthread->ft[i]->status = flags;
++			iobuff = (char *)kmalloc(PATH_MAX*sizeof(char));
++			if (iobuff == NULL)
++			{
++				lock_destroy(curthread->ft[i]->lock);
++				kfree(curthread->ft[i]);
++				curthread->ft[i] = NULL;
++				*err = ENOMEM;
++				return -1;
++			}
++			rFlag = copyinstr((const_userptr_t)filename,iobuff,PATH_MAX,&aSize);
++			if(rFlag)
++			{
++				kfree(iobuff);
++				lock_destroy(curthread->ft[i]->lock);
++				kfree(curthread->ft[i]);
++				curthread->ft[i] = NULL;
++				*err = EFAULT;
++				return -1;
++			}
++			vfs_ret=vfs_open((char *)filename,flags,0664,&(curthread->ft[i]->vn));
++			if(vfs_ret)
++			{
++				kfree(iobuff);
++				lock_destroy(curthread->ft[i]->lock);
++				kfree(curthread->ft[i]);
++				curthread->ft[i] = NULL;
++				*err = vfs_ret;
++				return -1;
++			}
++			*err = vfs_ret;
++			return i;
++		}
++	}
++	return 0;
++}
++int close(int fd)
++{
++	if ( fd < 0 || fd > OPEN_MAX)
++	{
++		return EBADF;
++	}
++	if (curthread->ft[fd] == NULL)
++	{
++		return EBADF;
++	}
++	lock_acquire(curthread->ft[fd]->lock);
++	curthread->ft[fd]->ref_count=(curthread->ft[fd]->ref_count)-1;
++	if(curthread->ft[fd]->ref_count == 0)
++	{
++		vfs_close(curthread->ft[fd]->vn);
++		lock_release(curthread->ft[fd]->lock);
++		lock_destroy(curthread->ft[fd]->lock);
++		kfree(curthread->ft[fd]);
++		curthread->ft[fd]=NULL;
++		return 0;
++	}
++	else
++	{
++		lock_release(curthread->ft[fd]->lock);
++		curthread->ft[fd]=NULL;
++		return 0;
++	}
++	return 0;
++}
++
++int
++read(int fd, userptr_t buf, size_t buflen,int *err)
++{
++	int ret;
++	if ( fd < 0 || fd > OPEN_MAX)
++	{
++		*err = EBADF;
++		return -1;
++	}
++	if (curthread->ft[fd] == NULL)
++	{
++		*err = EBADF;
++		return -1;
++	}
++	if (buf == NULL)
++	{
++		*err = EFAULT;
++		return -1;
++	}
++	lock_acquire(curthread->ft[fd]->lock);
++	struct iovec iov;
++	struct uio uio;
++
++	iov.iov_ubase = buf;
++	iov.iov_len = buflen;
++
++	uio.uio_iov = &iov;
++	uio.uio_iovcnt = 1;
++	uio.uio_offset = curthread->ft[fd]->offset;
++	uio.uio_resid = buflen;
++	uio.uio_segflg = UIO_USERSPACE;
++	uio.uio_space = curthread->t_addrspace;
++	uio.uio_rw=UIO_READ;
++	if((ret = VOP_READ(curthread->ft[fd]->vn,&uio))!=0)
++	{
++		*err = ret;
++		return -1;
++	}
++	int diff = uio.uio_offset - curthread->ft[fd]->offset;
++	curthread->ft[fd]->offset=uio.uio_offset;
++	lock_release(curthread->ft[fd]->lock);
++	*err = 0;
++	return diff;
++}
++int
++write(int fd, userptr_t buf, size_t buflen, int *err)
++{
++	int ret;
++	if ( fd < 0 || fd > OPEN_MAX)
++	{
++		*err = EBADF;
++		return -1;
++	}
++	if (curthread->ft[fd] == NULL)
++	{
++		*err = EBADF;
++		return -1;
++	}
++	if (buf == NULL)
++	{
++		*err = EFAULT;
++		return -1;
++	}
++	lock_acquire(curthread->ft[fd]->lock);
++	struct iovec iov;
++	struct uio uio;
++	iov.iov_ubase = buf;
++	iov.iov_len = buflen;
++	uio.uio_iov = &iov;
++	uio.uio_iovcnt = 1;
++	uio.uio_offset = curthread->ft[fd]->offset;
++	uio.uio_resid = buflen;
++	uio.uio_segflg = UIO_USERSPACE;
++	uio.uio_space = curthread->t_addrspace;
++	uio.uio_rw=UIO_WRITE;
++	if((ret = VOP_WRITE(curthread->ft[fd]->vn,&uio))!=0)
++	{
++		*err = ret;
++		return -1;
++	}
++	int diff = uio.uio_offset - curthread->ft[fd]->offset ;
++	curthread->ft[fd]->offset=uio.uio_offset;
++	lock_release(curthread->ft[fd]->lock);
++	*err=0;
++	return diff;
++}
++off_t
++lseek(int fd,off_t pos, int whence,int *err)
++{
++	off_t nPos=0;
++	struct stat eoFILE;
++	//kprintf("lseek entered\n");
++	if (curthread->ft[fd] == NULL)
++	{
++		*err = EBADF;
++		 return -1;
++	}
++	//kprintf("curthread->ft[fd] == NULL\n");
++	if ( fd < 0 || fd > OPEN_MAX)
++	{
++		*err = EBADF;
++		 return -1;
++	}
++	//kprintf("fd < 0 || fd > OPEN_MAX\n");
++	if (whence != SEEK_SET && whence != SEEK_CUR && whence != SEEK_END)
++	{
++		*err = EINVAL;
++		return -1;
++	}
++	//kprintf("whence != SEEK_SET || whence != SEEK_CUR || whence != SEEK_END\n");
++	//kprintf("Acquiring lock\n");
++	lock_acquire(curthread->ft[fd]->lock);
++	//kprintf("Stat gathering\n");
++	VOP_STAT(curthread->ft[fd]->vn,&eoFILE);
++	if (whence == SEEK_SET)
++	{
++		nPos = pos;
++	}
++	if (whence == SEEK_CUR)
++	{
++		nPos = curthread->ft[fd]->offset+pos;
++	}
++	if (whence == SEEK_END)
++	{
++		nPos = eoFILE.st_size+pos;
++	}
++	if (nPos < 0)
++	{
++		*err = EINVAL;
++		lock_release(curthread->ft[fd]->lock);
++		return -1;
++	}
++	//kprintf("NPos %llu\n",nPos);
++	*err = VOP_TRYSEEK(curthread->ft[fd]->vn,nPos);
++	if (*err)
++	{
++		lock_release(curthread->ft[fd]->lock);
++	    return -1;
++	}
++	curthread->ft[fd]->offset = nPos;
++	lock_release(curthread->ft[fd]->lock);
++	//kprintf("New position  %llu\n",nPos);
++	return curthread->ft[fd]->offset;
++}
++int
++dup2(int oldfd, int newfd)
++{
++	int ret;
++		if ( oldfd < 0 || oldfd > OPEN_MAX || newfd < 0 || newfd > OPEN_MAX)
++		{
++			return -1;
++		}
++		if (curthread->ft[oldfd] == NULL || curthread->ft[newfd] == NULL)
++		{
++			return -1;
++		}
++		if (curthread->ft[oldfd] == curthread->ft[newfd] || oldfd == newfd)
++		{
++		    return oldfd;
++		}
++		if (curthread->ft[newfd] != NULL)
++		{
++		   ret = close(newfd);
++		   if (ret)
++		      return -1;
++		}
++		curthread->ft[newfd] = curthread->ft[oldfd];
++		lock_acquire(curthread->ft[newfd]->lock);
++		curthread->ft[newfd]->ref_count++;
++		lock_release(curthread->ft[newfd]->lock);
++		return newfd;
++}
++
++int
++chdir(const_userptr_t pathname)
++{
++	char new_path[PATH_MAX];
++	size_t get;
++
++	if (pathname == NULL)
++	{
++		return -1;
++	}
++
++	int ret = copyinstr(pathname,new_path,PATH_MAX,&get);
++
++	if (ret)
++	{
++		return -1;
++	}
++
++	return vfs_chdir(new_path);
++}
++int
++__getcwd(userptr_t buf, size_t buflen)
++{
++	char path[PATH_MAX];
++	int ret;
++	struct iovec iov;
++	struct uio uio;
++	uio_kinit(&iov,&uio,path,PATH_MAX,0,UIO_READ);
++	ret = vfs_getcwd(&uio);
++	if (ret)
++	{
++		return -1;
++	}
++	ret = copyout((userptr_t)path,buf,buflen);
++	if (ret)
++	{
++		return -1;
++	}
++	return uio.uio_offset;
++}
+diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
+index a6f45c8..d18567f 100644
+--- a/kern/syscall/runprogram.c
++++ b/kern/syscall/runprogram.c
+@@ -44,7 +44,8 @@
+ #include <vfs.h>
+ #include <syscall.h>
+ #include <test.h>
+-
++#include <synch.h>
++#include <unistd.h>
+ /*
+  * Load program "progname" and start running it in usermode.
+  * Does not return except on error.
+@@ -58,6 +59,56 @@ runprogram(char *progname)
+ 	vaddr_t entrypoint, stackptr;
+ 	int result;
+ 
++	struct vnode *o, *i, *e;
++	char *con0 = kstrdup("con:");
++	char *con1 = kstrdup("con:");
++	char *con2 = kstrdup("con:");
++	int inpTemp = vfs_open(con0,O_RDONLY,0664,&i);
++	int outTemp = vfs_open(con1,O_WRONLY,0664,&o);
++	int errTemp = vfs_open(con2,O_WRONLY,0664,&e);
++	KASSERT(inpTemp!=1);
++	KASSERT(outTemp!=1);
++	KASSERT(errTemp!=1);
++
++	struct fTable *input, *output, *error;
++	input= kmalloc(sizeof(struct fTable));
++	output = kmalloc(sizeof(struct fTable));
++	error = kmalloc(sizeof(struct fTable));
++	KASSERT(input!=NULL);
++	KASSERT(output!=NULL);
++	KASSERT(error!=NULL);
++
++	input->name=kstrdup("Standard_Input");
++	input->offset=0;
++	input->ref_count =0;
++	input->status=O_RDONLY;
++	input->vn=i;
++	input->lock=lock_create("Standard Input");
++
++	output->name=kstrdup("Standard_Output");
++	output->offset=0;
++	output->ref_count =0;
++	output->status=O_WRONLY;
++	output->vn=o;
++	output->lock=lock_create("Standard Output");
++
++	error->name=kstrdup("Standard_Error");
++	error->offset=0;
++	error->ref_count =0;
++	error->status=O_WRONLY;
++	error->vn=e;
++	error->lock=lock_create("Standard Error");
++	KASSERT(input->lock!=NULL);
++	KASSERT(output->lock!=NULL);
++	KASSERT(error->lock!=NULL);
++
++	curthread->ft[STDIN_FILENO]=input;
++	curthread->ft[STDOUT_FILENO]=output;
++	curthread->ft[STDERR_FILENO]=error;
++	kfree(con0);
++	kfree(con1);
++	kfree(con2);
++	//kprintf("IO fd's initialized\n");
+ 	/* Open the file. */
+ 	result = vfs_open(progname, O_RDONLY, 0, &v);
+ 	if (result) {
+diff --git a/kern/test/malloctest.c b/kern/test/malloctest.c
+index b4dd87c..a8e4ba8 100644
+--- a/kern/test/malloctest.c
++++ b/kern/test/malloctest.c
+@@ -60,7 +60,6 @@ mallocthread(void *sm, unsigned long num)
+ 	void *oldptr=NULL;
+ 	void *oldptr2=NULL;
+ 	int i;
+-
+ 	for (i=0; i<NTRIES; i++) {
+ 		ptr = kmalloc(ITEMSIZE);
+ 		if (ptr==NULL) {
+diff --git a/kern/test/synchtest.c b/kern/test/synchtest.c
+index d072469..f106f4a 100644
+--- a/kern/test/synchtest.c
++++ b/kern/test/synchtest.c
+@@ -309,21 +309,23 @@ cvtest2thread(void *junk, unsigned long num)
+ {
+ 	int i;
+ 	(void)junk;
+-
+ 	for (i=0; i<NCVLOOPS; i++) {
+ 		lock_acquire(testlock);
+ 		while (testval1 != num) {
+-      testval2 = 0;
++			testval2 = 0;
++
+ 			cv_wait(testcv, testlock);
+-      testval2 = 0xFFFFFFFF;
++			testval2 = 0xFFFFFFFF;
+ 		}
+ 		testval2 = num;
++
+ 		cv_broadcast(testcv, testlock);
+ 		thread_yield();
+ 		kprintf("Thread %lu\n", testval2);
+ 		testval1 = (testval1 + NTHREADS - 1)%NTHREADS;
+ 		lock_release(testlock);
+ 	}
++	kprintf("cv2 test exiting\n");
+ 	V(donesem);
+ }
+ 
+@@ -344,6 +346,7 @@ cvtest2(int nargs, char **args)
+ 	for (i=0; i<NTHREADS; i++) {
+ 		result = thread_fork("synchtest", cvtest2thread, NULL, i,
+ 				      NULL);
++		//kprintf("Thread fork failure\n");
+ 		if (result) {
+ 			panic("cvtest: thread_fork failed: %s\n",
+ 			      strerror(result));
+diff --git a/kern/thread/synch.c b/kern/thread/synch.c
+index 9a7468c..7828129 100644
+--- a/kern/thread/synch.c
++++ b/kern/thread/synch.c
+@@ -47,20 +47,20 @@
+ struct semaphore *
+ sem_create(const char *name, int initial_count)
+ {
+-        struct semaphore *sem;
++	struct semaphore *sem;
+ 
+-        KASSERT(initial_count >= 0);
++	KASSERT(initial_count >= 0);
+ 
+-        sem = kmalloc(sizeof(struct semaphore));
+-        if (sem == NULL) {
+-                return NULL;
+-        }
++	sem = kmalloc(sizeof(struct semaphore));
++	if (sem == NULL) {
++			return NULL;
++	}
+ 
+-        sem->sem_name = kstrdup(name);
+-        if (sem->sem_name == NULL) {
+-                kfree(sem);
+-                return NULL;
+-        }
++	sem->sem_name = kstrdup(name);
++	if (sem->sem_name == NULL) {
++			kfree(sem);
++			return NULL;
++	}
+ 
+ 	sem->sem_wchan = wchan_create(sem->sem_name);
+ 	if (sem->sem_wchan == NULL) {
+@@ -70,9 +70,9 @@ sem_create(const char *name, int initial_count)
+ 	}
+ 
+ 	spinlock_init(&sem->sem_lock);
+-        sem->sem_count = initial_count;
++    sem->sem_count = initial_count;
+ 
+-        return sem;
++    return sem;
+ }
+ 
+ void
+@@ -81,8 +81,8 @@ sem_destroy(struct semaphore *sem)
+         KASSERT(sem != NULL);
+ 
+ 	/* wchan_cleanup will assert if anyone's waiting on it */
+-	spinlock_cleanup(&sem->sem_lock);
+-	wchan_destroy(sem->sem_wchan);
++		spinlock_cleanup(&sem->sem_lock);
++		wchan_destroy(sem->sem_wchan);
+         kfree(sem->sem_name);
+         kfree(sem);
+ }
+@@ -100,7 +100,7 @@ P(struct semaphore *sem)
+          */
+         KASSERT(curthread->t_in_interrupt == false);
+ 
+-	spinlock_acquire(&sem->sem_lock);
++        spinlock_acquire(&sem->sem_lock);
+         while (sem->sem_count == 0) {
+ 		/*
+ 		 * Bridge to the wchan lock, so if someone else comes
+@@ -120,24 +120,22 @@ P(struct semaphore *sem)
+ 		 */
+ 		wchan_lock(sem->sem_wchan);
+ 		spinlock_release(&sem->sem_lock);
+-                wchan_sleep(sem->sem_wchan);
+-
++	        wchan_sleep(sem->sem_wchan);
+ 		spinlock_acquire(&sem->sem_lock);
+-        }
+-        KASSERT(sem->sem_count > 0);
+-        sem->sem_count--;
++	}
++	KASSERT(sem->sem_count > 0);
++	sem->sem_count--;
+ 	spinlock_release(&sem->sem_lock);
+ }
+ 
+ void
+ V(struct semaphore *sem)
+ {
+-        KASSERT(sem != NULL);
++    KASSERT(sem != NULL);
++	spinlock_acquire(&sem->sem_lock); 
+ 
+-	spinlock_acquire(&sem->sem_lock);
+-
+-        sem->sem_count++;
+-        KASSERT(sem->sem_count > 0);
++	sem->sem_count++;
++	KASSERT(sem->sem_count > 0);
+ 	wchan_wakeone(sem->sem_wchan);
+ 
+ 	spinlock_release(&sem->sem_lock);
+@@ -158,20 +156,35 @@ lock_create(const char *name)
+         }
+ 
+         lock->lk_name = kstrdup(name);
++
+         if (lock->lk_name == NULL) {
+                 kfree(lock);
+                 return NULL;
+         }
+-        
++        //added by vasanth
++        lock->lock_owner=NULL;
++        lock->lock_wchan = wchan_create(lock->lk_name);
++		if (lock->lock_wchan == NULL)
++		{
++			kfree(lock->lk_name);
++			kfree(lock);
++			return NULL;
++		}
++		spinlock_init(&lock->spn_lock);
++
+         // add stuff here as needed
+-        
+         return lock;
+ }
+ 
+ void
+ lock_destroy(struct lock *lock)
+ {
++
+         KASSERT(lock != NULL);
++        //added by vasanth
++        //KASSERT(lock->lock_owner == NULL);
++        spinlock_cleanup(&lock->spn_lock);
++        wchan_destroy(lock->lock_wchan);
+ 
+         // add stuff here as needed
+         
+@@ -182,27 +195,61 @@ lock_destroy(struct lock *lock)
+ void
+ lock_acquire(struct lock *lock)
+ {
++		//added by vasanth
++		KASSERT(lock != NULL);
++		spinlock_acquire(&lock->spn_lock);
++		while (lock->lock_owner!=NULL)
++		{
++			wchan_lock(lock->lock_wchan);
++			spinlock_release(&lock->spn_lock);
++			wchan_sleep(lock->lock_wchan);
++			spinlock_acquire(&lock->spn_lock);
++		}
++		lock->lock_owner=curthread;
++		spinlock_release(&lock->spn_lock);
+         // Write this
+ 
+-        (void)lock;  // suppress warning until code gets written
++       // (void)lock;  // suppress warning until code gets written
+ }
+ 
+ void
+ lock_release(struct lock *lock)
+ {
+-        // Write this
+-
+-        (void)lock;  // suppress warning until code gets written
++		//added by vasanth
++ 		KASSERT(lock != NULL);
++		spinlock_acquire(&lock->spn_lock);
++		if(lock->lock_owner==curthread)
++		{
++			lock->lock_owner=NULL;
++			wchan_wakeall(lock->lock_wchan);
++		}
++		spinlock_release(&lock->spn_lock);
++		// Write this
++
++
++        //(void)lock;  // suppress warning until code gets written
+ }
+ 
+ bool
+ lock_do_i_hold(struct lock *lock)
+ {
+         // Write this
+-
+-        (void)lock;  // suppress warning until code gets written
+-
+-        return true; // dummy until code gets written
++	bool status;
++		spinlock_acquire(&lock->spn_lock);
++		if (lock->lock_owner==curthread)
++		{
++			status = true;
++		}
++		else
++		{
++			status = false;
++		}
++		spinlock_release(&lock->spn_lock);
++		return status;
++
++        //(void)lock;  // suppress warning until code gets written
++
++        //return true; // dummy until code gets written
+ }
+ 
+ ////////////////////////////////////////////////////////////
+@@ -217,26 +264,36 @@ cv_create(const char *name)
+ 
+         cv = kmalloc(sizeof(struct cv));
+         if (cv == NULL) {
+-                return NULL;
++        	return NULL;
+         }
+ 
+         cv->cv_name = kstrdup(name);
+         if (cv->cv_name==NULL) {
+-                kfree(cv);
+-                return NULL;
++            kfree(cv);
++            return NULL;
+         }
+         
+         // add stuff here as needed
++        /* Added by Babu :
++        * Adding a wait channel for making the threads wait during cv_acquire
++        */
++        cv->cv_waitchan = wchan_create(cv->cv_name);
++
+         
+         return cv;
+ }
+ 
++
+ void
+ cv_destroy(struct cv *cv)
+ {
+         KASSERT(cv != NULL);
+ 
+         // add stuff here as needed
++        /*
++         * Added by Babu : wchan destructor
++         */
++        wchan_destroy(cv->cv_waitchan);
+         
+         kfree(cv->cv_name);
+         kfree(cv);
+@@ -245,23 +302,180 @@ cv_destroy(struct cv *cv)
+ void
+ cv_wait(struct cv *cv, struct lock *lock)
+ {
+-        // Write this
+-        (void)cv;    // suppress warning until code gets written
+-        (void)lock;  // suppress warning until code gets written
++    // Write this
++	/** Release lock, wait and then acquire once awake */
++	KASSERT(cv != NULL);
++	KASSERT(lock != NULL);
++
++	//kprintf("Waiting in CV\n");
++
++	if(lock_do_i_hold(lock))
++		lock_release(lock);
++
++	//kprintf("Sleeping in CV\n");
++	wchan_lock(cv->cv_waitchan);
++	wchan_sleep(cv->cv_waitchan);
++
++	//kprintf("Came out of CV\n");
++
++	if(!lock_do_i_hold(lock))
++		lock_acquire(lock);
+ }
+ 
+ void
+ cv_signal(struct cv *cv, struct lock *lock)
+ {
+-        // Write this
+-	(void)cv;    // suppress warning until code gets written
+-	(void)lock;  // suppress warning until code gets written
++    // Write this
++	KASSERT(cv != NULL);
++	KASSERT(lock != NULL);
++
++	/*if(!lock_do_i_hold(lock))
++		lock_acquire(lock);*/
++
++	/*if(lock_do_i_hold(lock))
++		lock_release(lock);*/
++
++	//kprintf("Signaling CV\n");
++
++	wchan_wakeone(cv->cv_waitchan);
++	//wchan_unlock(cv->cv_waitchan);
++
++	/*if(!lock_do_i_hold(lock))
++		lock_acquire(lock);*/
++	(void) lock;
+ }
+ 
+ void
+ cv_broadcast(struct cv *cv, struct lock *lock)
+ {
+ 	// Write this
+-	(void)cv;    // suppress warning until code gets written
+-	(void)lock;  // suppress warning until code gets written
++	KASSERT(cv != NULL);
++	KASSERT(lock != NULL);
++
++	/*if(!lock_do_i_hold(lock))
++		lock_acquire(lock);*/
++
++	/*if(lock_do_i_hold(lock))
++		lock_release(lock);*/
++
++	//kprintf("Broadcasting CV\n");
++	wchan_wakeall(cv->cv_waitchan);
++
++
++	/*if(!lock_do_i_hold(lock))
++		lock_acquire(lock);*/
++
++
++	(void) lock;
++}
++
++struct rwlock *
++rwlock_create(const char *name)
++{
++	struct rwlock *rwlock;
++	rwlock = kmalloc(sizeof(struct rwlock));
++	if (rwlock == NULL)
++	{
++		return NULL;
++	}
++	rwlock->rwlock_name=kstrdup(name);
++	if (rwlock->rwlock_name == NULL)
++	{
++	    kfree(rwlock);
++	    return NULL;
++	}
++	rwlock->rlock_wchan = wchan_create(rwlock->rwlock_name);
++	if (rwlock->rlock_wchan == NULL)
++	{
++		kfree(rwlock->rwlock_name);
++		kfree(rwlock);
++		return NULL;
++	}
++	rwlock->wlock_wchan = wchan_create(rwlock->rwlock_name);
++	if (rwlock->wlock_wchan == NULL)
++	{
++		kfree(rwlock->rwlock_name);
++		wchan_destroy(rwlock->rlock_wchan);
++		kfree(rwlock);
++		return NULL;
++	}
++	rwlock->num_reader=0;
++	rwlock->num_writer=0;
++	rwlock->rw_lock = lock_create(rwlock->rwlock_name);
++	if (rwlock->rw_lock == NULL)
++	{
++		kfree(rwlock->rwlock_name);
++		wchan_destroy(rwlock->rlock_wchan);
++		wchan_destroy(rwlock->wlock_wchan);
++		kfree(rwlock);
++		return NULL;
++	}
++	return rwlock;
++
++}
++void
++rwlock_destroy(struct rwlock *rwlock)
++{
++	KASSERT(rwlock != NULL);
++	lock_destroy(rwlock->rw_lock);
++	wchan_destroy(rwlock->rlock_wchan);
++	wchan_destroy(rwlock->wlock_wchan);
++	kfree(rwlock->rwlock_name);
++	kfree(rwlock);
++}
++
++void
++rwlock_acquire_read(struct rwlock *rwlock)
++{
++	KASSERT(rwlock != NULL);
++	lock_acquire(rwlock->rw_lock);
++	while (rwlock->num_writer>0)
++	{
++		wchan_lock(rwlock->rlock_wchan);
++		lock_release(rwlock->rw_lock);
++		wchan_sleep(rwlock->rlock_wchan);
++		lock_acquire(rwlock->rw_lock);
++	}
++	rwlock->num_reader++;
++	lock_release(rwlock->rw_lock);
++}
++void
++rwlock_release_read(struct rwlock *rwlock)
++{
++	KASSERT(rwlock != NULL);
++	KASSERT(rwlock->num_reader > 0);
++	lock_acquire(rwlock->rw_lock);
++	if(rwlock->num_reader > 0)
++	{
++		rwlock->num_reader--;
++	}
++	wchan_wakeall(rwlock->wlock_wchan);
++	wchan_wakeall(rwlock->rlock_wchan);
++	lock_release(rwlock->rw_lock);
++}
++void
++rwlock_acquire_write(struct rwlock *rwlock)
++{
++	KASSERT(rwlock != NULL);
++	lock_acquire(rwlock->rw_lock);
++	while ((rwlock->num_reader>0) || (rwlock->num_writer > 0))
++	{
++		wchan_lock(rwlock->wlock_wchan);
++		lock_release(rwlock->rw_lock);
++		wchan_sleep(rwlock->wlock_wchan);
++		lock_acquire(rwlock->rw_lock);
++	}
++	rwlock->num_writer++;
++	lock_release(rwlock->rw_lock);
++}
++void
++rwlock_release_write(struct rwlock *rwlock)
++{
++	KASSERT(rwlock != NULL);
++	KASSERT(rwlock->num_writer > 0);
++	lock_acquire(rwlock->rw_lock);
++	rwlock->num_writer--;
++	wchan_wakeall(rwlock->rlock_wchan);
++	wchan_wakeall(rwlock->wlock_wchan);
++	lock_release(rwlock->rw_lock);
+ }
+diff --git a/kern/thread/thread.c b/kern/thread/thread.c
+index e7235e3..b1dcc73 100644
+--- a/kern/thread/thread.c
++++ b/kern/thread/thread.c
+@@ -47,6 +47,7 @@
+ #include <addrspace.h>
+ #include <mainbus.h>
+ #include <vnode.h>
++#include <limits.h>
+ 
+ #include "opt-synchprobs.h"
+ #include "opt-defaultscheduler.h"
+@@ -153,6 +154,19 @@ thread_create(const char *name)
+ 	thread->t_cwd = NULL;
+ 
+ 	/* If you add to struct thread, be sure to initialize here */
++	/*File descriptor*/
++		int i;
++		for (i=0;i<OPEN_MAX;i++)
++		{
++			thread->ft[i] = kmalloc(sizeof(struct file_table *));
++			if (thread->ft[i] == NULL)
++					{
++						kfree(thread);
++						return NULL;
++					}
++			thread->ft[i]=0;
++		}
++		thread->priority = 5;
+ 
+ 	return thread;
+ }
+@@ -263,6 +277,7 @@ thread_destroy(struct thread *thread)
+ 	thread->t_wchan_name = "DESTROYED";
+ 
+ 	kfree(thread->t_name);
++	//if(thread->ft!=NULL)kfree(thread->ft);
+ 	kfree(thread);
+ }
+ 
+@@ -483,7 +498,6 @@ thread_fork(const char *name,
+ 	    struct thread **ret)
+ {
+ 	struct thread *newthread;
+-
+ 	newthread = thread_create(name);
+ 	if (newthread == NULL) {
+ 		return ENOMEM;
+@@ -520,6 +534,8 @@ thread_fork(const char *name,
+ 	 */
+ 	newthread->t_iplhigh_count++;
+ 
++	//Might have to add the copy of the file table --vasanth
++
+ 	/* Set up the switchframe so entrypoint() gets called */
+ 	switchframe_init(newthread, entrypoint, data1, data2);
+ 
+@@ -574,6 +590,11 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
+ 
+ 	/* Check the stack guard band. */
+ 	thread_checkstack(cur);
++	if ( cur->priority > 0 && cur->priority< 10)
++	{
++		if (newstate == S_SLEEP)cur->priority--;     //increment priority if thread was sleeping
++		if (newstate == S_READY)cur->priority++;     //decrement priority if thread was ready
++	}
+ 
+ 	/* Lock the run queue. */
+ 	spinlock_acquire(&curcpu->c_runqueue_lock);
+@@ -585,6 +606,7 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
+ 		return;
+ 	}
+ 
++
+ 	/* Put the thread in the right place. */
+ 	switch (newstate) {
+ 	    case S_RUN:
+@@ -618,6 +640,7 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
+ 	}
+ 	cur->t_state = newstate;
+ 
++
+ 	/*
+ 	 * Get the next thread. While there isn't one, call md_idle().
+ 	 * curcpu->c_isidle must be true when md_idle is
+@@ -853,6 +876,24 @@ schedule(void)
+ {
+   // 28 Feb 2012 : GWA : Implement your scheduler that prioritizes
+   // "interactive" threads here.
++	spinlock_acquire(&curcpu->c_runqueue_lock);
++	if (curcpu->c_runqueue.tl_count>1)
++	{
++		struct threadlistnode *tnode = &curcpu->c_runqueue.tl_head;
++		while(tnode->tln_next->tln_next != NULL )
++		{
++			int head_priority =(int) curcpu->c_runqueue.tl_head.tln_next->tln_self->priority;
++			tnode = tnode->tln_next;
++			int curr_priority = tnode->tln_self->priority;
++			//kprintf("curr_priority %d\n",curr_priority);
++			if ( curr_priority < head_priority)
++			{
++				threadlist_remove(&curcpu->c_runqueue,tnode->tln_self);
++				threadlist_addhead(&curcpu->c_runqueue,tnode->tln_self);
++			}
++		}
++	}
++	spinlock_release(&curcpu->c_runqueue_lock);
+ }
+ #endif
+ 
+diff --git a/mk/os161.config.mk b/mk/os161.config.mk
+index 3de8771..8790d16 100644
+--- a/mk/os161.config.mk
++++ b/mk/os161.config.mk
+@@ -295,7 +295,7 @@
+ #
+ 
+ # Locations of things.
+-OSTREE=$(HOME)/os161/root	# Root directory to install into.
++OSTREE=$(HOME)/os161/root-team	# Root directory to install into.
+ WORKDIR=$(TOP)/build		# Top of tree to build into.
+ BUILDSYMLINKS=yes		# yes => link build -> $(BUILDTOP)/$(HERE).
+ 
+diff --git a/submit.patch b/submit.patch
+new file mode 100644
+index 0000000..45c474b
+--- /dev/null
++++ b/submit.patch
+@@ -0,0 +1,1815 @@
++diff --git a/defs.mk b/defs.mk
++new file mode 100644
++index 0000000..f62cde1
++--- /dev/null
+++++ b/defs.mk
++@@ -0,0 +1,20 @@
+++# This file was generated by configure. Edits will disappear if you rerun
+++# configure. If you find that you need to edit this file to make things
+++# work, let the course staff know and we'll try to fix the configure script.
+++#
+++# The purpose of this file is to hold all the makefile definitions
+++# needed to adjust the OS/161 build process to any particular
+++# environment. If I've done it right, all you need to do is rerun the
+++# configure script and make clean if you start working on a different
+++# host OS. If I've done it mostly right, you may need to edit this
+++# file but you still hopefully won't need to edit any of the
+++# makefiles.
+++#
+++# The things that can be set here are documented in mk/os161.config.mk.
+++#
+++
+++OSTREE=$(HOME)/root-team
+++PLATFORM=sys161
+++MACHINE=mips
+++COMPAT_CFLAGS=
+++COMPAT_TARGETS=
++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
++index 0f773bd..d205710 100644
++--- a/kern/arch/mips/syscall/syscall.c
+++++ b/kern/arch/mips/syscall/syscall.c
++@@ -36,6 +36,8 @@
++ #include <current.h>
++ #include <syscall.h>
++ 
+++#include <endian.h>
+++#include <copyinout.h>
++ 
++ /*
++  * System call dispatcher.
++@@ -80,6 +82,9 @@ syscall(struct trapframe *tf)
++ {
++ 	int callno;
++ 	int32_t retval;
+++	uint32_t retval2;
+++	uint64_t ar2,ret;
+++	int whence;
++ 	int err;
++ 
++ 	KASSERT(curthread != NULL);
++@@ -110,7 +115,52 @@ syscall(struct trapframe *tf)
++ 		break;
++ 
++ 	    /* Add stuff here */
++- 
+++	    case SYS_open:
+++	    retval = open((userptr_t)tf->tf_a0,
+++	    		(int)tf->tf_a1,&err);
+++	    break;
+++
+++   	    case SYS_close:
+++   	    err = close(tf->tf_a0);
+++        break;
+++
+++        case SYS_read:
+++        retval = read(tf->tf_a0,(userptr_t)tf->tf_a1,tf->tf_a2,&err);
+++        break;
+++
+++        case SYS_write:
+++        retval = write(tf->tf_a0,(userptr_t)tf->tf_a1,
+++        		tf->tf_a2,&err);
+++        break;
+++
+++        case SYS_dup2:
+++        err = dup2(tf->tf_a0,tf->tf_a1);
+++        break;
+++
+++        case SYS_lseek:
+++        join32to64(tf->tf_a2,tf->tf_a3,&ar2);
+++        //kprintf("Correct lseek called\n");
+++           if ((err = copyin((const_userptr_t)(tf->tf_sp+16), &whence, sizeof(whence))) != 0) {
+++               break;
+++           }
+++        ret = lseek((int)tf->tf_a0,ar2,whence,&err);
+++        //kprintf("ret value %llu\n",ret);
+++        split64to32(ret,(uint32_t *)&retval,(uint32_t *)&retval2);
+++        //kprintf("Retval %d,%d\n",retval,retval2);
+++        if (!err)
+++        {
+++        tf->tf_v1 = retval2;
+++        }
+++        break;
+++
+++        case SYS_chdir:
+++        err = chdir((const_userptr_t)tf->tf_a0);
+++        break;
+++
+++        case SYS___getcwd:
+++        err = __getcwd((userptr_t)tf->tf_a0,(size_t)tf->tf_a1);
+++        break;
+++
++ 	    default:
++ 		kprintf("Unknown syscall %d\n", callno);
++ 		err = ENOSYS;
++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
++index d527f61..4f9c76f 100644
++--- a/kern/conf/conf.kern
+++++ b/kern/conf/conf.kern
++@@ -367,6 +367,7 @@ file      vfs/devnull.c
++ file      syscall/loadelf.c
++ file      syscall/runprogram.c
++ file      syscall/time_syscalls.c
+++file	  syscall/file_syscalls.c
++ 
++ #
++ # Startup and initialization
++diff --git a/kern/include/fcntl.h b/kern/include/fcntl.h
++new file mode 100644
++index 0000000..40e3f6c
++--- /dev/null
+++++ b/kern/include/fcntl.h
++@@ -0,0 +1,100 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++#ifndef _KERN_FCNTL_H_
+++#define _KERN_FCNTL_H_
+++
+++/*
+++ * Constants for libc's <fcntl.h>.
+++ */
+++
+++
+++/*
+++ * Important
+++ */
+++
+++/* Flags for open: choose one of these: */
+++#define O_RDONLY      0      /* Open for read */
+++#define O_WRONLY      1      /* Open for write */
+++#define O_RDWR        2      /* Open for read and write */
+++/* then or in any of these: */
+++#define O_CREAT       4      /* Create file if it doesn't exist */
+++#define O_EXCL        8      /* With O_CREAT, fail if file already exists */
+++#define O_TRUNC      16      /* Truncate file upon open */
+++#define O_APPEND     32      /* All writes happen at EOF (optional feature) */
+++#define O_NOCTTY     64      /* Required by POSIX, != 0, but does nothing */
+++
+++/* Additional related definition */
+++#define O_ACCMODE     3      /* mask for O_RDONLY/O_WRONLY/O_RDWR */
+++
+++/*
+++ * Not so important
+++ */
+++
+++/* operation codes for flock() */
+++#define LOCK_SH         1       /* shared lock */
+++#define LOCK_EX         2       /* exclusive lock */
+++#define LOCK_UN         3       /* release the lock */
+++#define LOCK_NB         4       /* flag: don't block */
+++
+++/*
+++ * Mostly pretty useless
+++ */
+++
+++/* fcntl() operations */
+++#define F_DUPFD         0       /* like dup() but not quite */  
+++#define F_GETFD         1       /* get per-handle flags */
+++#define F_SETFD         2       /* set per-handle flags */
+++#define F_GETFL         3       /* get per-file flags (O_* open flags) */
+++#define F_SETFL         4       /* set per-file flags (O_* open flags) */
+++#define F_GETOWN        5       /* get process/pgroup for SIGURG and SIGIO */
+++#define F_SETOWN        6       /* set process/pgroup for SIGURG and SIGIO */
+++#define F_GETLK         7       /* inspect record locks */
+++#define F_SETLK         8       /* acquire record locks nonblocking */
+++#define F_SETLKW        9       /* acquire record locks and wait */
+++
+++/* flag for F_GETFD and F_SETFD */
+++#define FD_CLOEXEC      1       /* close-on-exec */
+++
+++/* modes for fcntl (F_GETLK/SETLK) locking */
+++#define F_RDLCK         0       /* shared lock */
+++#define F_WRLCK         1       /* exclusive lock */
+++#define F_UNLCK         2       /* unlock */
+++
+++/* struct for fcntl (F_GETLK/SETLK) locking */
+++struct flock {
+++	off_t l_start;          /* place in file */
+++	int l_whence;           /* SEEK_SET, SEEK_CUR, or SEEK_END */
+++	int l_type;             /* F_RDLCK or F_WRLCK */
+++	off_t l_len;            /* length of locked region */
+++	pid_t l_pid;            /* process that holds the lock */
+++};
+++
+++
+++#endif /* _KERN_FCNTL_H_ */
++diff --git a/kern/include/kern/limits.h b/kern/include/kern/limits.h
++index 3fad3f2..b2afe55 100644
++--- a/kern/include/kern/limits.h
+++++ b/kern/include/kern/limits.h
++@@ -96,5 +96,7 @@
++ /* Max number of iovec structures at once for readv/writev/preadv/pwritev */
++ #define __IOV_MAX       1024
++ 
+++/*Maximum length of file name */
+++
++ 
++ #endif /* _KERN_LIMITS_H_ */
++diff --git a/kern/include/seek.h b/kern/include/seek.h
++new file mode 100644
++index 0000000..cf1cfe6
++--- /dev/null
+++++ b/kern/include/seek.h
++@@ -0,0 +1,47 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++#ifndef _KERN_SEEK_H_
+++#define _KERN_SEEK_H_
+++
+++/*
+++ * Codes for lseek(), which are shared in libc between <fcntl.h> and
+++ * <unistd.h> and thus get their own file.
+++ *
+++ * These are pretty important. Back in the day (like 20+ years ago)
+++ * people would often just write the values 0, 1, and 2, but that's
+++ * really not recommended.
+++ */
+++
+++#define SEEK_SET      0      /* Seek relative to beginning of file */
+++#define SEEK_CUR      1      /* Seek relative to current position in file */
+++#define SEEK_END      2      /* Seek relative to end of file */
+++
+++
+++#endif /* _KERN_SEEK_H_ */
++diff --git a/kern/include/synch.h b/kern/include/synch.h
++index ac3714b..35565c6 100644
++--- a/kern/include/synch.h
+++++ b/kern/include/synch.h
++@@ -74,6 +74,10 @@ void V(struct semaphore *);
++  */
++ struct lock {
++         char *lk_name;
+++        //added by vasanth
+++        volatile struct thread *lock_owner;
+++        struct wchan *lock_wchan;
+++        struct spinlock spn_lock;
++         // add what you need here
++         // (don't forget to mark things volatile as needed)
++ };
++@@ -113,6 +117,7 @@ void lock_destroy(struct lock *);
++ 
++ struct cv {
++         char *cv_name;
+++        struct wchan *cv_waitchan;
++         // add what you need here
++         // (don't forget to mark things volatile as needed)
++ };
++@@ -140,9 +145,18 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
++ /*
++  * 13 Feb 2012 : GWA : Reader-writer locks.
++  */
++-
+++/* we use two waiting channels one for reader and one for writer we do this so that
+++ *if a writer is waiting all the readers will be put on sleep until the writers are
+++ *done with their writing
+++ */
++ struct rwlock {
++         char *rwlock_name;
+++        volatile int num_reader;
+++        volatile int num_writer;
+++        struct wchan *rlock_wchan;
+++        struct wchan *wlock_wchan;
+++        struct lock *rw_lock;
+++
++ };
++ 
++ struct rwlock * rwlock_create(const char *);
++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
++index befd3d8..6eb477d 100644
++--- a/kern/include/syscall.h
+++++ b/kern/include/syscall.h
++@@ -57,5 +57,12 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
++ 
++ int sys_reboot(int code);
++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
++-
+++int open(userptr_t filename, int flags,int *err);
+++int close(int fd);
+++int read(int fd, userptr_t buf, size_t buflen,int *err);
+++int write(int fd, userptr_t buf, size_t buflen,int *err);
+++int dup2(int oldfd, int newfd);
+++off_t lseek(int fd,off_t pos, int whence, int *err);
+++int chdir(const_userptr_t pathname);
+++int __getcwd(userptr_t buf, size_t buflen);
++ #endif /* _SYSCALL_H_ */
++diff --git a/kern/include/test.h b/kern/include/test.h
++index 240d583..7e24bde 100644
++--- a/kern/include/test.h
+++++ b/kern/include/test.h
++@@ -63,6 +63,17 @@ void whalemating_cleanup(void);
++  * Traffic light.
++  */
++ 
+++//volatile unsigned long intersectionOccupied = 0;
+++
+++/**
+++* Added by Babu:
+++* Locks for each quadrants
+++**/
+++struct lock *lockquad0;
+++struct lock *lockquad1;
+++struct lock *lockquad2;
+++struct lock *lockquad3;
+++
++ void inQuadrant(int);
++ void leaveIntersection(void);
++ int stoplight(int, char **);
++@@ -72,6 +83,7 @@ void turnleft(void *, unsigned long);
++ void turnright(void *, unsigned long);
++ void stoplight_init(void);
++ void stoplight_cleanup(void);
+++void inQuadrantSync(unsigned long);
++ 
++ /*
++  * Test code.
++diff --git a/kern/include/thread.h b/kern/include/thread.h
++index 86706ca..65e1f08 100644
++--- a/kern/include/thread.h
+++++ b/kern/include/thread.h
++@@ -38,7 +38,7 @@
++ 
++ #include <spinlock.h>
++ #include <threadlist.h>
++-
+++#include <limits.h>
++ struct addrspace;
++ struct cpu;
++ struct vnode;
++@@ -57,6 +57,7 @@ struct vnode;
++ #define SAME_STACK(p1, p2)     (((p1) & STACK_MASK) == ((p2) & STACK_MASK))
++ 
++ 
+++
++ /* States a thread can be in. */
++ typedef enum {
++ 	S_RUN,		/* running */
++@@ -65,6 +66,15 @@ typedef enum {
++ 	S_ZOMBIE,	/* zombie; exited but not yet deleted */
++ } threadstate_t;
++ 
+++struct fTable{
+++	    char *name;
+++	    int status;
+++	    off_t offset;
+++	    int ref_count;
+++	    struct lock *lock;
+++	    struct vnode *vn;
+++	};
+++
++ /* Thread structure. */
++ struct thread {
++ 	/*
++@@ -101,6 +111,8 @@ struct thread {
++ 	int t_curspl;			/* Current spl*() state */
++ 	int t_iplhigh_count;		/* # of times IPL has been raised */
++ 
+++
+++
++ 	/*
++ 	 * Public fields
++ 	 */
++@@ -112,8 +124,11 @@ struct thread {
++ 	struct vnode *t_cwd;		/* current working directory */
++ 
++ 	/* add more here as needed */
+++	struct fTable *ft[OPEN_MAX];          /*File table pointer*/
+++	int priority;
++ };
++ 
+++
++ /* Call once during system startup to allocate data structures. */
++ void thread_bootstrap(void);
++ 
++diff --git a/kern/include/unistd.h b/kern/include/unistd.h
++new file mode 100644
++index 0000000..30f2678
++--- /dev/null
+++++ b/kern/include/unistd.h
++@@ -0,0 +1,39 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++#ifndef _KERN_UNISTD_H_
+++#define _KERN_UNISTD_H_
+++
+++/* Constants for read/write/etc: special file handles */
+++#define STDIN_FILENO  0      /* Standard input */
+++#define STDOUT_FILENO 1      /* Standard output */
+++#define STDERR_FILENO 2      /* Standard error */
+++
+++
+++#endif /* _KERN_UNISTD_H_ */
++diff --git a/kern/startup/main.c b/kern/startup/main.c
++index be4c4b8..969575b 100644
++--- a/kern/startup/main.c
+++++ b/kern/startup/main.c
++@@ -1,3 +1,4 @@
+++/*vsubrama@buffalo.edu*/
++ /*
++  * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++  *	The President and Fellows of Harvard College.
++diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
++index 81d2f0e..b1d2a35 100644
++--- a/kern/synchprobs/problems.c
+++++ b/kern/synchprobs/problems.c
++@@ -35,6 +35,7 @@
++ #include <thread.h>
++ #include <test.h>
++ #include <synch.h>
+++#include <wchan.h>
++ 
++ /*
++  * 08 Feb 2012 : GWA : Driver code is in kern/synchprobs/driver.c. We will
++@@ -46,8 +47,71 @@
++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
++ // functions will allow you to do local initialization. They are called at
++ // the top of the corresponding driver code.
++-
+++struct whalemating{
+++	volatile int num_male_whale;
+++	volatile int num_female_whale;
+++	volatile int num_matchmaker_whale;
+++	struct wchan *male_wchan;
+++	struct wchan *female_wchan;
+++	struct wchan *matchmaker_wchan;
+++	struct wchan *match_wchan;
+++	volatile int match_found;
+++	struct lock *lock;
+++};
+++struct whalemating *whale_mating;
++ void whalemating_init() {
+++
+++
+++	whale_mating = kmalloc(sizeof(struct whalemating));
+++	if (whale_mating == NULL)
+++	{
+++		return;
+++	}
+++	whale_mating->male_wchan = wchan_create("name");
+++	if (whale_mating->male_wchan == NULL)
+++	{
+++		kfree(whale_mating);
+++		return;
+++	}
+++	whale_mating->female_wchan = wchan_create("name");
+++	if (whale_mating->female_wchan == NULL)
+++	{
+++		wchan_destroy(whale_mating->male_wchan);
+++		kfree(whale_mating);
+++		return;
+++	}
+++	whale_mating->matchmaker_wchan = wchan_create("name");
+++	if (whale_mating->matchmaker_wchan == NULL)
+++	{
+++		wchan_destroy(whale_mating->male_wchan);
+++		wchan_destroy(whale_mating->female_wchan);
+++		kfree(whale_mating);
+++		return;
+++	}
+++	whale_mating->match_wchan = wchan_create("name");
+++	if (whale_mating->matchmaker_wchan == NULL)
+++		{
+++			wchan_destroy(whale_mating->male_wchan);
+++			wchan_destroy(whale_mating->female_wchan);
+++			wchan_destroy(whale_mating->match_wchan);
+++			kfree(whale_mating);
+++			return;
+++		}
+++	whale_mating->lock = lock_create("name");
+++	if (whale_mating->lock == NULL)
+++	{
+++		wchan_destroy(whale_mating->male_wchan);
+++		wchan_destroy(whale_mating->female_wchan);
+++		wchan_destroy(whale_mating->matchmaker_wchan);
+++		wchan_destroy(whale_mating->match_wchan);
+++		kfree(whale_mating);
+++		return;
+++	}
+++	whale_mating->num_male_whale = 0;
+++	whale_mating->num_female_whale = 0;
+++	whale_mating->num_matchmaker_whale = 0;
+++	whale_mating->match_found=0;
+++
++   return;
++ }
++ 
++@@ -55,6 +119,12 @@ void whalemating_init() {
++ // care if your problems leak memory, but if you do, use this to clean up.
++ 
++ void whalemating_cleanup() {
+++	wchan_destroy(whale_mating->male_wchan);
+++	wchan_destroy(whale_mating->female_wchan);
+++	wchan_destroy(whale_mating->matchmaker_wchan);
+++	wchan_destroy(whale_mating->match_wchan);
+++	lock_destroy(whale_mating->lock);
+++	kfree(whale_mating);
++   return;
++ }
++ 
++@@ -64,9 +134,28 @@ male(void *p, unsigned long which)
++ 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
++   (void)which;
++   
++-  male_start();
++-	// Implement this function 
++-  male_end();
+++ male_start();
+++	// Implement this function
+++ lock_acquire(whale_mating->lock);
+++ while(whale_mating->num_male_whale>1)
+++ {
+++   wchan_lock(whale_mating->male_wchan);
+++   lock_release(whale_mating->lock);
+++   wchan_sleep(whale_mating->male_wchan);
+++   lock_acquire(whale_mating->lock);
+++ }
+++ whale_mating->num_male_whale++;
+++ wchan_wakeall(whale_mating->match_wchan);
+++ while(!(whale_mating->match_found==1))
+++ {
+++	 wchan_lock(whale_mating->match_wchan);
+++	 lock_release(whale_mating->lock);
+++	 wchan_sleep(whale_mating->match_wchan);
+++	 lock_acquire(whale_mating->lock);
+++ }
+++ lock_release(whale_mating->lock);
+++ male_end();
+++
++ 
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // whalemating driver can return to the menu cleanly.
++@@ -81,15 +170,36 @@ female(void *p, unsigned long which)
++   (void)which;
++   
++   female_start();
++-	// Implement this function 
+++
+++	// Implement this function
+++  lock_acquire(whale_mating->lock);
+++   while(whale_mating->num_female_whale>1)
+++   {
+++     wchan_lock(whale_mating->female_wchan);
+++     lock_release(whale_mating->lock);
+++     wchan_sleep(whale_mating->female_wchan);
+++     lock_acquire(whale_mating->lock);
+++   }
+++   whale_mating->num_female_whale++;
+++   wchan_wakeall(whale_mating->match_wchan);
+++   while(!(whale_mating->match_found==1))
+++   {
+++  	 wchan_lock(whale_mating->match_wchan);
+++  	 lock_release(whale_mating->lock);
+++  	 wchan_sleep(whale_mating->match_wchan);
+++  	 lock_acquire(whale_mating->lock);
+++   }
+++   lock_release(whale_mating->lock);
++   female_end();
++-  
+++
+++
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // whalemating driver can return to the menu cleanly.
++   V(whalematingMenuSemaphore);
++   return;
++ }
++ 
+++
++ void
++ matchmaker(void *p, unsigned long which)
++ {
++@@ -97,15 +207,43 @@ matchmaker(void *p, unsigned long which)
++   (void)which;
++   
++   matchmaker_start();
++-	// Implement this function 
+++  lock_acquire(whale_mating->lock);
+++  while(whale_mating->num_matchmaker_whale>1)
+++  {
+++     wchan_lock(whale_mating->matchmaker_wchan);
+++     lock_release(whale_mating->lock);
+++     wchan_sleep(whale_mating->matchmaker_wchan);
+++     lock_acquire(whale_mating->lock);
+++  }
+++  whale_mating->num_matchmaker_whale++;
+++  wchan_wakeall(whale_mating->match_wchan);
+++  while((whale_mating->num_male_whale == 0) || (whale_mating->num_female_whale == 0))
+++  {
+++	  wchan_lock(whale_mating->match_wchan);
+++	  lock_release(whale_mating->lock);
+++	  wchan_sleep(whale_mating->match_wchan);
+++	  lock_acquire(whale_mating->lock);
+++  }
+++  whale_mating->match_found=1;
+++  wchan_wakeall(whale_mating->match_wchan);
+++  whale_mating->num_male_whale--;
+++  whale_mating->num_female_whale--;
+++  whale_mating->num_matchmaker_whale--;
+++  whale_mating->match_found=0;
+++  wchan_wakeall(whale_mating->male_wchan);
+++  wchan_wakeall(whale_mating->female_wchan);
+++  wchan_wakeall(whale_mating->matchmaker_wchan);
+++  lock_release(whale_mating->lock);
+++	// Implement this function
++   matchmaker_end();
++-  
+++
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // whalemating driver can return to the menu cleanly.
++   V(whalematingMenuSemaphore);
++   return;
++ }
++ 
+++
++ /*
++  * You should implement your solution to the stoplight problem below. The
++  * quadrant and direction mappings for reference: (although the problem is,
++@@ -133,27 +271,48 @@ matchmaker(void *p, unsigned long which)
++  * functions in drivers.c.
++  */
++ 
+++/**
+++ * Added by Babu : 27 Feb 2012
+++ * Solving Stop light problem with the help
+++ * of locks and predefined semaphores.
+++ */
+++
+++
++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
++ // functions will allow you to do local initialization. They are called at
++ // the top of the corresponding driver code.
++ 
++ void stoplight_init() {
++-  return;
+++	lockquad0 = lock_create("quad0lk");
+++	lockquad1 = lock_create("quad1lk");
+++	lockquad2 = lock_create("quad2lk");
+++	lockquad3 = lock_create("quad3lk");
+++	return;
++ }
++ 
++ // 20 Feb 2012 : GWA : Adding at the suggestion of Nikhil Londhe. We don't
++ // care if your problems leak memory, but if you do, use this to clean up.
++ 
++ void stoplight_cleanup() {
++-  return;
+++	lock_destroy(lockquad0);
+++	lock_destroy(lockquad1);
+++	lock_destroy(lockquad2);
+++	lock_destroy(lockquad3);
+++	return;
++ }
++ 
++ void
++ gostraight(void *p, unsigned long direction)
++ {
++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
++-  (void)direction;
++-  
+++	unsigned long destQuadrant1 = direction;
+++	unsigned long destQuadrant2 = (direction + 3) % 4;
+++	kprintf("go straight....\n");
+++
+++	inQuadrantSync(destQuadrant1);
+++	inQuadrantSync(destQuadrant2);
+++	leaveIntersection();
+++
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // stoplight driver can return to the menu cleanly.
++   V(stoplightMenuSemaphore);
++@@ -163,8 +322,16 @@ gostraight(void *p, unsigned long direction)
++ void
++ turnleft(void *p, unsigned long direction)
++ {
+++	kprintf("turn left....\n");
++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
++-  (void)direction;
+++	unsigned long destQuadrant1 = direction;
+++	unsigned long destQuadrant2 = (direction + 3) % 4;
+++	unsigned long destQuadrant3 = (direction + 2) % 4;
+++
+++	inQuadrantSync(destQuadrant1);
+++	inQuadrantSync(destQuadrant2);
+++	inQuadrantSync(destQuadrant3);
+++	leaveIntersection();
++   
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // stoplight driver can return to the menu cleanly.
++@@ -175,11 +342,54 @@ turnleft(void *p, unsigned long direction)
++ void
++ turnright(void *p, unsigned long direction)
++ {
+++	kprintf("turn right....\n");
++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
++-  (void)direction;
+++	unsigned long destQuadrant1 = direction;
+++
+++	inQuadrantSync(destQuadrant1);
+++	leaveIntersection();
++ 
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // stoplight driver can return to the menu cleanly.
++   V(stoplightMenuSemaphore);
++   return;
++ }
+++
+++/*
+++ * Added by Babu
+++ * Function which serve as a wrapper to inQuadrant operations
+++ * along with synchronization primitive like lock
+++ */
+++void
+++inQuadrantSync(unsigned long destQuadrant)
+++{
+++	struct lock *lockquad;
+++	switch (destQuadrant)
+++	{
+++		case 0:
+++			lockquad = lockquad0;
+++			break;
+++		case 1:
+++			lockquad = lockquad1;
+++			break;
+++		case 2:
+++			lockquad = lockquad2;
+++			break;
+++		case 3:
+++			lockquad = lockquad3;
+++			break;
+++		default:
+++			panic("unknown direction");
+++			break;
+++	}
+++
+++	/* If the lock is not held before, then acquire it */
+++	if(lock_do_i_hold(lockquad))
+++	{
+++		lock_acquire(lockquad);
+++		inQuadrant(destQuadrant);
+++		kprintf("Releasing lock 0\n");
+++		lock_release(lockquad);
+++	}
+++	return;
+++}
++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
++new file mode 100644
++index 0000000..83f4d58
++--- /dev/null
+++++ b/kern/syscall/file_syscalls.c
++@@ -0,0 +1,341 @@
+++/*
+++ * file_syscalls.c
+++ *
+++ *  Created on: Mar 8, 2014
+++ *      Author: trinity
+++ */
+++#include <types.h>
+++#include <copyinout.h>
+++#include <lib.h>
+++#include <thread.h>
+++#include <syscall.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <fcntl.h>
+++#include <current.h>
+++#include <synch.h>
+++
+++#include <uio.h>
+++#include <kern/iovec.h>
+++#include <seek.h>
+++#include <stat.h>
+++#include <kern/errno.h>
+++
+++int
+++open(userptr_t filename, int flags,int *err)
+++{
+++	char *iobuff;
+++	int rFlag,vfs_ret;
+++	size_t aSize;
+++	if (filename == NULL)
+++	{
+++		*err = EFAULT;
+++		 return -1;
+++	}
+++	int tflags = flags & O_ACCMODE;
+++	if ( tflags != O_RDONLY && tflags != O_WRONLY && tflags !=O_RDWR )
+++	{
+++		kprintf("Failing in arguments\n");
+++		*err = EINVAL;
+++		return -1;
+++	}
+++	int i;
+++	for ( i=0;i<OPEN_MAX;i++)
+++	{
+++		if (curthread->ft[i] == NULL)
+++		{
+++			curthread->ft[i] = kmalloc(sizeof(struct fTable));
+++			if (curthread->ft[i] == NULL)
+++			{
+++				*err = ENOMEM;
+++				return -1;
+++			}
+++			curthread->ft[i]->lock = lock_create(curthread->t_name);
+++			if (curthread->ft[i]->lock == NULL)
+++			{
+++				kfree(curthread->ft[i]);
+++				curthread->ft[i] = NULL;
+++				*err = ENOMEM;
+++				return -1;
+++			}
+++			curthread->ft[i]->offset=0;
+++			curthread->ft[i]->ref_count=(curthread->ft[i]->ref_count) + 1;
+++			curthread->ft[i]->status = flags;
+++			iobuff = (char *)kmalloc(PATH_MAX*sizeof(char));
+++			if (iobuff == NULL)
+++			{
+++				lock_destroy(curthread->ft[i]->lock);
+++				kfree(curthread->ft[i]);
+++				curthread->ft[i] = NULL;
+++				*err = ENOMEM;
+++				return -1;
+++			}
+++			rFlag = copyinstr((const_userptr_t)filename,iobuff,PATH_MAX,&aSize);
+++			if(rFlag)
+++			{
+++				kfree(iobuff);
+++				lock_destroy(curthread->ft[i]->lock);
+++				kfree(curthread->ft[i]);
+++				curthread->ft[i] = NULL;
+++				*err = EFAULT;
+++				return -1;
+++			}
+++			vfs_ret=vfs_open((char *)filename,flags,0664,&(curthread->ft[i]->vn));
+++			if(vfs_ret)
+++			{
+++				kfree(iobuff);
+++				lock_destroy(curthread->ft[i]->lock);
+++				kfree(curthread->ft[i]);
+++				curthread->ft[i] = NULL;
+++				*err = vfs_ret;
+++				return -1;
+++			}
+++			*err = vfs_ret;
+++			return i;
+++		}
+++	}
+++	return 0;
+++}
+++int close(int fd)
+++{
+++	if ( fd < 0 || fd > OPEN_MAX)
+++	{
+++		return EBADF;
+++	}
+++	if (curthread->ft[fd] == NULL)
+++	{
+++		return EBADF;
+++	}
+++	lock_acquire(curthread->ft[fd]->lock);
+++	curthread->ft[fd]->ref_count=(curthread->ft[fd]->ref_count)-1;
+++	if(curthread->ft[fd]->ref_count == 0)
+++	{
+++		vfs_close(curthread->ft[fd]->vn);
+++		lock_release(curthread->ft[fd]->lock);
+++		lock_destroy(curthread->ft[fd]->lock);
+++		kfree(curthread->ft[fd]);
+++		curthread->ft[fd]=NULL;
+++		return 0;
+++	}
+++	else
+++	{
+++		lock_release(curthread->ft[fd]->lock);
+++		curthread->ft[fd]=NULL;
+++		return 0;
+++	}
+++	return 0;
+++}
+++
+++int
+++read(int fd, userptr_t buf, size_t buflen,int *err)
+++{
+++	int ret;
+++	if ( fd < 0 || fd > OPEN_MAX)
+++	{
+++		*err = EBADF;
+++		return -1;
+++	}
+++	if (curthread->ft[fd] == NULL)
+++	{
+++		*err = EBADF;
+++		return -1;
+++	}
+++	if (buf == NULL)
+++	{
+++		*err = EFAULT;
+++		return -1;
+++	}
+++	lock_acquire(curthread->ft[fd]->lock);
+++	struct iovec iov;
+++	struct uio uio;
+++
+++	iov.iov_ubase = buf;
+++	iov.iov_len = buflen;
+++
+++	uio.uio_iov = &iov;
+++	uio.uio_iovcnt = 1;
+++	uio.uio_offset = curthread->ft[fd]->offset;
+++	uio.uio_resid = buflen;
+++	uio.uio_segflg = UIO_USERSPACE;
+++	uio.uio_space = curthread->t_addrspace;
+++	uio.uio_rw=UIO_READ;
+++	if((ret = VOP_READ(curthread->ft[fd]->vn,&uio))!=0)
+++	{
+++		*err = ret;
+++		return -1;
+++	}
+++	int diff = uio.uio_offset - curthread->ft[fd]->offset;
+++	curthread->ft[fd]->offset=uio.uio_offset;
+++	lock_release(curthread->ft[fd]->lock);
+++	*err = 0;
+++	return diff;
+++}
+++int
+++write(int fd, userptr_t buf, size_t buflen, int *err)
+++{
+++	int ret;
+++	if ( fd < 0 || fd > OPEN_MAX)
+++	{
+++		*err = EBADF;
+++		return -1;
+++	}
+++	if (curthread->ft[fd] == NULL)
+++	{
+++		*err = EBADF;
+++		return -1;
+++	}
+++	if (buf == NULL)
+++	{
+++		*err = EFAULT;
+++		return -1;
+++	}
+++	lock_acquire(curthread->ft[fd]->lock);
+++	struct iovec iov;
+++	struct uio uio;
+++	iov.iov_ubase = buf;
+++	iov.iov_len = buflen;
+++	uio.uio_iov = &iov;
+++	uio.uio_iovcnt = 1;
+++	uio.uio_offset = curthread->ft[fd]->offset;
+++	uio.uio_resid = buflen;
+++	uio.uio_segflg = UIO_USERSPACE;
+++	uio.uio_space = curthread->t_addrspace;
+++	uio.uio_rw=UIO_WRITE;
+++	if((ret = VOP_WRITE(curthread->ft[fd]->vn,&uio))!=0)
+++	{
+++		*err = ret;
+++		return -1;
+++	}
+++	int diff = uio.uio_offset - curthread->ft[fd]->offset ;
+++	curthread->ft[fd]->offset=uio.uio_offset;
+++	lock_release(curthread->ft[fd]->lock);
+++	*err=0;
+++	return diff;
+++}
+++off_t
+++lseek(int fd,off_t pos, int whence,int *err)
+++{
+++	off_t nPos=0;
+++	struct stat eoFILE;
+++	//kprintf("lseek entered\n");
+++	if (curthread->ft[fd] == NULL)
+++	{
+++		*err = EBADF;
+++		 return -1;
+++	}
+++	//kprintf("curthread->ft[fd] == NULL\n");
+++	if ( fd < 0 || fd > OPEN_MAX)
+++	{
+++		*err = EBADF;
+++		 return -1;
+++	}
+++	//kprintf("fd < 0 || fd > OPEN_MAX\n");
+++	if (whence != SEEK_SET && whence != SEEK_CUR && whence != SEEK_END)
+++	{
+++		*err = EINVAL;
+++		return -1;
+++	}
+++	//kprintf("whence != SEEK_SET || whence != SEEK_CUR || whence != SEEK_END\n");
+++	//kprintf("Acquiring lock\n");
+++	lock_acquire(curthread->ft[fd]->lock);
+++	//kprintf("Stat gathering\n");
+++	VOP_STAT(curthread->ft[fd]->vn,&eoFILE);
+++	if (whence == SEEK_SET)
+++	{
+++		nPos = pos;
+++	}
+++	if (whence == SEEK_CUR)
+++	{
+++		nPos = curthread->ft[fd]->offset+pos;
+++	}
+++	if (whence == SEEK_END)
+++	{
+++		nPos = eoFILE.st_size+pos;
+++	}
+++	if (nPos < 0)
+++	{
+++		*err = EINVAL;
+++		lock_release(curthread->ft[fd]->lock);
+++		return -1;
+++	}
+++	//kprintf("NPos %llu\n",nPos);
+++	*err = VOP_TRYSEEK(curthread->ft[fd]->vn,nPos);
+++	if (*err)
+++	{
+++		lock_release(curthread->ft[fd]->lock);
+++	    return -1;
+++	}
+++	curthread->ft[fd]->offset = nPos;
+++	lock_release(curthread->ft[fd]->lock);
+++	//kprintf("New position  %llu\n",nPos);
+++	return curthread->ft[fd]->offset;
+++}
+++int
+++dup2(int oldfd, int newfd)
+++{
+++	int ret;
+++		if ( oldfd < 0 || oldfd > OPEN_MAX || newfd < 0 || newfd > OPEN_MAX)
+++		{
+++			return -1;
+++		}
+++		if (curthread->ft[oldfd] == NULL || curthread->ft[newfd] == NULL)
+++		{
+++			return -1;
+++		}
+++		if (curthread->ft[oldfd] == curthread->ft[newfd] || oldfd == newfd)
+++		{
+++		    return oldfd;
+++		}
+++		if (curthread->ft[newfd] != NULL)
+++		{
+++		   ret = close(newfd);
+++		   if (ret)
+++		      return -1;
+++		}
+++		curthread->ft[newfd] = curthread->ft[oldfd];
+++		lock_acquire(curthread->ft[newfd]->lock);
+++		curthread->ft[newfd]->ref_count++;
+++		lock_release(curthread->ft[newfd]->lock);
+++		return newfd;
+++}
+++
+++int
+++chdir(const_userptr_t pathname)
+++{
+++	char new_path[PATH_MAX];
+++	size_t get;
+++
+++	if (pathname == NULL)
+++	{
+++		return -1;
+++	}
+++
+++	int ret = copyinstr(pathname,new_path,PATH_MAX,&get);
+++
+++	if (ret)
+++	{
+++		return -1;
+++	}
+++
+++	return vfs_chdir(new_path);
+++}
+++int
+++__getcwd(userptr_t buf, size_t buflen)
+++{
+++	char path[PATH_MAX];
+++	int ret;
+++	struct iovec iov;
+++	struct uio uio;
+++	uio_kinit(&iov,&uio,path,PATH_MAX,0,UIO_READ);
+++	ret = vfs_getcwd(&uio);
+++	if (ret)
+++	{
+++		return -1;
+++	}
+++	ret = copyout((userptr_t)path,buf,buflen);
+++	if (ret)
+++	{
+++		return -1;
+++	}
+++	return uio.uio_offset;
+++}
++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
++index a6f45c8..d18567f 100644
++--- a/kern/syscall/runprogram.c
+++++ b/kern/syscall/runprogram.c
++@@ -44,7 +44,8 @@
++ #include <vfs.h>
++ #include <syscall.h>
++ #include <test.h>
++-
+++#include <synch.h>
+++#include <unistd.h>
++ /*
++  * Load program "progname" and start running it in usermode.
++  * Does not return except on error.
++@@ -58,6 +59,56 @@ runprogram(char *progname)
++ 	vaddr_t entrypoint, stackptr;
++ 	int result;
++ 
+++	struct vnode *o, *i, *e;
+++	char *con0 = kstrdup("con:");
+++	char *con1 = kstrdup("con:");
+++	char *con2 = kstrdup("con:");
+++	int inpTemp = vfs_open(con0,O_RDONLY,0664,&i);
+++	int outTemp = vfs_open(con1,O_WRONLY,0664,&o);
+++	int errTemp = vfs_open(con2,O_WRONLY,0664,&e);
+++	KASSERT(inpTemp!=1);
+++	KASSERT(outTemp!=1);
+++	KASSERT(errTemp!=1);
+++
+++	struct fTable *input, *output, *error;
+++	input= kmalloc(sizeof(struct fTable));
+++	output = kmalloc(sizeof(struct fTable));
+++	error = kmalloc(sizeof(struct fTable));
+++	KASSERT(input!=NULL);
+++	KASSERT(output!=NULL);
+++	KASSERT(error!=NULL);
+++
+++	input->name=kstrdup("Standard_Input");
+++	input->offset=0;
+++	input->ref_count =0;
+++	input->status=O_RDONLY;
+++	input->vn=i;
+++	input->lock=lock_create("Standard Input");
+++
+++	output->name=kstrdup("Standard_Output");
+++	output->offset=0;
+++	output->ref_count =0;
+++	output->status=O_WRONLY;
+++	output->vn=o;
+++	output->lock=lock_create("Standard Output");
+++
+++	error->name=kstrdup("Standard_Error");
+++	error->offset=0;
+++	error->ref_count =0;
+++	error->status=O_WRONLY;
+++	error->vn=e;
+++	error->lock=lock_create("Standard Error");
+++	KASSERT(input->lock!=NULL);
+++	KASSERT(output->lock!=NULL);
+++	KASSERT(error->lock!=NULL);
+++
+++	curthread->ft[STDIN_FILENO]=input;
+++	curthread->ft[STDOUT_FILENO]=output;
+++	curthread->ft[STDERR_FILENO]=error;
+++	kfree(con0);
+++	kfree(con1);
+++	kfree(con2);
+++	//kprintf("IO fd's initialized\n");
++ 	/* Open the file. */
++ 	result = vfs_open(progname, O_RDONLY, 0, &v);
++ 	if (result) {
++diff --git a/kern/test/malloctest.c b/kern/test/malloctest.c
++index b4dd87c..a8e4ba8 100644
++--- a/kern/test/malloctest.c
+++++ b/kern/test/malloctest.c
++@@ -60,7 +60,6 @@ mallocthread(void *sm, unsigned long num)
++ 	void *oldptr=NULL;
++ 	void *oldptr2=NULL;
++ 	int i;
++-
++ 	for (i=0; i<NTRIES; i++) {
++ 		ptr = kmalloc(ITEMSIZE);
++ 		if (ptr==NULL) {
++diff --git a/kern/test/synchtest.c b/kern/test/synchtest.c
++index d072469..f106f4a 100644
++--- a/kern/test/synchtest.c
+++++ b/kern/test/synchtest.c
++@@ -309,21 +309,23 @@ cvtest2thread(void *junk, unsigned long num)
++ {
++ 	int i;
++ 	(void)junk;
++-
++ 	for (i=0; i<NCVLOOPS; i++) {
++ 		lock_acquire(testlock);
++ 		while (testval1 != num) {
++-      testval2 = 0;
+++			testval2 = 0;
+++
++ 			cv_wait(testcv, testlock);
++-      testval2 = 0xFFFFFFFF;
+++			testval2 = 0xFFFFFFFF;
++ 		}
++ 		testval2 = num;
+++
++ 		cv_broadcast(testcv, testlock);
++ 		thread_yield();
++ 		kprintf("Thread %lu\n", testval2);
++ 		testval1 = (testval1 + NTHREADS - 1)%NTHREADS;
++ 		lock_release(testlock);
++ 	}
+++	kprintf("cv2 test exiting\n");
++ 	V(donesem);
++ }
++ 
++@@ -344,6 +346,7 @@ cvtest2(int nargs, char **args)
++ 	for (i=0; i<NTHREADS; i++) {
++ 		result = thread_fork("synchtest", cvtest2thread, NULL, i,
++ 				      NULL);
+++		//kprintf("Thread fork failure\n");
++ 		if (result) {
++ 			panic("cvtest: thread_fork failed: %s\n",
++ 			      strerror(result));
++diff --git a/kern/thread/synch.c b/kern/thread/synch.c
++index 9a7468c..7828129 100644
++--- a/kern/thread/synch.c
+++++ b/kern/thread/synch.c
++@@ -47,20 +47,20 @@
++ struct semaphore *
++ sem_create(const char *name, int initial_count)
++ {
++-        struct semaphore *sem;
+++	struct semaphore *sem;
++ 
++-        KASSERT(initial_count >= 0);
+++	KASSERT(initial_count >= 0);
++ 
++-        sem = kmalloc(sizeof(struct semaphore));
++-        if (sem == NULL) {
++-                return NULL;
++-        }
+++	sem = kmalloc(sizeof(struct semaphore));
+++	if (sem == NULL) {
+++			return NULL;
+++	}
++ 
++-        sem->sem_name = kstrdup(name);
++-        if (sem->sem_name == NULL) {
++-                kfree(sem);
++-                return NULL;
++-        }
+++	sem->sem_name = kstrdup(name);
+++	if (sem->sem_name == NULL) {
+++			kfree(sem);
+++			return NULL;
+++	}
++ 
++ 	sem->sem_wchan = wchan_create(sem->sem_name);
++ 	if (sem->sem_wchan == NULL) {
++@@ -70,9 +70,9 @@ sem_create(const char *name, int initial_count)
++ 	}
++ 
++ 	spinlock_init(&sem->sem_lock);
++-        sem->sem_count = initial_count;
+++    sem->sem_count = initial_count;
++ 
++-        return sem;
+++    return sem;
++ }
++ 
++ void
++@@ -81,8 +81,8 @@ sem_destroy(struct semaphore *sem)
++         KASSERT(sem != NULL);
++ 
++ 	/* wchan_cleanup will assert if anyone's waiting on it */
++-	spinlock_cleanup(&sem->sem_lock);
++-	wchan_destroy(sem->sem_wchan);
+++		spinlock_cleanup(&sem->sem_lock);
+++		wchan_destroy(sem->sem_wchan);
++         kfree(sem->sem_name);
++         kfree(sem);
++ }
++@@ -100,7 +100,7 @@ P(struct semaphore *sem)
++          */
++         KASSERT(curthread->t_in_interrupt == false);
++ 
++-	spinlock_acquire(&sem->sem_lock);
+++        spinlock_acquire(&sem->sem_lock);
++         while (sem->sem_count == 0) {
++ 		/*
++ 		 * Bridge to the wchan lock, so if someone else comes
++@@ -120,24 +120,22 @@ P(struct semaphore *sem)
++ 		 */
++ 		wchan_lock(sem->sem_wchan);
++ 		spinlock_release(&sem->sem_lock);
++-                wchan_sleep(sem->sem_wchan);
++-
+++	        wchan_sleep(sem->sem_wchan);
++ 		spinlock_acquire(&sem->sem_lock);
++-        }
++-        KASSERT(sem->sem_count > 0);
++-        sem->sem_count--;
+++	}
+++	KASSERT(sem->sem_count > 0);
+++	sem->sem_count--;
++ 	spinlock_release(&sem->sem_lock);
++ }
++ 
++ void
++ V(struct semaphore *sem)
++ {
++-        KASSERT(sem != NULL);
+++    KASSERT(sem != NULL);
+++	spinlock_acquire(&sem->sem_lock); 
++ 
++-	spinlock_acquire(&sem->sem_lock);
++-
++-        sem->sem_count++;
++-        KASSERT(sem->sem_count > 0);
+++	sem->sem_count++;
+++	KASSERT(sem->sem_count > 0);
++ 	wchan_wakeone(sem->sem_wchan);
++ 
++ 	spinlock_release(&sem->sem_lock);
++@@ -158,20 +156,35 @@ lock_create(const char *name)
++         }
++ 
++         lock->lk_name = kstrdup(name);
+++
++         if (lock->lk_name == NULL) {
++                 kfree(lock);
++                 return NULL;
++         }
++-        
+++        //added by vasanth
+++        lock->lock_owner=NULL;
+++        lock->lock_wchan = wchan_create(lock->lk_name);
+++		if (lock->lock_wchan == NULL)
+++		{
+++			kfree(lock->lk_name);
+++			kfree(lock);
+++			return NULL;
+++		}
+++		spinlock_init(&lock->spn_lock);
+++
++         // add stuff here as needed
++-        
++         return lock;
++ }
++ 
++ void
++ lock_destroy(struct lock *lock)
++ {
+++
++         KASSERT(lock != NULL);
+++        //added by vasanth
+++        //KASSERT(lock->lock_owner == NULL);
+++        spinlock_cleanup(&lock->spn_lock);
+++        wchan_destroy(lock->lock_wchan);
++ 
++         // add stuff here as needed
++         
++@@ -182,27 +195,61 @@ lock_destroy(struct lock *lock)
++ void
++ lock_acquire(struct lock *lock)
++ {
+++		//added by vasanth
+++		KASSERT(lock != NULL);
+++		spinlock_acquire(&lock->spn_lock);
+++		while (lock->lock_owner!=NULL)
+++		{
+++			wchan_lock(lock->lock_wchan);
+++			spinlock_release(&lock->spn_lock);
+++			wchan_sleep(lock->lock_wchan);
+++			spinlock_acquire(&lock->spn_lock);
+++		}
+++		lock->lock_owner=curthread;
+++		spinlock_release(&lock->spn_lock);
++         // Write this
++ 
++-        (void)lock;  // suppress warning until code gets written
+++       // (void)lock;  // suppress warning until code gets written
++ }
++ 
++ void
++ lock_release(struct lock *lock)
++ {
++-        // Write this
++-
++-        (void)lock;  // suppress warning until code gets written
+++		//added by vasanth
+++ 		KASSERT(lock != NULL);
+++		spinlock_acquire(&lock->spn_lock);
+++		if(lock->lock_owner==curthread)
+++		{
+++			lock->lock_owner=NULL;
+++			wchan_wakeall(lock->lock_wchan);
+++		}
+++		spinlock_release(&lock->spn_lock);
+++		// Write this
+++
+++
+++        //(void)lock;  // suppress warning until code gets written
++ }
++ 
++ bool
++ lock_do_i_hold(struct lock *lock)
++ {
++         // Write this
++-
++-        (void)lock;  // suppress warning until code gets written
++-
++-        return true; // dummy until code gets written
+++	bool status;
+++		spinlock_acquire(&lock->spn_lock);
+++		if (lock->lock_owner==curthread)
+++		{
+++			status = true;
+++		}
+++		else
+++		{
+++			status = false;
+++		}
+++		spinlock_release(&lock->spn_lock);
+++		return status;
+++
+++        //(void)lock;  // suppress warning until code gets written
+++
+++        //return true; // dummy until code gets written
++ }
++ 
++ ////////////////////////////////////////////////////////////
++@@ -217,26 +264,36 @@ cv_create(const char *name)
++ 
++         cv = kmalloc(sizeof(struct cv));
++         if (cv == NULL) {
++-                return NULL;
+++        	return NULL;
++         }
++ 
++         cv->cv_name = kstrdup(name);
++         if (cv->cv_name==NULL) {
++-                kfree(cv);
++-                return NULL;
+++            kfree(cv);
+++            return NULL;
++         }
++         
++         // add stuff here as needed
+++        /* Added by Babu :
+++        * Adding a wait channel for making the threads wait during cv_acquire
+++        */
+++        cv->cv_waitchan = wchan_create(cv->cv_name);
+++
++         
++         return cv;
++ }
++ 
+++
++ void
++ cv_destroy(struct cv *cv)
++ {
++         KASSERT(cv != NULL);
++ 
++         // add stuff here as needed
+++        /*
+++         * Added by Babu : wchan destructor
+++         */
+++        wchan_destroy(cv->cv_waitchan);
++         
++         kfree(cv->cv_name);
++         kfree(cv);
++@@ -245,23 +302,180 @@ cv_destroy(struct cv *cv)
++ void
++ cv_wait(struct cv *cv, struct lock *lock)
++ {
++-        // Write this
++-        (void)cv;    // suppress warning until code gets written
++-        (void)lock;  // suppress warning until code gets written
+++    // Write this
+++	/** Release lock, wait and then acquire once awake */
+++	KASSERT(cv != NULL);
+++	KASSERT(lock != NULL);
+++
+++	//kprintf("Waiting in CV\n");
+++
+++	if(lock_do_i_hold(lock))
+++		lock_release(lock);
+++
+++	//kprintf("Sleeping in CV\n");
+++	wchan_lock(cv->cv_waitchan);
+++	wchan_sleep(cv->cv_waitchan);
+++
+++	//kprintf("Came out of CV\n");
+++
+++	if(!lock_do_i_hold(lock))
+++		lock_acquire(lock);
++ }
++ 
++ void
++ cv_signal(struct cv *cv, struct lock *lock)
++ {
++-        // Write this
++-	(void)cv;    // suppress warning until code gets written
++-	(void)lock;  // suppress warning until code gets written
+++    // Write this
+++	KASSERT(cv != NULL);
+++	KASSERT(lock != NULL);
+++
+++	/*if(!lock_do_i_hold(lock))
+++		lock_acquire(lock);*/
+++
+++	/*if(lock_do_i_hold(lock))
+++		lock_release(lock);*/
+++
+++	//kprintf("Signaling CV\n");
+++
+++	wchan_wakeone(cv->cv_waitchan);
+++	//wchan_unlock(cv->cv_waitchan);
+++
+++	/*if(!lock_do_i_hold(lock))
+++		lock_acquire(lock);*/
+++	(void) lock;
++ }
++ 
++ void
++ cv_broadcast(struct cv *cv, struct lock *lock)
++ {
++ 	// Write this
++-	(void)cv;    // suppress warning until code gets written
++-	(void)lock;  // suppress warning until code gets written
+++	KASSERT(cv != NULL);
+++	KASSERT(lock != NULL);
+++
+++	/*if(!lock_do_i_hold(lock))
+++		lock_acquire(lock);*/
+++
+++	/*if(lock_do_i_hold(lock))
+++		lock_release(lock);*/
+++
+++	//kprintf("Broadcasting CV\n");
+++	wchan_wakeall(cv->cv_waitchan);
+++
+++
+++	/*if(!lock_do_i_hold(lock))
+++		lock_acquire(lock);*/
+++
+++
+++	(void) lock;
+++}
+++
+++struct rwlock *
+++rwlock_create(const char *name)
+++{
+++	struct rwlock *rwlock;
+++	rwlock = kmalloc(sizeof(struct rwlock));
+++	if (rwlock == NULL)
+++	{
+++		return NULL;
+++	}
+++	rwlock->rwlock_name=kstrdup(name);
+++	if (rwlock->rwlock_name == NULL)
+++	{
+++	    kfree(rwlock);
+++	    return NULL;
+++	}
+++	rwlock->rlock_wchan = wchan_create(rwlock->rwlock_name);
+++	if (rwlock->rlock_wchan == NULL)
+++	{
+++		kfree(rwlock->rwlock_name);
+++		kfree(rwlock);
+++		return NULL;
+++	}
+++	rwlock->wlock_wchan = wchan_create(rwlock->rwlock_name);
+++	if (rwlock->wlock_wchan == NULL)
+++	{
+++		kfree(rwlock->rwlock_name);
+++		wchan_destroy(rwlock->rlock_wchan);
+++		kfree(rwlock);
+++		return NULL;
+++	}
+++	rwlock->num_reader=0;
+++	rwlock->num_writer=0;
+++	rwlock->rw_lock = lock_create(rwlock->rwlock_name);
+++	if (rwlock->rw_lock == NULL)
+++	{
+++		kfree(rwlock->rwlock_name);
+++		wchan_destroy(rwlock->rlock_wchan);
+++		wchan_destroy(rwlock->wlock_wchan);
+++		kfree(rwlock);
+++		return NULL;
+++	}
+++	return rwlock;
+++
+++}
+++void
+++rwlock_destroy(struct rwlock *rwlock)
+++{
+++	KASSERT(rwlock != NULL);
+++	lock_destroy(rwlock->rw_lock);
+++	wchan_destroy(rwlock->rlock_wchan);
+++	wchan_destroy(rwlock->wlock_wchan);
+++	kfree(rwlock->rwlock_name);
+++	kfree(rwlock);
+++}
+++
+++void
+++rwlock_acquire_read(struct rwlock *rwlock)
+++{
+++	KASSERT(rwlock != NULL);
+++	lock_acquire(rwlock->rw_lock);
+++	while (rwlock->num_writer>0)
+++	{
+++		wchan_lock(rwlock->rlock_wchan);
+++		lock_release(rwlock->rw_lock);
+++		wchan_sleep(rwlock->rlock_wchan);
+++		lock_acquire(rwlock->rw_lock);
+++	}
+++	rwlock->num_reader++;
+++	lock_release(rwlock->rw_lock);
+++}
+++void
+++rwlock_release_read(struct rwlock *rwlock)
+++{
+++	KASSERT(rwlock != NULL);
+++	KASSERT(rwlock->num_reader > 0);
+++	lock_acquire(rwlock->rw_lock);
+++	if(rwlock->num_reader > 0)
+++	{
+++		rwlock->num_reader--;
+++	}
+++	wchan_wakeall(rwlock->wlock_wchan);
+++	wchan_wakeall(rwlock->rlock_wchan);
+++	lock_release(rwlock->rw_lock);
+++}
+++void
+++rwlock_acquire_write(struct rwlock *rwlock)
+++{
+++	KASSERT(rwlock != NULL);
+++	lock_acquire(rwlock->rw_lock);
+++	while ((rwlock->num_reader>0) || (rwlock->num_writer > 0))
+++	{
+++		wchan_lock(rwlock->wlock_wchan);
+++		lock_release(rwlock->rw_lock);
+++		wchan_sleep(rwlock->wlock_wchan);
+++		lock_acquire(rwlock->rw_lock);
+++	}
+++	rwlock->num_writer++;
+++	lock_release(rwlock->rw_lock);
+++}
+++void
+++rwlock_release_write(struct rwlock *rwlock)
+++{
+++	KASSERT(rwlock != NULL);
+++	KASSERT(rwlock->num_writer > 0);
+++	lock_acquire(rwlock->rw_lock);
+++	rwlock->num_writer--;
+++	wchan_wakeall(rwlock->rlock_wchan);
+++	wchan_wakeall(rwlock->wlock_wchan);
+++	lock_release(rwlock->rw_lock);
++ }
++diff --git a/kern/thread/thread.c b/kern/thread/thread.c
++index e7235e3..b1dcc73 100644
++--- a/kern/thread/thread.c
+++++ b/kern/thread/thread.c
++@@ -47,6 +47,7 @@
++ #include <addrspace.h>
++ #include <mainbus.h>
++ #include <vnode.h>
+++#include <limits.h>
++ 
++ #include "opt-synchprobs.h"
++ #include "opt-defaultscheduler.h"
++@@ -153,6 +154,19 @@ thread_create(const char *name)
++ 	thread->t_cwd = NULL;
++ 
++ 	/* If you add to struct thread, be sure to initialize here */
+++	/*File descriptor*/
+++		int i;
+++		for (i=0;i<OPEN_MAX;i++)
+++		{
+++			thread->ft[i] = kmalloc(sizeof(struct file_table *));
+++			if (thread->ft[i] == NULL)
+++					{
+++						kfree(thread);
+++						return NULL;
+++					}
+++			thread->ft[i]=0;
+++		}
+++		thread->priority = 5;
++ 
++ 	return thread;
++ }
++@@ -263,6 +277,7 @@ thread_destroy(struct thread *thread)
++ 	thread->t_wchan_name = "DESTROYED";
++ 
++ 	kfree(thread->t_name);
+++	//if(thread->ft!=NULL)kfree(thread->ft);
++ 	kfree(thread);
++ }
++ 
++@@ -483,7 +498,6 @@ thread_fork(const char *name,
++ 	    struct thread **ret)
++ {
++ 	struct thread *newthread;
++-
++ 	newthread = thread_create(name);
++ 	if (newthread == NULL) {
++ 		return ENOMEM;
++@@ -520,6 +534,8 @@ thread_fork(const char *name,
++ 	 */
++ 	newthread->t_iplhigh_count++;
++ 
+++	//Might have to add the copy of the file table --vasanth
+++
++ 	/* Set up the switchframe so entrypoint() gets called */
++ 	switchframe_init(newthread, entrypoint, data1, data2);
++ 
++@@ -574,6 +590,11 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
++ 
++ 	/* Check the stack guard band. */
++ 	thread_checkstack(cur);
+++	if ( cur->priority > 0 && cur->priority< 10)
+++	{
+++		if (newstate == S_SLEEP)cur->priority--;     //increment priority if thread was sleeping
+++		if (newstate == S_READY)cur->priority++;     //decrement priority if thread was ready
+++	}
++ 
++ 	/* Lock the run queue. */
++ 	spinlock_acquire(&curcpu->c_runqueue_lock);
++@@ -585,6 +606,7 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
++ 		return;
++ 	}
++ 
+++
++ 	/* Put the thread in the right place. */
++ 	switch (newstate) {
++ 	    case S_
+\ No newline at end of file
+diff --git a/user/testbin/fileonlytest/fileonlytest.c b/user/testbin/fileonlytest/fileonlytest.c
+index b807ff6..7776818 100644
+--- a/user/testbin/fileonlytest/fileonlytest.c
++++ b/user/testbin/fileonlytest/fileonlytest.c
+@@ -83,6 +83,7 @@ main(int argc, char **argv)
+ 			writebuf[j] = i * 2 * j;
+ 		}
+ 		len = write(fh, writebuf, sizeof(writebuf));
++		printf("Written %d bytes.\n",len);
+ 		if (len != sizeof(writebuf)) {
+ 			err(1, "write failed");
+ 		}
diff --git a/user/testbin/fileonlytest/fileonlytest.c b/user/testbin/fileonlytest/fileonlytest.c
index b807ff6..d43b0fc 100644
--- a/user/testbin/fileonlytest/fileonlytest.c
+++ b/user/testbin/fileonlytest/fileonlytest.c
@@ -83,6 +83,7 @@ main(int argc, char **argv)
 			writebuf[j] = i * 2 * j;
 		}
 		len = write(fh, writebuf, sizeof(writebuf));
+		printf("Written %d bytes.\n",len);
 		if (len != sizeof(writebuf)) {
 			err(1, "write failed");
 		}
@@ -159,7 +160,7 @@ main(int argc, char **argv)
 	}
 		
 	// 23 Mar 2012 : GWA : FIXME : Spin until exit() works.
-	
+	exit(0);
 	printf("Spinning in case exit() doesn't work.\n");
 	while (1) {};
 
diff --git a/user/testbin/sysexittest/Makefile b/user/testbin/sysexittest/Makefile
new file mode 100644
index 0000000..0f4e2be
--- /dev/null
+++ b/user/testbin/sysexittest/Makefile
@@ -0,0 +1,11 @@
+# Makefile for forktest
+
+TOP=../../..
+.include "$(TOP)/mk/os161.config.mk"
+
+PROG=sysexittest
+SRCS=sysexittest.c
+BINDIR=/testbin
+
+.include "$(TOP)/mk/os161.prog.mk"
+
diff --git a/user/testbin/sysexittest/sysexittest.c b/user/testbin/sysexittest/sysexittest.c
new file mode 100644
index 0000000..0dcb72e
--- /dev/null
+++ b/user/testbin/sysexittest/sysexittest.c
@@ -0,0 +1,34 @@
+
+/*
+ * forktest - test fork().
+ *
+ * This should work correctly when fork is implemented.
+ *
+ * It should also continue to work after subsequent assignments, most
+ * notably after implementing the virtual memory system.
+ */
+
+#include <unistd.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <err.h>
+
+
+int
+main()
+{
+	//printf("entering sysexit test");
+	int pid = fork();
+	if(pid == 0)
+	{
+		warnx("child thread");
+	}
+	else
+	{
+		warnx("parent thread");
+	}			
+	warnx(" fork pid : %d \n", pid);
+	exit(0);
+	return 0;
+}
